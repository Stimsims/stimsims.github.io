{"version":3,"sources":["webpack:///./node_modules/nerdamer/Extra.js","webpack:///./node_modules/nerdamer/Calculus.js","webpack:///./node_modules/nerdamer/Solve.js","webpack:///./node_modules/nerdamer/Algebra.js","webpack:///./node_modules/nerdamer/all.js"],"names":["nerdamer","core","getCore","_","PARSER","Symbol","format","Utils","isVector","isArray","S","Vector","groups","CP","EX","CB","FN","Settings","Laplace_integration_depth","prototype","findFunction","fname","this","group","clone","found","symbols","x","__","Extra","version","LaPlace","transform","symbol","t","s","toString","retval","coeff","unwrapSQRT","stripVar","g","divide","isConstant","contains","parse","isInt","power","n","String","equals","isComposite","each","add","isE","indexOf","args","depth_is_lower","integration_depth","block","u","sym","sub","integration_expr","Calculus","integrate","hasIntegral","error","expand","multiply","a","inverse","s_","input_symbol","num","den","f","m","den_p","fact","p","finalize","multiplier","toUnitMultiplier","getNum","getDenom","toLinear","Frac","decompose_fn","value","b","Math2","factorial","pow","isLinear","console","log","new_num","fn1","fn2","a_has_sin","b_has_cos","a_has_cos","b_has_sin","sin","cos","c","e","f2","containsFunction","d","exp","s_terms","collectSymbols","unwrapPARENS","sort","p1","i","length","fc","push","negate","symfunction","Statistics","frequencyMap","arr","map","l","key","subtract","count","sum","x_","xi","mean","slice","call","arguments","apply","elements","median","sorted","even","mid","Math","floor","mode","keys","freq","max","gVariance","k","variance","sampleVariance","standardDeviation","sampleStandardDeviation","zScore","stdev","Units","table","foot","meter","decimeter","register","name","visible","numargs","build","api","isSymbol","text","inBrackets","evaluate","N","PL","P","LOG","SQRT","SIN","COS","TAN","SEC","CSC","COT","SINH","COSH","NoIntegralFound","msg","message","Error","fnTransform","lessThan","hasTrig","in_trig","in_inverse_trig","Expression","toCommonDenominator","denominator","numerator","factor","Algebra","in_htrig","all_functions","cosAsinBtransform","cosAsinBtranform","symbol1","symbol2","cosAsinAtransform","cosAsinAtranform","Number","sinAsinBtransform","trigTransform","max_lim_depth","fn","index","start","end","exceptions","NerdamerTypeError","isNumericSymbol","modifier","subs","ans","product","diff","wrt","nth","vector","isMatrix","matrix","Matrix","j","set","undefined","variables","sp","derive","polydiff","cp","result","df","product_rule","qdiff","arg","y_","LOG10","updateHash","val","altVal","integration","u_substitution","dx","try_combo","q","do_fn_sub","subbed","Q","g1","g2","poly_integrate","dc","decompose_arg","xp","dc2","new_val","by_parts","integrated","A","Factor","B","f1","toDecimal","stop","warn","partial_fraction","input","depth","opt","partial_fractions","PartFrac","partfrac","get_udv","parts","setSymbol","dv","part","trig_sub","greaterThan","getU","du","integral","clearU","o","udv","v","vdu","uv","integral_vdu","vdu_s","previous","is_cyclic","pop","rem","original_symbol","dt","vars","isNaN","previousGroup","PARENTHESIS","aa","decomp","ax","b_is_positive","unwrapAbs","C","D","E","F","L1","L2","br","d2","sqrt_a","sqrt_ax","sqa","sqb","aob","bsqi","invert","abs","was_factored","degree","fx","sq","sqComplete","u_du","ag","decomposed","hasFunc","a_","b_","rd","rd2","na","r","w","n1","n2","parse_str","cfsymbol","isPoly","unwrapped","sym1","sym2","arg1","arg2","new_sym","p1_even","p2_even","double_angle","sign","trans","transformed","sym1_is_linear","pd","min","pc","f_is_linear","p2","dummy","bksub","ASIN","u_transform","sqrt","expanded","y","U","scope","U2","factors","Classes","Factors","coeffFactor","div","cosn","X","sym2_clone","sa","sb","nq","syma","symb","first","intg","DivisionByZero","defint","from","to","get_value","point","Limit","limit","num_integrate","upper","lower","interval","diverges","lim","fin","gin","lim_sign","isInfinity","fm","gm","L","lim1","lim2","indeterminate","ft","gt","t_symbol","den_is_zero","infinity","rewriteToLog","getSubbed","isInterval","isConvergent","Simplify","simplify","_num","_den","isOne","symbol_","base","lim_base","lim_pow","evaluates","trial","s_arg","pi","divergent","FACTORIAL","_lim","_symbols","fns","unshift","Fresnel","_A","_C","explode","remove","range","Equation","lhs","rhs","IMAGINARY","NerdamerValueError","LHS","RHS","SOLVE_RADIUS","ROOTS_PER_SIDE","make_pi_conversions","STEP_SIZE","MAX_NEWTON_ITERATIONS","MAX_NON_LINEAR_TRIES","NON_LINEAR_JUMP_AT","NON_LINEAR_JUMP_SIZE","NON_LINEAR_START","NEWTON_SLICES","NEWTON_EPSILON","EPSILON","SOLUTION_PROXIMITY","FILTER_SOLUTIONS","MAX_SOLVE_DEPTH","hasNegativeTerms","option","toLHS","eqn","removeDenom","_t","newRHS","isZero","latex","join","solveFor","_solve","arrayUnique","concat","jacobian","eqns","getSystemVariables","forEach","eq","cMatrix","setEq","checkAll","test","Solve","solutions","solve","variable","solution","es","split","solveNonLinearSystem","tries","max_tries","halfway","iters","xn1","norm","lnorm","xn","jump_at","jump","create_subs","get","max_iter","f_eqns","J","systemSolutions","round","expand_result","callback","SOLUTIONS_AS_OBJECT","idx","valueOf","solveSystem","var_array","allLinear","setVar","coeffs","cf","arraySum","term","check","z","err","tparts","determinant","SolveError","quad","discriminant","det","cubic","d_o","c_o","b_o","a_o","d0","Ct","replace","quartic","D0","D1","divideAndConquer","solve_for","sols","csolve","pn","pf","sr","roots","root","str","toPolarFormArray","getPoints","step","points","last","last_sign","rside","lside","left","right","test_side","side","num_roots","hits","isFinite","Newton","fp","maxiter","iter","x0","fx0","rewrite","for_variable","sqrts","distributeMultiplier","sqrtSolve","filter","isImaginary","existing","add_to_result","has_trig","r_is_symbol","sol","temp","PI","r_str","sf","numvars","cfact","fractionals","correct_denom","original","is_sqrt","min_p","arrayMin","corrected","separate","inverseFunctionSolve","fkeys","getNumberSymbolics","deg","getCoeffs","was_calculated","proots","factored","points1","points2","points3","separated","rw","neq","parent","CONST_HASH","math","importFunctions","Polynomial","order","InvalidVariableNameError","fill","MVTerm","terms","image","fromArray","fit","c1","c2","Array","absEquals","trim","equalsZero","modP","mod","up_one","next","poly","dividend","arrayClone","divisor","mp","quotient","l1","l2","x1","x2","lc","monic","gcd","QGCD","new_array","gcf","toPolynomial","ca","fnz","parr","incl_img","dsc","squareFree","output","equalsNumber","toSymbol","plus","with_order","imaginary","tBase","nterm","updateCount","altVar","sameVars","groupTerms","egrouped","grouped","el","collectFactors","fo","firstObject","obj","preAdd","pFactor","is_constant","Object","values","merge","clean","h","getVars","getRevMap","rev_map","len","mapped","generateImage","getImg","mvterm","new_mvterm","toMapObj","filledArray","clss","arrSum","haveIntersection","some","subFunctions","tvar","getFunctionsSubs","init","decp","known_roots","get_roots","rarr","powers","calcroots","lowest_pow","lowest_symbol","minpower","arrayMax","last_power","ValueLimitExceededError","zeroi","degreePar","Degree","zeror","QuadSD_ak1","NN","iPar","calcSC_ak1","DBL_EPSILON","K","qk","sdPar","dumFlag","a3","a1","a7","nextK_ak1","tFlag","qp","newest_ak1","a4","a5","b1","b2","c3","c4","Quad_ak1","si","lr","li","QuadIT_ak1","uu","vv","calcPar","ee","omp","relstp","ui","vi","zm","qPar","triedFlag","NZ","szr","szi","lzr","lzi","RealIT_ak1","kv","ms","pv","nm1","Fxshfr_ak1","MDP1","betas","betav","oss","ots","otv","ovv","ss","ts","tss","tv","tvv","fflag","spass","stry","vpass","vtry","svk","iFlag","degPar","bnd","ff","moduli_max","moduli_min","sc","xm","bb","cc","xxx","jj","NM1","zerok","LB2","LN2","pt","Fxshfr_Par","LO","MIN_VALUE","cosr","sinr","xx","yy","MAX_VALUE","rpSolve","img","real","nroots","froot","guess","Function","done","safety","newtonraph","sumProd","_coeffs","polyPowers","mix","include_negatives","ll","common","zeroes","exit","tp","allSame","n_terms","n_zeroes","_symbol","_factor","_factored","quadFactor","root1","root2","isSimple","untouched","den_array","num_array","dfact","nfact","strip","unstrip","multiVar","all_S","all_unit","coeff_factors","power_factors","powerFactor","mfactor","t_factors","trialAndError","tf_symbol","t_factor","reduce","nn","sqfr","allNumeric","cnst","cfactors","ifactor","search","candidate","ltfactors","nfactors","ceil","lc_is_neg","cnst_is_neg","factor_found","isPrime","mSqfrFactor","reverse","can_divide","is_factor","sqdiff","remove_square","obj_array","constants","powSimp","factors2","maxes","new_factor","divided","neg_numeric_factor","status","sg","arguments2Array","appeared","splice","every","aggregate","gcd_","lcm","gcd_m","GCD","gcd_v","gcd_p","vars_a","vars_b","T","multipliers","numer","prev","curr","denom_args","size","mask","results","total","isVariableSymbol","denom","remainder","create","symbol1_has_func","symbol2_has_func","parse_funcs","quot","reconvert","get_unique_max","any","t_map","init_sort","is_larger","s1","s2","get_det","lookat","umax","is_equal","max1","max2","idx1","idx2","item1","item2","d1","cterm","lead_var","blv","alv","checked","tt","try_better_lead_var","fdt","fnt","nd","dividend_larger","shift","neg","cur","line","v1","v2","convertToVector","dy","createTemplate","denom_factors","f_array","factors_vec","degrees","efactor","as_array","ofactors","nterms","dterms","M","ks","template","tfactors","fillHoles","transpose","partials","sd","distributeExponent","raw","complexSimp","ac","bd","bc","ad","cd","r1","r2","i1","i2","realpart","imagpart","trigSimp","sym_array","tr","fracSimp","ratSimp","simplified","useAlgebraDiv","divideFn","calls","useParserDiv","module","exports"],"mappings":"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","file":"nerdamer~app-499f0d101f5ee95501f6.js","sourcesContent":["require(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nrequire(\"core-js/modules/es6.string.sub\");\n\nrequire(\"core-js/modules/es6.array.index-of\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus');\n\n  require('./Algebra');\n}\n\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      Symbol = core.Symbol,\n      format = core.Utils.format,\n      isVector = core.Utils.isVector,\n      isArray = core.Utils.isArray,\n      Vector = core.Vector,\n      S = core.groups.S,\n      EX = core.groups.EX,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      FN = core.groups.FN;\n  core.Settings.Laplace_integration_depth = 40;\n\n  Symbol.prototype.findFunction = function (fname) {\n    //this is what we're looking for\n    if (this.group === FN && this.fname === fname) return this.clone();\n    var found;\n    if (this.symbols) for (var x in this.symbols) {\n      found = this.symbols[x].findFunction(fname);\n      if (found) break;\n    }\n    return found;\n  };\n\n  var __ = core.Extra = {\n    version: '1.4.1',\n    //http://integral-table.com/downloads/LaplaceTable.pdf\n    //Laplace assumes all coefficients to be positive\n    LaPlace: {\n      //Using: integral_0^oo f(t)*e^(-s*t) dt\n      transform: function transform(symbol, t, s) {\n        t = t.toString(); //First try a lookup for a speed boost\n\n        symbol = Symbol.unwrapSQRT(symbol, true);\n        var retval,\n            coeff = symbol.stripVar(t),\n            g = symbol.group;\n        symbol = _.divide(symbol, coeff.clone());\n\n        if (symbol.isConstant() || !symbol.contains(t, true)) {\n          retval = _.parse(format('({0})/({1})', symbol, s));\n        } else if (g === S && core.Utils.isInt(symbol.power)) {\n          var n = String(symbol.power);\n          retval = _.parse(format('factorial({0})/({1})^({0}+1)', n, s));\n        } else if (symbol.group === S && symbol.power.equals(1 / 2)) {\n          retval = _.parse(format('sqrt(pi)/(2*({0})^(3/2))', s));\n        } else if (symbol.isComposite()) {\n          retval = new Symbol(0);\n          symbol.each(function (x) {\n            retval = _.add(retval, __.LaPlace.transform(x, t, s));\n          }, true);\n        } else if (symbol.isE() && (symbol.power.group === S || symbol.power.group === CB)) {\n          var a = symbol.power.stripVar(t);\n          retval = _.parse(format('1/(({1})-({0}))', a, s));\n        } else {\n          var fns = ['sin', 'cos', 'sinh', 'cosh']; //support for symbols in fns with arguments in the form a*t or n*t where a = symbolic and n = Number\n\n          if (symbol.group === FN && fns.indexOf(symbol.fname) !== -1 && (symbol.args[0].group === S || symbol.args[0].group === CB)) {\n            var a = symbol.args[0].stripVar(t);\n\n            switch (symbol.fname) {\n              case 'sin':\n                retval = _.parse(format('({0})/(({1})^2+({0})^2)', a, s));\n                break;\n\n              case 'cos':\n                retval = _.parse(format('({1})/(({1})^2+({0})^2)', a, s));\n                break;\n\n              case 'sinh':\n                retval = _.parse(format('({0})/(({1})^2-({0})^2)', a, s));\n                break;\n\n              case 'cosh':\n                retval = _.parse(format('({1})/(({1})^2-({0})^2)', a, s));\n                break;\n            }\n          } else {\n            //Try to integrate for a solution\n            //we need at least the Laplace integration depth\n            var depth_is_lower = core.Settings.integration_depth < core.Settings.Laplace_integration_depth;\n\n            if (depth_is_lower) {\n              var integration_depth = core.Settings.integration_depth; //save the depth\n\n              core.Settings.integration_depth = core.Settings.Laplace_integration_depth; //transforms need a little more room\n            }\n\n            core.Utils.block('PARSE2NUMBER', function () {\n              var u = t;\n              var sym = symbol.sub(t, u);\n\n              var integration_expr = _.parse('e^(-' + s + '*' + u + ')*' + sym);\n\n              retval = core.Calculus.integrate(integration_expr, u);\n              if (retval.hasIntegral()) _.error('Unable to compute transform');\n              retval = retval.sub(t, 0);\n              retval = _.expand(_.multiply(retval, new Symbol(-1)));\n              retval = retval.sub(u, t);\n            }, false);\n            retval = core.Utils.block('PARSE2NUMBER', function () {\n              return _.parse(retval);\n            }, true);\n            if (depth_is_lower) //put the integration depth as it was\n              core.Settings.integration_depth = integration_depth;\n          }\n        }\n\n        return _.multiply(retval, coeff);\n      },\n      inverse: function inverse(symbol, s_, t) {\n        var input_symbol = symbol.clone();\n        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n          if (symbol.group === S || symbol.group === CB || symbol.group === CP) {\n            var finalize = function finalize() {\n              //put back the numerator\n              retval = _.multiply(retval, num);\n              retval.multiplier = retval.multiplier.multiply(symbol.multiplier); //put back a\n\n              retval = _.divide(retval, f.a);\n            };\n\n            var num, den, s, retval, f, p, m, den_p, fe; //remove the multiplier\n\n            m = symbol.multiplier.clone();\n            symbol.toUnitMultiplier(); //get the numerator and denominator\n\n            num = symbol.getNum();\n            den = symbol.getDenom().toUnitMultiplier(); //TODO: Make it so factor doesn't destroy pi\n            //num = core.Algebra.Factor.factor(symbol.getNum());\n            //den = core.Algebra.Factor.factor(symbol.getDenom().invert(null, true));\n\n            if (den.group === CP) {\n              den_p = den.power.clone();\n              den.toLinear();\n            } else den_p = new core.Frac(1); //convert s to a string\n\n\n            s = s_.toString(); //split up the denominator if in the form ax+b\n\n            f = core.Utils.decompose_fn(den, s, true); //move the multiplier to the numerator\n\n            fe = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\n            num.multiplier = num.multiplier.multiply(m); //store the parts in variables for easy recognition \n            //check if in the form t^n where n = integer\n\n            if ((den.group === S || den.group === CB) && f.x.value === s && f.b.equals(0) && core.Utils.isInt(f.x.power)) {\n              var fact, p;\n              p = f.x.power - 1;\n              fact = core.Math2.factorial(p); //  n!/s^(n-1)\n\n              retval = _.divide(_.pow(t, new Symbol(p)), new Symbol(fact)); //wrap it up\n\n              finalize();\n            } else if (den.group === CP && den_p.equals(1)) {\n              // a/(b*s-c) -> ae^(-bt)\n              if (f.x.isLinear() && !num.contains(s)) {\n                console.log(f.a.toString(), f.b.toString());\n                t = _.divide(t, f.a.clone());\n                retval = _.parse(format('(({0})^({3}-1)*e^(-(({2})*({0}))/({1})))/(({3}-1)!*({1})^({3}))', t, f.a, f.b, den_p)); //                                retval = _.pow(new Symbol('e'), _.multiply(t, f.b.negate()));\n                //wrap it up\n\n                finalize();\n              } else {\n                if (f.x.group === S && f.x.power.equals(2)) {\n                  if (!num.contains(s)) {\n                    retval = _.parse(format('(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/sqrt(({2})*({3}))', t, num, f.a, f.b));\n                  } // a*s/(b*s^2+c^2)\n                  else {\n                      var a = new Symbol(1);\n\n                      if (num.group === CB) {\n                        var new_num = new Symbol(1);\n                        num.each(function (x) {\n                          if (x.contains(s)) new_num = _.multiply(new_num, x);else a = _.multiply(a, x);\n                        });\n                        num = new_num;\n                      } //we need more information about the denominator to decide\n\n\n                      var f2 = core.Utils.decompose_fn(num, s, true);\n                      var fn1, fn2, a_has_sin, b_has_cos, a_has_cos, b_has_sin;\n                      fn1 = f2.a;\n                      fn2 = f2.b;\n                      a_has_sin = fn1.containsFunction('sin');\n                      a_has_cos = fn1.containsFunction('cos');\n                      b_has_cos = fn2.containsFunction('cos');\n                      b_has_sin = fn2.containsFunction('sin');\n\n                      if (f2.x.value === s && f2.x.isLinear() && !(a_has_sin && b_has_cos || a_has_cos || b_has_sin)) {\n                        retval = _.parse(format('(({1})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})', t, f2.a, f.a, f.b));\n                      } else {\n                        if (a_has_sin && b_has_cos) {\n                          var sin, cos;\n                          sin = fn1.findFunction('sin');\n                          cos = fn2.findFunction('cos'); //who has the s?\n\n                          if (sin.args[0].equals(cos.args[0]) && !sin.args[0].contains(s)) {\n                            var b, c, d, e;\n                            b = _.divide(fn2, cos.toUnitMultiplier()).toString();\n                            c = sin.args[0].toString();\n                            d = f.b;\n                            e = _.divide(fn1, sin.toUnitMultiplier());\n                            exp = '(({1})*({2})*cos({3})*sin(sqrt({4})*({0})))/sqrt({4})+({1})*sin({3})*({5})*cos(sqrt({4})*({0}))';\n                            retval = _.parse(format(exp, t, a, b, c, d, e));\n                          }\n                        }\n                      }\n                    }\n                }\n              }\n            } else if (f.x.power.num && f.x.power.num.equals(3) && f.x.power.den.equals(2) && num.contains('sqrt(pi)') && !num.contains(s) && num.isLinear()) {\n              var b = _.divide(num.clone(), _.parse('sqrt(pi)'));\n\n              retval = _.parse(format('(2*({2})*sqrt({0}))/({1})', t, f.a, b, num));\n            } else if (den_p.equals(2) && f.x.power.equals(2)) {\n              var a, d, exp;\n\n              if (!num.contains(s)) {\n                a = _.divide(num, new Symbol(2));\n                exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({3})*sqrt(({2})*({3})))-(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*({3}))';\n                retval = _.parse(format(exp, t, a, f.a, f.b));\n              } else {\n                //decompose the numerator to check value of s\n                f2 = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\n\n                if (f2.x.isComposite()) {\n                  var s_terms = []; //first collect the factors e.g. (a)(bx)(cx^2+d)\n\n                  var symbols = num.collectSymbols(function (x) {\n                    x = Symbol.unwrapPARENS(x);\n                    var t = core.Utils.decompose_fn(x, s, true);\n                    t.symbol = x;\n                    return t;\n                  }). //then sort them by power hightest to lowest\n                  sort(function (a, b) {\n                    var p1, p2;\n                    p1 = a.x.value !== s ? 0 : a.x.power;\n                    p2 = b.x.value !== s ? 0 : b.x.power;\n                    return p2 - p1;\n                  });\n                  a = new Symbol(-1); //grab only the ones which have s\n\n                  for (var i = 0; i < symbols.length; i++) {\n                    var fc = symbols[i];\n                    if (fc.x.value === s) s_terms.push(fc);else a = _.multiply(a, fc.symbol);\n                  } //the following 2 assumptions are made\n                  //1. since the numerator was factored above then each s_term has a unique power\n                  //2. because the terms are sorted by descending powers then the first item \n                  //   has the highest power\n                  //we can now check for the next type s(s^2-a^2)/(s^2+a^2)^2\n\n\n                  if (s_terms[0].x.power.equals(2) && s_terms[1].x.power.equals(1) && s_terms[1].b.equals(0) && !s_terms[0].b.equals(0)) {\n                    b = s_terms[0].a.negate();\n                    exp = '-(({1})*({2})*({5})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))/' + '(2*({4})^2*sqrt(({4})*({5})))-(({1})*({3})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))' + '/(2*({4})*sqrt(({4})*({5})))+(({1})*({2})*cos((sqrt(({4})*({5}))*({0}))/({4})))/({4})^2';\n                    retval = _.parse(format(exp, t, a, b, s_terms[0].b, f.a, f.b));\n                  }\n                } else {\n                  if (f2.x.isLinear()) {\n                    a = _.divide(f2.a, new Symbol(2));\n                    exp = '(({1})*({0})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))';\n                    retval = _.parse(format(exp, t, a, f.a, f.b));\n                  } else if (f2.x.power.equals(2)) {\n                    if (f2.b.equals(0)) {\n                      a = _.divide(f2.a, new Symbol(2));\n                      exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\n                      retval = _.parse(format(exp, t, a, f.a, f.b));\n                    } else {\n                      a = _.divide(f2.a, new Symbol(2));\n                      d = f2.b.negate();\n                      exp = '-((({2})*({4})-2*({1})*({3}))*sin((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3})*sqrt(({2})*({3})))+' + '(({4})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3}))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\n                      retval = _.parse(format(exp, t, a, f.a, f.b, d));\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (!retval) retval = _.symfunction('ilt', [input_symbol, s_, t]);\n          return retval;\n        }, true);\n      }\n    },\n    Statistics: {\n      frequencyMap: function frequencyMap(arr) {\n        var map = {}; //get the frequency map\n\n        for (var i = 0, l = arr.length; i < l; i++) {\n          var e = arr[i],\n              key = e.toString();\n          if (!map[key]) //default it to zero\n            map[key] = 0;\n          map[key]++; //increment\n        }\n\n        return map;\n      },\n      sort: function sort(arr) {\n        return arr.sort(function (a, b) {\n          if (!a.isConstant() || !b.isConstant()) _.error('Unable to sort! All values must be numeric');\n          return a.multiplier.subtract(b.multiplier);\n        });\n      },\n      count: function count(arr) {\n        return new Symbol(arr.length);\n      },\n      sum: function sum(arr, x_) {\n        var sum = new Symbol(0);\n\n        for (var i = 0, l = arr.length; i < l; i++) {\n          var xi = arr[i].clone();\n\n          if (x_) {\n            sum = _.add(_.pow(_.subtract(xi, x_.clone()), new Symbol(2)), sum);\n          } else sum = _.add(xi, sum);\n        }\n\n        return sum;\n      },\n      mean: function mean() {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.mean.apply(this, args[0].elements);\n        return _.divide(__.Statistics.sum(args), __.Statistics.count(args));\n      },\n      median: function median() {\n        var args = [].slice.call(arguments),\n            retval; //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.median.apply(this, args[0].elements);\n\n        try {\n          var sorted = __.Statistics.sort(args);\n\n          var l = args.length;\n\n          if (core.Utils.even(l)) {\n            var mid = l / 2;\n            retval = __.Statistics.mean(sorted[mid - 1], sorted[mid]);\n          } else retval = sorted[Math.floor(l / 2)];\n        } catch (e) {\n          retval = _.symfunction('median', args);\n        }\n\n        return retval;\n      },\n      mode: function mode() {\n        var args = [].slice.call(arguments),\n            retval; //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.mode.apply(this, args[0].elements);\n\n        var map = __.Statistics.frequencyMap(args); //the mode of 1 item is that item as per issue #310 (verified by Happypig375). \n\n\n        if (core.Utils.keys(map).length === 1) retval = args[0];else {\n          //invert by arraning them according to their frequency\n          var inverse = {};\n\n          for (var x in map) {\n            var freq = map[x]; //check if it's in the inverse already\n\n            if (!(freq in inverse)) inverse[freq] = x;else {\n              var e = inverse[freq]; //if it's already an array then just add it\n\n              if (isArray(e)) e.push(x); //convert it to and array\n              else inverse[freq] = [x, inverse[freq]];\n            }\n          } //the keys now represent the maxes. We want the max of those keys\n\n\n          var max = inverse[Math.max.apply(null, core.Utils.keys(inverse))]; //check it's an array. If it is then map over the results and convert \n          //them to Symbol\n\n          if (isArray(max)) {\n            retval = _.symfunction('mode', max.sort());\n          } else retval = _.parse(max);\n        }\n        return retval;\n      },\n      gVariance: function gVariance(k, args) {\n        var x_ = __.Statistics.mean.apply(__.Statistics, args),\n            sum = __.Statistics.sum(args, x_);\n\n        return _.multiply(k, sum);\n      },\n      variance: function variance() {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.variance.apply(this, args[0].elements);\n\n        var k = _.divide(new Symbol(1), __.Statistics.count(args));\n\n        return __.Statistics.gVariance(k, args);\n      },\n      sampleVariance: function sampleVariance() {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.sampleVariance.apply(this, args[0].elements);\n\n        var k = _.divide(new Symbol(1), _.subtract(__.Statistics.count(args), new Symbol(1)));\n\n        return __.Statistics.gVariance(k, args);\n      },\n      standardDeviation: function standardDeviation() {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.standardDeviation.apply(this, args[0].elements);\n        return _.pow(__.Statistics.variance.apply(__.Statistics, args), new Symbol(1 / 2));\n      },\n      sampleStandardDeviation: function sampleStandardDeviation() {\n        var args = [].slice.call(arguments); //handle arrays\n\n        if (isVector(args[0])) return __.Statistics.sampleStandardDeviation.apply(this, args[0].elements);\n        return _.pow(__.Statistics.sampleVariance.apply(__.Statistics, args), new Symbol(1 / 2));\n      },\n      zScore: function zScore(x, mean, stdev) {\n        return _.divide(_.subtract(x, mean), stdev);\n      }\n    },\n    Units: {\n      table: {\n        foot: '12 inch',\n        meter: '100 cm',\n        decimeter: '10 cm'\n      }\n    }\n  };\n\n  nerdamer.register([{\n    name: 'laplace',\n    visible: true,\n    numargs: 3,\n    build: function build() {\n      return __.LaPlace.transform;\n    }\n  }, {\n    name: 'ilt',\n    visible: true,\n    numargs: 3,\n    build: function build() {\n      return __.LaPlace.inverse;\n    }\n  }, //statistical\n  {\n    name: 'mean',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.mean;\n    }\n  }, {\n    name: 'median',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.median;\n    }\n  }, {\n    name: 'mode',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.mode;\n    }\n  }, {\n    name: 'smpvar',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.sampleVariance;\n    }\n  }, {\n    name: 'variance',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.variance;\n    }\n  }, {\n    name: 'smpstdev',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.sampleStandardDeviation;\n    }\n  }, {\n    name: 'stdev',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.Statistics.standardDeviation;\n    }\n  }, {\n    name: 'zscore',\n    visible: true,\n    numargs: 3,\n    build: function build() {\n      return __.Statistics.zScore;\n    }\n  }]); //link registered functions externally\n\n  nerdamer.api();\n})();","require(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nrequire(\"core-js/modules/es6.array.map\");\n\nrequire(\"core-js/modules/es6.string.sub\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.number.constructor\");\n\nrequire(\"core-js/modules/es6.array.index-of\");\n\n/* global module */\n\n/*\r\n* Author : Martin Donk\r\n* Website : http://www.nerdamer.com\r\n* Email : martin.r.donk@gmail.com\r\n* Source : https://github.com/jiggzson/nerdamer\r\n*/\nif (typeof module !== 'undefined' && typeof nerdamer === 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      Frac = core.Frac,\n      Settings = core.Settings,\n      isSymbol = core.Utils.isSymbol,\n      FN = core.groups.FN,\n      Symbol = core.Symbol,\n      text = core.Utils.text,\n      inBrackets = core.Utils.inBrackets,\n      isInt = core.Utils.isInt,\n      format = core.Utils.format,\n      even = core.Utils.even,\n      evaluate = core.Utils.evaluate,\n      N = core.groups.N,\n      S = core.groups.S,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      EX = core.groups.EX,\n      P = core.groups.P,\n      LOG = Settings.LOG,\n      EXP = 'exp',\n      ABS = 'abs',\n      SQRT = 'sqrt',\n      SIN = 'sin',\n      COS = 'cos',\n      TAN = 'tan',\n      SEC = 'sec',\n      CSC = 'csc',\n      COT = 'cot',\n      ASIN = 'asin',\n      ACOS = 'acos',\n      ATAN = 'atan',\n      ASEC = 'asec',\n      ACSC = 'acsc',\n      ACOT = 'acot',\n      SINH = 'sinh',\n      COSH = 'cosh',\n      TANH = 'tanh',\n      CSCH = 'csch',\n      SECH = 'sech',\n      COTH = 'coth',\n      ASECH = 'asech',\n      ACSCH = 'acsch',\n      ACOTH = 'acoth'; //custom errors\n\n  function NoIntegralFound(msg) {\n    this.message = msg || \"\";\n  }\n\n  NoIntegralFound.prototype = new Error(); //Preparations\n\n  Symbol.prototype.hasIntegral = function () {\n    return this.containsFunction('integrate');\n  }; //transforms a function\n\n\n  Symbol.prototype.fnTransform = function () {\n    if (this.group !== FN) return this;\n    var retval,\n        a = this.args[0];\n    var m = new Symbol(this.multiplier);\n    var sym = this.clone().toUnitMultiplier();\n\n    if (this.isLinear()) {\n      switch (this.fname) {\n        case SINH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\n          break;\n\n        case TAN:\n          retval = _.parse(format('sin({0})/cos({0})', a));\n          break;\n\n        case CSC:\n          retval = _.parse(format('1/sin({0})', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('1/cos({0})', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.power.equals(2)) {\n      switch (this.fname) {\n        case SIN:\n          retval = _.parse(format('1/2-cos(2*({0}))/2', a));\n          break;\n\n        case COS:\n          retval = _.parse(format('1/2+cos(2*({0}))/2', a));\n          break;\n\n        case TAN:\n          //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\n          retval = _.parse(format('sin({0})^2/cos({0})^2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case SINH:\n          retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.fname === SEC) {\n      retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === CSC) {\n      retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === TAN) {\n      if (this.power.lessThan(0)) {\n        retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\n      } else {\n        retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\n      }\n    } else if (this.fname === SIN && this.power.lessThan(0)) {\n      retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === COS && this.power.lessThan(0)) {\n      retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === SIN && this.power.equals(3)) {\n      retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\n    } else if (this.fname === COS && this.power.equals(3)) {\n      retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\n    } else retval = sym;\n\n    return _.multiply(retval, m);\n  };\n\n  Symbol.prototype.hasTrig = function () {\n    if (this.isConstant(true) || this.group === S) return false;\n    if (this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname))) return true;\n\n    if (this.symbols) {\n      for (var x in this.symbols) {\n        if (this.symbols[x].hasTrig()) return true;\n      }\n    }\n\n    return false;\n  };\n\n  core.Expression.prototype.hasIntegral = function () {\n    return this.symbol.hasIntegral();\n  };\n  /**\r\n   * Attempts to rewrite a symbol under one common denominator\r\n   * @param {Symbol} symbol \r\n   */\n\n\n  core.Utils.toCommonDenominator = function (symbol) {\n    //transform x/a+x -> (ax+x)/a\n    if (symbol.isComposite() && symbol.isLinear()) {\n      var m = new Symbol(symbol.multiplier);\n      var denominator = new Symbol(1);\n      var numerator = new Symbol(0);\n      symbol.each(function (x) {\n        denominator = _.multiply(denominator, x.getDenom());\n      }, true); //remove the denomitor in each term\n\n      symbol.each(function (x) {\n        var num = x.getNum();\n        var den = x.getDenom();\n\n        var factor = _.multiply(num, _.divide(denominator.clone(), den));\n\n        numerator = _.add(numerator, factor);\n      });\n\n      var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\n\n      return retval;\n    }\n\n    return symbol;\n  }; //A function to check if a function name is an inverse trig function\n\n\n  core.Utils.in_inverse_trig = function (x) {\n    var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\n    return inv_trig_fns.indexOf(x) !== -1;\n  }; //A function to check if a function name is a trig function\n\n\n  core.Utils.in_trig = function (x) {\n    var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  core.Utils.in_htrig = function (x) {\n    var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  var all_functions = core.Utils.all_functions = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      if (arr[i].group !== FN) return false;\n    }\n\n    return true;\n  },\n      cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\n  },\n      cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\n    //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\n    //we technically know how to do this transform but more is needed for correct output\n    if (Number(symbol2.power) !== 1) return _.multiply(symbol1, symbol2);\n    var a;\n    a = symbol1.args[0];\n    return _.parse(format('(sin(2*({0})))/2', a));\n  },\n      sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\n  },\n      trigTransform = core.Utils.trigTransform = function (arr) {\n    var map = {},\n        symbol,\n        t,\n        retval = new Symbol(1);\n\n    for (var i = 0, l = arr.length; i < l; i++) {\n      symbol = arr[i];\n\n      if (symbol.group === FN) {\n        var fname = symbol.fname;\n\n        if (fname === COS && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[SIN]);\n          } else {\n            t = cosAsinAtransform(symbol, map[SIN]);\n          }\n\n          delete map[SIN];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[COS]) {\n          if (map[COS].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[COS]);\n          } else {\n            t = cosAsinAtransform(symbol, map[COS]);\n          }\n\n          delete map[COS];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = sinAsinBtransform(symbol, map[SIN]);\n            delete map[SIN];\n          } else {\n            //This should actually be redundant code but let's put just in case\n            t = _.multiply(symbol, map[SIN]);\n            delete map[SIN];\n          }\n\n          retval = t;\n        } else map[fname] = symbol;\n      } else retval = _.multiply(retval, symbol);\n    } //put back the remaining functions\n\n\n    for (var x in map) {\n      retval = _.multiply(retval, map[x]);\n    }\n\n    return retval;\n  };\n\n  core.Settings.integration_depth = 10;\n  core.Settings.max_lim_depth = 10;\n\n  var __ = core.Calculus = {\n    version: '1.4.6',\n    sum: function sum(fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        start = Number(start);\n        end = Number(end);\n        retval = core.Utils.block(modifier, function () {\n          var f = fn.text(),\n              subs = {\n            '~': true\n          },\n              //lock subs. Is this even being used?\n          retval = new core.Symbol(0);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n\n            var ans = _.parse(f, subs);\n\n            retval = _.add(retval, ans);\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('sum', arguments);\n      }\n\n      return retval;\n    },\n    product: function product(fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        retval = core.Utils.block(modifier, function () {\n          start = Number(start);\n          end = Number(end.multiplier);\n          var f = fn.text(),\n              subs = {},\n              retval = new core.Symbol(1);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n            retval = _.multiply(retval, _.parse(f, subs));\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('product', arguments);\n      }\n\n      return retval;\n    },\n    diff: function diff(symbol, wrt, nth) {\n      if (core.Utils.isVector(symbol)) {\n        var vector = new core.Vector([]);\n        symbol.each(function (x) {\n          vector.elements.push(__.diff(x, wrt, nth));\n        });\n        return vector;\n      } else if (core.Utils.isMatrix(symbol)) {\n        var matrix = new core.Matrix();\n        symbol.each(function (x, i, j) {\n          matrix.set(i, j, __.diff(x, wrt, nth));\n        });\n        return matrix;\n      }\n\n      var d = isSymbol(wrt) ? wrt.text() : wrt; //the nth derivative\n\n      nth = isSymbol(nth) ? nth.multiplier : nth || 1;\n      if (d === undefined) d = core.Utils.variables(symbol)[0]; //unwrap sqrt\n\n      if (symbol.group === FN && symbol.fname === SQRT) {\n        var s = symbol.args[0],\n            sp = symbol.power.clone(); //these groups go to zero anyway so why waste time?\n\n        if (s.group !== N || s.group !== P) {\n          s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\n          s.multiplier = s.multiplier.multiply(symbol.multiplier);\n        }\n\n        symbol = s;\n      }\n\n      if (symbol.group === FN && !isSymbol(symbol.power)) {\n        var a = derive(_.parse(symbol));\n\n        var b = __.diff(symbol.args[0].clone(), d);\n\n        symbol = _.multiply(a, b); //chain rule\n      } else {\n        symbol = derive(symbol);\n      }\n\n      if (nth > 1) {\n        nth--;\n        symbol = __.diff(symbol, wrt, nth);\n      }\n\n      return symbol; // Equivalent to \"derivative of the outside\".\n\n      function polydiff(symbol) {\n        if (symbol.value === d || symbol.contains(d, true)) {\n          symbol.multiplier = symbol.multiplier.multiply(symbol.power);\n          symbol.power = symbol.power.subtract(new Frac(1));\n\n          if (symbol.power.equals(0)) {\n            symbol = Symbol(symbol.multiplier);\n          }\n        }\n\n        return symbol;\n      }\n\n      ;\n\n      function derive(symbol) {\n        var g = symbol.group,\n            a,\n            b,\n            cp;\n\n        if (g === N || g === S && symbol.value !== d || g === P) {\n          symbol = Symbol(0);\n        } else if (g === S) {\n          symbol = polydiff(symbol);\n        } else if (g === CB) {\n          var m = symbol.multiplier.clone();\n          symbol.toUnitMultiplier();\n\n          var retval = _.multiply(product_rule(symbol), polydiff(symbol));\n\n          retval.multiplier = retval.multiplier.multiply(m);\n          return retval;\n        } else if (g === FN && symbol.power.equals(1)) {\n          // Table of known derivatives\n          switch (symbol.fname) {\n            case LOG:\n              cp = symbol.clone();\n              symbol = symbol.args[0].clone(); //get the arguments\n\n              symbol.power = symbol.power.negate();\n              symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\n              break;\n\n            case COS:\n              //cos -> -sin\n              symbol.fname = SIN;\n              symbol.multiplier.negate();\n              break;\n\n            case SIN:\n              //sin -> cos\n              symbol.fname = COS;\n              break;\n\n            case TAN:\n              //tan -> sec^2\n              symbol.fname = SEC;\n              symbol.power = new Frac(2);\n              break;\n\n            case SEC:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, TAN);\n              break;\n\n            case CSC:\n              symbol = qdiff(symbol, '-cot');\n              break;\n\n            case COT:\n              symbol.fname = CSC;\n              symbol.multiplier.negate();\n              symbol.power = new Frac(2);\n              break;\n\n            case ASIN:\n              symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ACOS:\n              symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ATAN:\n              symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ABS:\n              m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier(); //depending on the complexity of the symbol it's easier to just parse it into a new symbol\n              //this should really be readdressed soon\n\n              b = symbol.args[0].clone();\n              b.toUnitMultiplier();\n              symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\n              symbol.multiplier = m;\n              break;\n\n            case 'parens':\n              //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\n              //1*g'\n              symbol = Symbol(1);\n              break;\n\n            case 'cosh':\n              //cosh -> -sinh\n              symbol.fname = 'sinh';\n              break;\n\n            case 'sinh':\n              //sinh -> cosh\n              symbol.fname = 'cosh';\n              break;\n\n            case TANH:\n              //tanh -> sech^2\n              symbol.fname = SECH;\n              symbol.power = new Frac(2);\n              break;\n\n            case SECH:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, '-tanh');\n              break;\n\n            case CSCH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\n              break;\n\n            case COTH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-csch(' + arg + ')^2');\n              break;\n\n            case 'asinh':\n              symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'acosh':\n              symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'atanh':\n              symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ASECH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\n              break;\n\n            case ACOTH:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\n              break;\n\n            case ACSCH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\n              break;\n\n            case ASEC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACSC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACOT:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\n              break;\n\n            case 'S':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'C':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'Si':\n              var arg = symbol.args[0];\n              symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Shi':\n              var arg = symbol.args[0];\n              symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ci':\n              var arg = symbol.args[0];\n              symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Chi':\n              var arg = symbol.args[0];\n              symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ei':\n              var arg = symbol.args[0];\n              symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Li':\n              var arg = symbol.args[0];\n              symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\n              break;\n\n            case 'erf':\n              symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\n              break;\n\n            case 'atan2':\n              var x_ = String(symbol.args[0]),\n                  y_ = String(symbol.args[1]);\n              symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\n              break;\n\n            case 'sign':\n              symbol = new Symbol(0);\n              break;\n\n            case Settings.LOG10:\n              symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\n              break;\n\n            default:\n              symbol = _.symfunction('diff', [symbol, wrt]);\n          }\n        } else if (g === EX || g === FN && isSymbol(symbol.power)) {\n          var value;\n\n          if (g === EX) {\n            value = symbol.value;\n          } else if (g === FN && symbol.contains(d)) {\n            value = symbol.fname + inBrackets(text(symbol.args[0]));\n          } else {\n            value = symbol.value + inBrackets(text(symbol.args[0]));\n          }\n\n          a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\n          b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\n          symbol = _.multiply(symbol, b);\n        } else if (g === FN && !symbol.power.equals(1)) {\n          b = symbol.clone();\n          b.toLinear();\n          b.toUnitMultiplier();\n          symbol = _.multiply(polydiff(symbol.clone()), derive(b));\n        } else if (g === CP || g === PL) {\n          var result = new Symbol(0);\n\n          for (var x in symbol.symbols) {\n            result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\n          }\n\n          symbol = _.multiply(polydiff(symbol.clone()), result);\n        }\n\n        symbol.updateHash();\n        return symbol;\n      }\n\n      ;\n\n      function qdiff(symbol, val, altVal) {\n        return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\n      }\n\n      ;\n\n      function product_rule(symbol) {\n        //grab all the symbols within the CB symbol\n        var symbols = symbol.collectSymbols(),\n            result = new Symbol(0),\n            l = symbols.length; //loop over all the symbols\n\n        for (var i = 0; i < l; i++) {\n          var df = __.diff(symbols[i].clone(), d);\n\n          for (var j = 0; j < l; j++) {\n            //skip the symbol of which we just pulled the derivative\n            if (i !== j) {\n              //multiply out the remaining symbols\n              df = _.multiply(df, symbols[j].clone());\n            }\n          } //add the derivative to the result\n\n\n          result = _.add(result, df);\n        }\n\n        return result; //done\n      }\n\n      ;\n    },\n    integration: {\n      u_substitution: function u_substitution(symbols, dx) {\n        function try_combo(a, b, f) {\n          var d = __.diff(b, dx);\n\n          var q = f ? f(a, b) : _.divide(a.clone(), d);\n          if (!q.contains(dx, true)) return q;\n          return null;\n        }\n\n        function do_fn_sub(fname, arg) {\n          var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\n\n          subbed = subbed.sub(new Symbol(u), arg);\n          subbed.updateHash();\n          return subbed;\n        }\n\n        var a = symbols[0].clone(),\n            b = symbols[1].clone(),\n            g1 = a.group,\n            g2 = b.group,\n            //may cause problems if person is using this already. Will need\n        //to find algorithm for detecting conflict\n        u = '__u__',\n            Q;\n\n        if (g1 === FN && g2 !== FN) {\n          //e.g. 2*x*cos(x^2)\n          var arg = a.args[0];\n          Q = try_combo(b, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(a.fname, arg));\n          Q = try_combo(b, a);\n\n          if (Q) {\n            return __.integration.poly_integrate(a);\n          }\n        } else if (g2 === FN && g1 !== FN) {\n          //e.g. 2*(x+1)*cos((x+1)^2\n          var arg = b.args[0];\n          Q = try_combo(a, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(b.fname, arg));\n        } else if (g1 === FN && g2 === FN) {\n          Q = try_combo(a.clone(), b.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(b.clone(), a.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n        } else if (g1 === EX && g2 !== EX) {\n          var p = a.power;\n          Q = try_combo(b, p.clone());\n\n          if (!Q) {\n            //one more try\n            var dc = __.integration.decompose_arg(p.clone(), dx); //consider the possibility of a^x^(n-1)*x^n dx\n\n\n            var xp = __.diff(dc[2].clone(), dx);\n\n            var dc2 = __.integration.decompose_arg(xp.clone(), dx); //if their powers equal, so if dx*p == b\n\n\n            if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\n              var m = _.divide(dc[0].clone(), dc2[0].clone());\n\n              var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\n\n              new_val = _.multiply(new_val, new Symbol(u));\n              return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\n            }\n          }\n\n          var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\n              retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\n\n          return retval;\n        } else if (g2 === EX && g1 !== EX) {\n          var p = b.power;\n          Q = try_combo(a, p.clone());\n\n          var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\n\n          return _.multiply(integrated.sub(new Symbol(u), p), Q);\n        } else if (a.isComposite() || b.isComposite()) {\n          var f = function f(a, b) {\n            var d = __.diff(b, dx);\n\n            var A = core.Algebra.Factor.factor(a),\n                B = core.Algebra.Factor.factor(d);\n\n            var q = _.divide(A, B);\n\n            return q;\n          };\n\n          var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\n              f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\n          Q = try_combo(f1.clone(), f2.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(f2.clone(), f1.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(a), Q);\n        }\n      },\n      //simple integration of a single polynomial x^(n+1)/(n+1)\n      poly_integrate: function poly_integrate(x) {\n        var p = x.power.toString(),\n            m = x.multiplier.toDecimal(),\n            s = x.toUnitMultiplier().toLinear();\n\n        if (Number(p) === -1) {\n          return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\n        }\n\n        return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\n      },\n      //If we're just spinning wheels we want to stop. This is why we \n      //wrap integration in a try catch block and call this to stop.\n      stop: function stop(msg) {\n        msg = msg || 'Unable to compute integral!';\n        core.Utils.warn(msg);\n        throw new NoIntegralFound(msg);\n      },\n      partial_fraction: function partial_fraction(input, dx, depth, opt) {\n        //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\n        if (!isSymbol(dx)) dx = _.parse(dx);\n        var result, partial_fractions;\n        result = new Symbol(0);\n        partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\n\n        if (partial_fractions.group === CB && partial_fractions.isLinear()) {\n          //perform a quick check to make sure that all partial fractions are linear\n          partial_fractions.each(function (x) {\n            if (!x.isLinear()) __.integration.stop();\n          });\n          partial_fractions.each(function (x) {\n            result = _.add(result, __.integrate(x, dx, depth, opt));\n          });\n        } else {\n          result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\n        }\n\n        return result;\n      },\n      get_udv: function get_udv(symbol) {\n        var parts = [[\n          /*L*/\n        ], [\n          /*I*/\n        ], [\n          /*A*/\n        ], [\n          /*T*/\n        ], [\n          /*E*/\n        ]]; //first we sort them \n\n        var setSymbol = function setSymbol(x) {\n          var g = x.group;\n\n          if (g === FN) {\n            var fname = x.fname;\n            if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname)) parts[3].push(x);else if (core.Utils.in_inverse_trig(fname)) parts[1].push(x);else if (fname === LOG) parts[0].push(x);else {\n              __.integration.stop();\n            }\n          } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\n            parts[2].push(x);\n          } else if (g === EX || x.isComposite() && !x.isLinear()) parts[4].push(x);else __.integration.stop();\n        };\n\n        if (symbol.group === CB) symbol.each(function (x) {\n          setSymbol(Symbol.unwrapSQRT(x, true));\n        });else setSymbol(symbol);\n        var u,\n            dv = new Symbol(1); //compile u and dv\n\n        for (var i = 0; i < 5; i++) {\n          var part = parts[i],\n              t,\n              l = part.length;\n\n          if (l > 0) {\n            if (l > 1) {\n              t = new Symbol(1);\n\n              for (var j = 0; j < l; j++) {\n                t = _.multiply(t, part[j].clone());\n              }\n            } else t = part[0].clone();\n\n            if (!u) {\n              u = t; //the first u encountered gets chosen\n\n              u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\n            } else dv = _.multiply(dv, t); //everything else belongs to dv\n\n          }\n        }\n\n        return [u, dv];\n      },\n      trig_sub: function trig_sub(symbol, dx, depth, opt, parts, symbols) {\n        parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\n        var b = parts[3],\n            ax = parts[2],\n            a = parts[0],\n            x = parts[1];\n\n        if (x.power.equals(2) && a.greaterThan(0)) {\n          //use tan(x)\n          var t = core.Utils.getU(symbol),\n              //get an appropriate u\n          u = _.parse(TAN + inBrackets(t)),\n              //u\n          du = _.parse(SEC + inBrackets(t) + '^2'),\n              //du\n          f = _.multiply(symbol.sub(x, u), du);\n\n          var integral = __.integrate(f, t, depth, opt).sub(u, x);\n\n          core.Utils.clearU(u);\n          return integral;\n        }\n      },\n      by_parts: function by_parts(symbol, dx, depth, o) {\n        o.previous = o.previous || [];\n        var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s; //first LIATE\n\n        udv = __.integration.get_udv(symbol);\n        u = udv[0];\n        dv = udv[1];\n        du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\n        c = du.clone().stripVar(dx); //strip any coefficients\n\n        du = _.divide(du, c.clone());\n        v = __.integrate(dv.clone(), dx, depth || 0);\n        vdu = _.multiply(v.clone(), du);\n        vdu_s = vdu.toString(); //currently only supports e^x*(some trig)\n\n        if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {\n          //We're going to exploit the fact that vdu can never be constant\n          //to work out way out of this cycle. We'll return the length of\n          //the this.previous array until we're back at level one\n          o.is_cyclic = true; //return the integral. \n\n          return new Symbol(1);\n        } else o.previous.push(vdu_s);\n\n        uv = _.multiply(u, v); //clear the multiplier so we're dealing with a bare integral\n\n        m = vdu.multiplier.clone();\n        vdu.toUnitMultiplier();\n        integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\n        integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\n        retval = _.subtract(uv, integral_vdu); //we know that there cannot be constants so they're a holdover from a cyclic integral\n\n        if (o.is_cyclic) {\n          //start popping the previous stack so we know how deep in we are\n          o.previous.pop();\n\n          if (o.previous.length === 0) {\n            retval = _.expand(retval);\n            var rem = new Symbol(0);\n            retval.each(function (x) {\n              if (!x.contains(dx)) rem = _.add(rem, x.clone());\n            }); //get the actual uv\n\n            retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\n          }\n        }\n\n        return retval;\n      },\n\n      /*\r\n       * dependents: [Solve, integrate]\r\n       */\n      decompose_arg: core.Utils.decompose_fn\n    },\n    //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\n    integrate: function integrate(original_symbol, dt, depth, opt) {\n      //assume integration wrt independent variable if expression only has one variable\n      if (!dt) {\n        var vars = core.Utils.variables(original_symbol);\n        if (vars.length === 1) dt = vars[0]; //defaults to x\n\n        dt = dt || 'x';\n      } //add support for integrating vectors\n\n\n      if (core.Utils.isVector(original_symbol)) {\n        var vector = new core.Vector([]);\n        original_symbol.each(function (x) {\n          vector.elements.push(__.integrate(x, dt));\n        });\n        return vector;\n      }\n\n      if (!isNaN(dt)) _.error('variable expected but received ' + dt); //get rid of constants right away\n\n      if (original_symbol.isConstant(true)) return _.multiply(original_symbol.clone(), _.parse(dt)); //configurations options for integral. This is needed for tracking extra options\n      //e.g. cyclic integrals or additional settings\n\n      opt = opt || {};\n      return core.Utils.block('PARSE2NUMBER', function () {\n        //make a note of the original symbol. Set only if undefined\n        depth = depth || 0;\n        var dx = isSymbol(dt) ? dt.toString() : dt,\n            //we don't want the symbol in sqrt form. x^(1/2) is prefererred\n        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\n            g = symbol.group,\n            retval;\n\n        try {\n          //We stop integration after x amount of recursive calls\n          if (++depth > core.Settings.integration_depth) __.integration.stop('Maximum depth reached. Exiting!'); //constants. We first eliminate anything that doesn't have dx. Everything after this has \n          //to have dx or else it would have been taken care of below\n\n          if (!symbol.contains(dx, true)) {\n            retval = _.multiply(symbol.clone(), _.parse(dx));\n          } //e.g. 2*x\n          else if (g === S) {\n              retval = __.integration.poly_integrate(symbol, dx, depth);\n            } else if (g === EX) {\n              if (symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS)) __.integration.stop(); //check the base\n\n              if (symbol.contains(dx) && symbol.previousGroup !== FN) {\n                //if the symbol also contains dx then we stop since we currently \n                //don't know what to do with it e.g. x^x\n                if (symbol.power.contains(dx)) __.integration.stop();else {\n                  var t = __.diff(symbol.clone().toLinear(), dx);\n\n                  if (t.contains(dx)) __.integration.stop(); //since at this point it's the base only then we do standard single poly integration\n                  //e.g. x^y\n\n                  retval = __.integration.poly_integrate(symbol, dx, depth);\n                }\n              } //e.g. a^x or 9^x\n              else {\n                  var a = __.diff(symbol.power.clone(), dx);\n\n                  if (a.contains(dx)) {\n                    var aa = a.stripVar(dx),\n                        x = _.divide(a.clone(), aa.clone());\n\n                    if (x.group === S && x.isLinear()) {\n                      aa.multiplier = aa.multiplier.divide(new Frac(2));\n                      return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\n                    } else __.integration.stop();\n                  }\n\n                  if (symbol.isE()) {\n                    if (a.isLinear()) retval = symbol;else {\n                      if (a.isE() && a.power.group === S && a.power.power.equals(1)) retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);else __.integration.stop();\n                    }\n                  } else {\n                    var d = _.symfunction(LOG, [_.parse(symbol.value)]);\n\n                    retval = _.divide(symbol, d);\n                  }\n\n                  retval = _.divide(retval, a);\n                }\n            } else if (symbol.isComposite() && symbol.isLinear()) {\n              var m = _.parse(symbol.multiplier);\n\n              symbol.toUnitMultiplier();\n              retval = new Symbol(0);\n              symbol.each(function (x) {\n                retval = _.add(retval, __.integrate(x, dx, depth));\n              });\n              retval = _.multiply(m, retval);\n            } else if (g === CP) {\n              if (symbol.power.greaterThan(1)) symbol = _.expand(symbol);\n\n              if (symbol.power.equals(1)) {\n                retval = new Symbol(0);\n                symbol.each(function (x) {\n                  retval = _.add(retval, __.integrate(x, dx, depth));\n                }, true);\n              } else {\n                var p = Number(symbol.power),\n                    m = symbol.multiplier.clone(); //temporarily remove the multiplier\n\n                symbol.toUnitMultiplier();\n\n                var //below we consider the form ax+b\n                fn = symbol.clone().toLinear(),\n                    //get just the pure function without the power\n                decomp = __.integration.decompose_arg(fn, dx),\n                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\n                b = decomp[3],\n                    ax = decomp[2],\n                    a = decomp[0],\n                    x = decomp[1];\n\n                if (p === -1 && x.group !== PL && x.power.equals(2)) {\n                  var b_is_positive = isInt(b) ? b > 0 : true; //we can now check for atan\n\n                  if (x.group === S && x.power.equals(2) && b_is_positive) {\n                    ////then we have atan\n                    //abs is redundants since the sign appears in both denom and num.\n                    var unwrapAbs = function unwrapAbs(s) {\n                      var result = new Symbol(1);\n                      s.each(function (x) {\n                        result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\n                      });\n                      return result;\n                    };\n\n                    var A = a.clone(),\n                        B = b.clone();\n                    A = _.pow(A, new Symbol(1 / 2));\n                    B = _.pow(B, new Symbol(1 / 2)); //unwrap abs\n\n                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\n                        f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\n\n                    retval = _.divide(f, d);\n                  } else if (x.group === S && x.isLinear()) {\n                    retval = _.divide(__.integration.poly_integrate(symbol), a);\n                  } else {\n                    //1/(x^4+1)\n                    if (x.power.equals(4)) {\n                      //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\n                      var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\n                      var br = inBrackets; //apply rule: ax^4+b = (ax^2+2abx+b)(ax^2-2abx+b)\n                      //get quadratic factors\n\n                      A = _.parse(SQRT + br(a) + '*' + dx + '^2');\n                      B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\n                      C = _.parse(SQRT + br(b));\n                      f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\n                      f2 = _.add(_.subtract(A, B), C); //calculate numerators: [D+E, D-E] -> [2*b^(3/4)+bax, 2*b^(3/4)-bax]\n\n                      D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\n                      E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx); //let F = 2b2b\n\n                      F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4')); //calculate the factors\n\n                      L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\n                      L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\n                      retval = _.add(__.integrate(L1, dx, depth, opt), __.integrate(L2, dx, depth, opt));\n                    } else //let's try partial fractions\n                      retval = __.integration.partial_fraction(symbol, dx, depth);\n                  }\n                } else if (p === -1 / 2) {\n                  //detect asin and atan\n                  if (x.group === S && x.power.equals(2)) {\n                    if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\n                      a.negate(); //it's asin\n\n                      if (b.isConstant() && a.isConstant()) {\n                        var d = _.symfunction(SQRT, [a.clone()]),\n                            d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\n\n                        retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\n                      } //I'm not sure about this one. I'm trusting Wolfram Alpha here\n                      else {\n                          var sqrt_a = _.symfunction(SQRT, [a]),\n                              sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\n\n                          retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\n                        }\n                    } else {\n                      /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\n                      __.integration.stop();\n                    }\n                  } else {\n                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\n                    __.integration.stop();\n                  }\n                } else {\n                  if (x.isLinear() && x.group !== PL) retval = _.divide(__.integration.poly_integrate(symbol), a);else if (x.power.equals(2) && a.greaterThan(0)) {\n                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv; //1/(a*x^2+b^2)^n\n                    //strip the value of b so b = 1\n\n                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\n\n                    sqb = _.parse(SQRT + inBrackets(b));\n                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\n                    bsqi = _.pow(b, new Symbol(symbol.power));\n                    uv = core.Utils.getU(symbol);\n                    u = _.multiply(aob, x.clone().toLinear());\n                    v = _.parse(ATAN + inBrackets(u)); //the conversion will be 1+tan(x)^2 -> sec(x)^2\n                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \n                    //then the remaining sec will be (n-1)*2;\n\n                    var n = (Math.abs(symbol.power) - 1) * 2; //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\n\n                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\n\n                    core.Utils.clearU(uv);\n                    return _.multiply(integral.sub(uv, v), bsqi);\n                  } else {\n                    if (symbol.group !== CB && !symbol.power.lessThan(0)) {\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    } else {\n                      var f = symbol.clone().toLinear();\n                      var factored = core.Algebra.Factor.factor(f);\n                      var was_factored = factored.toString() !== f.toString();\n\n                      if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\n                        try {\n                          var f1, fx, u, sq;\n                          sq = core.Algebra.sqComplete(f, dx);\n                          u = core.Utils.getU(f);\n                          f1 = sq.f.sub(sq.a, u);\n                          fx = _.pow(f1, _.parse(symbol.power));\n                          retval = __.integrate(fx, u).sub(u, sq.a);\n                        } catch (e) {\n                          __.integration.stop();\n                        }\n                      } else retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                    }\n                  }\n                }\n\n                retval.multiplier = retval.multiplier.multiply(m);\n              }\n            } else if (g === FN) {\n              var arg = symbol.args[0],\n                  m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier();\n\n              var decomp = __.integration.decompose_arg(arg, dx); //easies way I can think of to get the coefficient and to make sure\n              //that the symbol is linear wrt dx. I'm not actually trying to get the \n              //derivative\n\n\n              var a = decomp[0],\n                  x = decomp[1],\n                  fname = symbol.fname; //log is a special case that can be handled with integration by parts\n\n              if (fname === LOG || fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear()) {\n                /*integration by parts */\n                var p = symbol.power.toString();\n                if (isInt(p)) depth = depth - p; //it needs more room to find the integral\n\n                if (!arg.isComposite()) retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));else {\n                  //integral u du\n                  var u = core.Utils.getU(symbol);\n\n                  var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\n\n                  var du = __.diff(arg, dx);\n\n                  var u_du = _.multiply(f, du);\n\n                  var integral = __.integrate(u_du, u, depth, opt);\n\n                  retval = _.multiply(_.parse(m), integral.sub(u, arg));\n                }\n              } else if (fname === TAN && symbol.power.lessThan(0)) {\n                //convert to cotangent\n                var sym = symbol.clone();\n                sym.power.negate();\n                sym.fname = COT;\n                return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\n              } else {\n                if (!a.contains(dx, true) && symbol.isLinear()) {\n                  //perform a deep search for safety\n                  //first handle the special cases \n                  if (fname === ABS) {\n                    //REVISIT **TODO**\n                    var x = _.divide(arg.clone(), a.clone());\n\n                    if (x.group === S && !x.power.lessThan(0)) {\n                      if (core.Utils.even(x.power)) {\n                        retval = __.integrate(arg, dx, depth);\n                      } else {\n                        var integrated = __.integrate(x, dx, depth);\n\n                        integrated.power = integrated.power.subtract(new Frac(1));\n                        retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\n                      }\n                    } else __.integration.stop();\n                  } else {\n                    var ag = symbol.args[0].group,\n                        decomposed = __.integration.decompose_arg(arg, dx);\n\n                    if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc()) __.integration.stop();\n                    /**TODO**/\n                    //ASIN, ACOS, ATAN\n\n                    switch (fname) {\n                      case COS:\n                        retval = _.symfunction(SIN, [arg]);\n                        break;\n\n                      case SIN:\n                        retval = _.symfunction(COS, [arg]);\n                        retval.negate();\n                        break;\n\n                      case TAN:\n                        retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\n                        break;\n\n                      case SEC:\n                        retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\n                        break;\n\n                      case CSC:\n                        retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\n                        break;\n\n                      case COT:\n                        retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\n                        break;\n\n                      case SINH:\n                        retval = _.symfunction(COSH, [arg]);\n                        break;\n\n                      case COSH:\n                        retval = _.symfunction(SINH, [arg]);\n                        break;\n\n                      case TANH:\n                        retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\n                        break;\n\n                      case ASEC:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACSC:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACOT:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n                      //inverse htrig\n\n                      case ASECH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACSCH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n\n                      case ACOTH:\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        break;\n                      //end inverse htrig\n                      //htrigh\n\n                      case SECH:\n                        retval = _.parse(format('atan(sinh({0}))', arg));\n                        break;\n\n                      case CSCH:\n                        retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\n                        break;\n\n                      case COTH:\n                        retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\n                        break;\n                      //end htrig\n\n                      case EXP:\n                        retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\n                        break;\n\n                      case 'S':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        var b_ = dc[3];\n                        retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\n                        break;\n\n                      case 'C':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        var b_ = dc[3];\n                        retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\n                        break;\n\n                      case 'erf':\n                        var arg = symbol.args[0].clone(),\n                            dc = __.integration.decompose_arg(arg, dx),\n                            x_ = dc[1],\n                            a_ = dc[0];\n\n                        retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\n                        break;\n\n                      case 'sign':\n                        retval = _.multiply(symbol.clone(), arg.clone());\n                        break;\n\n                      default:\n                        __.integration.stop();\n\n                    }\n\n                    retval = _.divide(retval, a);\n                  }\n                } else if (x.isLinear()) {\n                  if (fname === COS || fname === SIN) {\n                    var p = Number(symbol.power); //check to see if it's negative and then just transform it to sec or csc\n\n                    if (p < 0) {\n                      symbol.fname = fname === SIN ? CSC : SEC;\n                      symbol.invert().updateHash();\n                      retval = __.integrate(symbol, dx, depth);\n                    } else {\n                      var arg = symbol.args[0],\n                          rd = symbol.clone(),\n                          //cos^(n-1)\n                      rd2 = symbol.clone(),\n                          //cos^(n-2)\n                      q = new Symbol((p - 1) / p),\n                          //\n                      na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\n\n\n                      rd.power = rd.power.subtract(new Frac(1));\n                      rd2.power = rd2.power.subtract(new Frac(2));\n\n                      var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\n\n                      if (fname === SIN) t.negate();\n                      retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\n                    }\n                  } //tan(x)^n or cot(x)^n\n                  else if (fname === TAN || fname === COT) {\n                      //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                      if (symbol.args[0].isLinear(dx)) {\n                        var n = symbol.power.subtract(new Frac(1)).toString(),\n                            r = symbol.clone().toUnitMultiplier(),\n                            w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\n\n                        r.power = r.power.subtract(new Frac(2));\n                        if (r.power.equals(0)) r = _.parse(r);\n                        retval = _.subtract(w, __.integrate(r, dx, depth));\n                      }\n                    } //sec(x)^n or csc(x)^n\n                    else if (fname === SEC || fname === CSC) {\n                        //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                        var n1 = symbol.power.subtract(new Frac(1)).toString(),\n                            n2 = symbol.power.subtract(new Frac(2)).toString(),\n                            f2 = fname === SEC ? TAN : COT,\n                            r = symbol.clone().toUnitMultiplier(),\n                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\n                            w = _.parse(parse_str);\n\n                        r.power = r.power.subtract(new Frac(2));\n                        if (r.power.equals(0)) r = _.parse(r);\n                        retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\n                      } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\n                        retval = __.integrate(symbol.fnTransform(), dx, depth);\n                      } else __.integration.stop();\n                } else __.integration.stop();\n\n                retval.multiplier = retval.multiplier.multiply(m);\n              }\n            } else if (g === PL) {\n              retval = __.integration.partial_fraction(symbol, dx, depth);\n            } else if (g === CB) {\n              var den = symbol.getDenom();\n              if (den.group === S) symbol = _.expand(symbol); //separate the coefficient since all we care about are symbols containing dx\n\n              var coeff = symbol.stripVar(dx); //now get only those that apply\n\n              var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\n              //peform a correction for stripVar. This is a serious TODO!\n\n\n              if (coeff.contains(dx)) {\n                cfsymbol = _.multiply(cfsymbol, coeff);\n                coeff = new Symbol(1);\n              } //if we only have one symbol left then let's not waste time. Just pull the integral\n              //and let the chips fall where they may\n\n\n              if (cfsymbol.group !== CB) {\n                if (cfsymbol.equals(1)) {\n                  return __.integrate(_.expand(symbol), dx, depth);\n                } //only factor for multivariate which are polynomials\n\n\n                if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\n                  cfsymbol = core.Algebra.Factor.factor(cfsymbol);\n                }\n\n                retval = __.integrate(cfsymbol, dx, depth);\n              } else {\n                //we collect the symbols and sort them descending group, descending power, descending alpabethically\n                var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\n                  if (a.group === b.group) {\n                    if (Number(a.power) === Number(b.power)) if (a < b) return 1; //I want sin first\n                    else return -1;\n                    return b.power - a.power; //descending power\n                  }\n\n                  return b.group - a.group; //descending groups\n                }).map(function (x) {\n                  var unwrapped = Symbol.unwrapSQRT(x, true);\n\n                  if (unwrapped.fname === EXP) {\n                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\n                  }\n\n                  return unwrapped;\n                });\n                var l = symbols.length;\n\n                if (symbol.power < 0) {\n                  if (l === 2) {\n                    return __.integrate(_.expand(symbol), dx, depth, opt);\n                  }\n                } //otherwise the denominator is one lumped together symbol \n                else {\n                    //generate an image for \n                    if (l === 2) {\n                      //try u substitution\n                      try {\n                        retval = __.integration.u_substitution(symbols, dx);\n                      } catch (e) {\n                        /* failed :`(*/\n                        ;\n                      }\n\n                      if (!retval) {\n                        //no success with u substitution so let's try known combinations\n                        //are they two functions\n                        var g1 = symbols[0].group,\n                            g2 = symbols[1].group,\n                            sym1 = symbols[0],\n                            sym2 = symbols[1],\n                            fn1 = sym1.fname,\n                            fn2 = sym2.fname; //reset the symbol minus the coeff\n\n                        symbol = _.multiply(sym1.clone(), sym2.clone());\n\n                        if (g1 === FN && g2 === FN) {\n                          if (fn1 === LOG || fn2 === LOG) {\n                            retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\n                          } else {\n                            symbols.sort(function (a, b) {\n                              return b.fname > a.fname;\n                            });\n                            var arg1 = sym1.args[0]; //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\n\n                            if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S)) __.integration.stop();\n\n                            var decomp = __.integration.decompose_arg(arg1, dx);\n\n                            x = decomp[1], a = decomp[0];\n                            if (!x.isLinear()) //again... linear arguments only wrt x\n                              __.integration.stop(); //they have to have the same arguments and then we have cleared all the check to \n                            //make sure we can integrate FN & FN\n\n                            var arg2 = sym2.args[0]; //make sure that their argument matches\n\n                            if (arg1.equals(arg2)) {\n                              if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\n                                if (sym1.power.lessThan(0)) __.integration.stop(); //we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\n                                //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\n\n                                if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\n                                  sym1.fname = TAN;\n                                  sym1.updateHash();\n                                  retval = __.integrate(sym1, dx, depth);\n                                } else {\n                                  if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\n                                    //transform sin^(2*n) to (1-cos^2)^n\n                                    var n = Number(sym1.power) / 2,\n                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\n\n                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                  } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\n                                    //transform cos^(2*n) to (1-sin^2)^n\n                                    var n = Number(sym1.power) / 2,\n                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\n\n                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                                  } else {\n                                    var p1_even = core.Utils.even(sym1.power),\n                                        p2_even = core.Utils.even(sym2.power);\n                                    retval = new Symbol(0);\n\n                                    if (!p1_even || !p2_even) {\n                                      var u, r, trans; //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\n                                      //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\n\n                                      if (!p1_even) {\n                                        //u = sin(x)\n                                        u = sym2;\n                                        r = sym1;\n                                      } else {\n                                        u = sym1;\n                                        r = sym2;\n                                      } //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\n\n\n                                      var sign = u.fname === COS ? -1 : 1,\n                                          n = r.power,\n                                          //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \n                                      //even powers afterwards which can be transformed\n                                      k = (n - 1) / 2,\n                                          //make the transformation cos(x)^2 = 1 - sin(x)^2\n                                      trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\n                                          sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans))); //we can now just loop through and integrate each since it's now just a polynomial with functions\n\n\n                                      sym.each(function (x) {\n                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\n                                      });\n                                    } else {\n                                      //performs double angle transformation\n                                      var double_angle = function double_angle(symbol) {\n                                        var p = symbol.power,\n                                            k = p / 2,\n                                            e;\n                                        if (symbol.fname === COS) e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;else e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\n                                        return _.parse(e);\n                                      }; //they're both even so transform both using double angle identities and we'll just\n                                      //be able to integrate by the sum of integrals\n\n\n                                      var a = double_angle(sym1),\n                                          b = double_angle(sym2),\n                                          t = _.multiply(a, b);\n\n                                      var sym = _.expand(t);\n\n                                      sym.each(function (x) {\n                                        retval = _.add(retval, __.integrate(x, dx, depth));\n                                      });\n                                      return _.multiply(retval, coeff);\n                                    }\n                                  }\n                                }\n                              } //tan(x)*sec(x)^n \n                              else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\n                                  retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\n                                } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {\n                                  //remaining: tan(x)^3*sec(x)^6\n                                  if (sym1.isLinear() && sym2.isLinear()) {\n                                    retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\n                                  } else if (even(sym1.power)) {\n                                    var p = Number(sym1.power) / 2; //transform tangent\n\n                                    var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\n\n                                    retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\n                                  } else __.integration.stop();\n                                } else if (fn1 === SEC && fn2 === COS) {\n                                  sym1.fname = COS;\n                                  sym1.invert().updateHash();\n                                  retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                } else if (fn1 === SIN && fn2 === CSC) {\n                                  sym2.fname = SIN;\n                                  sym2.invert().updateHash();\n                                  retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                                } //tan/cos\n                                else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\n                                    var t = _.multiply(sym1.fnTransform(), sym2);\n\n                                    retval = __.integrate(_.expand(t), dx, depth);\n                                  } else {\n                                    var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\n\n                                    retval = __.integrate(_.expand(t), dx, depth);\n                                  }\n                            } //TODO: REVISIT AT SOME POINT\n                            else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\n                                var transformed = trigTransform(symbols);\n                                retval = __.integrate(_.expand(transformed), dx, depth);\n                              } else {\n                                __.integration.stop();\n                              }\n                          }\n                        } else if (g1 === FN && g2 === S) {\n                          var sym1_is_linear = sym1.isLinear();\n                          if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Ci', [sym1.args[0]]);else if (sym1.fname === COS && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Chi', [sym1.args[0]]);else if (sym1.fname === COSH && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Si', [sym1.args[0]]);else if (sym1.fname === SIN && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Shi', [sym1.args[0]]);else if (sym1.fname === SINH && sym2.power.equals(-1)) {\n                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                          } else if (sym1.fname === LOG && sym2.power.equals(-1)) {\n                            //log(x)^n/x = log(x)^(n+1)/(n+1)\n                            retval = __.integration.poly_integrate(sym1, dx, depth);\n                          } else if (sym1.fname === 'erf') {\n                            if (sym2.power.equals(1)) {\n                              var dc = __.integration.decompose_arg(sym1.args[0], dx),\n                                  a_ = dc[0],\n                                  x_ = dc[1],\n                                  arg = sym1.args[0].toString();\n\n                              retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg));\n                            }\n                          } else {\n                            //since group S is guaranteed convergence we need not worry about tracking depth of integration\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else if (g1 === EX && g2 === S) {\n                          var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\n\n                          if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\n                            retval = _.symfunction('Ei', [sym1.power.clone()]);\n                          } else if (fn1 === LOG && x.value === sym2.value) {\n                            retval = __.integration.poly_integrate(sym1, dx, depth);\n                          } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        } else if (g1 === PL && g2 === S) {\n                          //first try to reduce the top\n                          if (sym2.value === sym1.value && sym1.power.equals(-1)) {\n                            //find the lowest power in the denominator\n                            var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols)); //get the lowest common value between denominator and numerator\n\n                            var pc = Math.min(pd, sym2.power); //reduce both denominator and numerator by that factor\n\n                            var factor = sym2.clone();\n                            factor.power = new Frac(pc);\n                            sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\n\n                            var t = new Symbol(0);\n                            sym1.each(function (x) {\n                              t = _.add(t, _.divide(x.clone(), factor.clone()));\n                            });\n                            t.multiplier = sym1.multiplier;\n                            symbol = _.divide(sym2, t);\n                          } else {\n                            symbol = _.expand(symbol);\n                          }\n\n                          retval = __.integration.partial_fraction(symbol, dx, depth);\n                        } else if (g1 === CP && g2 === S) {\n                          var f = sym1.clone().toLinear(),\n                              f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1); //handle cases x^(2*n)/sqrt(1-x^2)\n\n                          if (sym1.power.equals(-1 / 2)) {\n                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\n\n                            var a = decomp[0].negate(),\n                                x = decomp[1],\n                                b = decomp[3],\n                                p1 = Number(sym1.power),\n                                p2 = Number(sym2.power);\n\n                            if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\n                              //if the substitution \n                              var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)), _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])), _.pow(a.clone(), new Symbol(2)));\n\n                              c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\n\n                              var dummy = _.parse('sin(u)');\n\n                              dummy.power = dummy.power.multiply(sym2.power);\n\n                              var integral = __.integrate(dummy, 'u', depth);\n\n                              var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\n\n                              retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\n                            } else if (p1 === -1 / 2) {\n                              var u_transform = function u_transform(f, u) {\n                                var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\n\n                                if (!integral.hasIntegral()) return integral;\n                              };\n\n                              if (p2 === -1) {\n                                retval = u_transform(_.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(), 'sqrt(1-1/({0})^2)');\n                              } else if (p2 === -2) {\n                                //apply transformation to see if it matches asin(x)\n                                retval = u_transform(_.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(), 'sqrt(1-1/({0})^2)');\n                              }\n                            }\n                          } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\n                            retval = __.integration.partial_fraction(symbol, dx, depth);\n                          } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {\n                            //sum of integrals\n                            var expanded = _.expand(sym1);\n\n                            retval = new Symbol(0);\n                            expanded.each(function (x) {\n                              if (x.group === PL) {\n                                x.each(function (y) {\n                                  retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\n                                });\n                              } else retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\n                            });\n                          } else if (sym1.power.lessThan(-2)) {\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\n                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                a = decomp[0].negate(),\n                                x = decomp[1],\n                                b = decomp[3],\n                                fn = sym1.clone().toLinear();\n\n                            if (x.group !== PL && x.isLinear()) {\n                              var p = Number(sym2.power),\n                                  du = '_u_',\n                                  u = new Symbol(du),\n                                  //pull the integral with the subsitution\n                              U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\n                                  scope = {}; //generate a scope for resubbing the symbol\n\n\n                              scope[du] = fn;\n\n                              var U2 = _.parse(U, scope);\n\n                              retval = __.integrate(U2, dx, 0);\n                            } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\n                              //factor out coefficients\n                              var factors = new core.Algebra.Classes.Factors();\n                              sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\n                              var div = core.Algebra.divide(sym2, sym1); //it assumed that the result will be of group CB\n\n                              if (div.group !== CB) {\n                                retval = new Symbol(0);\n                                div.each(function (t) {\n                                  retval = _.add(retval, __.integrate(t, dx, depth));\n                                }); //put back the factors\n\n                                factors.each(function (factor) {\n                                  retval = _.divide(retval, factor);\n                                });\n                                retval = _.expand(retval);\n                              } else {\n                                //try something else\n                                retval = __.integration.by_parts(symbol, dx, depth, opt);\n                              }\n                            } else retval = __.integration.partial_fraction(symbol, dx, depth);\n                          } else {\n                            //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \n                            if (sym1.power.den.equals(2)) {\n                              //assume the function is in the form (a^2-b*x^n)^(m/2)\n                              var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                                  //using the above definition\n                              a = dc[3],\n                                  x = dc[1],\n                                  b = dc[0],\n                                  bx = dc[2];\n\n                              if (x.power.equals(2) && b.lessThan(0)) {\n                                //if n is even && b is negative\n                                //make a equal 1 so we can do a trig sub\n                                if (!a.equals(1)) {\n                                  //divide a out of everything\n                                  //move a to the coeff\n                                  coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\n                                }\n\n                                var u = dx;\n\n                                var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\n                                    du = _.symfunction(COS, [new Symbol(u)]),\n                                    cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\n                                    X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\n                                    val = _.multiply(_.multiply(cosn, du), X),\n                                    integral = __.integrate(val, u, depth); //but remember that u = asin(sqrt(b)*a*x)\n\n\n                                retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\n                              } else {\n                                retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                              }\n                            } else if (f_is_linear) {\n                              retval = __.integration.partial_fraction(symbol, dx, depth);\n                            }\n                          }\n                        } else if (sym1.isComposite() && sym2.isComposite()) {\n                          //sum of integrals\n                          retval = new Symbol(0);\n\n                          if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\n                            //combine and pull the integral of each\n                            var sym = _.expand(symbol);\n\n                            sym.each(function (x) {\n                              retval = _.add(retval, __.integrate(x, dx, depth));\n                            }, true);\n                          } else {\n                            var p1 = Number(sym1.power),\n                                p2 = Number(sym2.power);\n\n                            if (p1 < 0 && p2 > 0) {\n                              //swap\n                              var t = sym1;\n                              sym1 = sym2;\n                              sym2 = t;\n                            }\n\n                            if (p1 === -1 && p2 === -1) {\n                              retval = __.integration.partial_fraction(symbol, dx);\n                            } else {\n                              sym1.each(function (x) {\n                                var k = _.multiply(x, sym2.clone());\n\n                                var integral = __.integrate(k, dx, depth);\n\n                                retval = _.add(retval, integral);\n                              });\n                            }\n                          }\n                        } else if (g1 === CP && symbols[0].power.greaterThan(0)) {\n                          sym1 = _.expand(sym1);\n                          retval = new Symbol(0);\n                          sym1.each(function (x) {\n                            retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\n                          }, true);\n                        } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\n                          sym1 = sym1.fnTransform();\n                          retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\n                        } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\n                          if (g2 === FN && g1 === CP) {\n                            var t = sym1;\n                            sym1 = sym2;\n                            sym2 = t; //swap\n                          }\n\n                          var du, sym2_clone, p, q, sa, sb;\n                          du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\n                          sym2_clone = Symbol.unwrapSQRT(sym2, true);\n\n                          if (du.power.equals(sym2_clone.power)) {\n                            p = new Symbol(sym2.power);\n                            sa = du.clone().toLinear();\n                            sb = sym2.clone().toLinear();\n                            q = core.Algebra.divide(sa.toLinear(), sb);\n\n                            if (q.isConstant()) {\n                              var nq = _.pow(q, p.negate());\n\n                              retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\n                            }\n                          } else {\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else {\n                          var syma = sym1.clone().toLinear();\n                          var symb = sym2.clone().toLinear();\n\n                          if (g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) && !syma.contains(dx) && !symb.contains(dx)) {\n                            retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))', syma.toString(), symb.toString(), sym1.power.multiplier.toString(), sym2.power.multiplier.toString(), dx));\n                          } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                        }\n                      }\n                    } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\n                      var first = symbols[0];\n\n                      if (first.group === CP) {\n                        //TODO {support higher powers of x in the future}\n                        if (first.power.greaterThan(1)) first = _.expand(first);\n\n                        var r = _.multiply(symbols[1], symbols[2]);\n\n                        retval = new Symbol(0);\n                        first.each(function (x) {\n                          var t = _.multiply(x, r.clone());\n\n                          var intg = __.integrate(t, dx, depth);\n\n                          retval = _.add(retval, intg);\n                        }, true);\n                      } else {\n                        //try integration by parts although technically it will never work\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else if (all_functions(symbols)) {\n                      var t = new Symbol(1);\n\n                      for (var i = 0, l = symbols.length; i < l; i++) {\n                        t = _.multiply(t, symbols[i].fnTransform());\n                      }\n\n                      t = _.expand(t);\n                      retval = __.integrate(t, dx, depth);\n                    } else {\n                      //one more go\n                      var transformed = trigTransform(symbols);\n                      retval = __.integrate(_.expand(transformed), dx, depth);\n                    }\n                  }\n              }\n\n              retval = _.multiply(retval, coeff);\n            } //if an integral was found then we return it\n\n\n          if (retval) return retval;\n        } catch (error) {\n          //do nothing if it's a NoIntegralFound error otherwise let it bubble\n          if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero)) throw error;\n        } //no symbol found so we return the integral again\n\n\n        return _.symfunction('integrate', [original_symbol, dt]);\n      }, false);\n    },\n    defint: function defint(symbol, from, to, dx) {\n      dx = dx || 'x'; //make x the default variable of integration\n\n      var get_value = function get_value(integral, vars, point) {\n        try {\n          return _.parse(integral, vars);\n        } catch (e) {\n          //it failed for some reason so return the limit\n          var lim = __.Limit.limit(integral, dx, point);\n\n          return lim;\n        }\n      };\n\n      var vars = core.Utils.variables(symbol),\n          hasTrig = symbol.hasTrig();\n      var retval, integral;\n      if (vars.length === 1) dx = vars[0];\n\n      if (!hasTrig) {\n        integral = __.integrate(symbol, dx);\n      }\n\n      if (!hasTrig && !integral.hasIntegral()) {\n        var upper = {},\n            lower = {},\n            a,\n            b;\n        upper[dx] = to;\n        lower[dx] = from;\n        a = get_value(integral, upper, to, dx);\n        b = get_value(integral, lower, from, dx);\n        retval = _.subtract(a, b);\n      } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {\n        var f = core.Utils.build(symbol);\n        retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\n      } else retval = _.symfunction('defint', [symbol, from, to, dx]);\n\n      return retval;\n    },\n    Limit: {\n      interval: function interval(start, end) {\n        return _.parse(format('[{0}, {1}]', start, end));\n      },\n      diverges: function diverges() {\n        return __.Limit.interval('-Infinity', 'Infinity');\n      },\n      divide: function divide(f, g, x, lim, depth) {\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        }\n\n        var fin = f.clone(),\n            gin = g.clone(); //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\n        //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\n        //the two-sided limit.\n        //Known limit\n\n        if (g.fname === ABS) {\n          var sign = f.sign();\n          var lim_sign = lim.sign();\n          if (lim.isInfinity) return _.multiply(new Symbol(sign), new Symbol(lim_sign));else if (lim.equals(0)) {\n            var fm = _.parse(f.multiplier);\n\n            var gm = _.parse(g.multiplier);\n\n            return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\n          } else {\n            //TODO: Support more limits\n            __.Limit.diverges();\n          }\n        }\n\n        var isInfinity = function isInfinity(L) {\n          if (core.Utils.isVector(L)) {\n            for (var i = 0; i < L.elements.length; i++) {\n              if (!L.elements[i].isInfinity) return false;\n            }\n\n            return true;\n          }\n\n          return L.isInfinity;\n        };\n\n        var equals = function equals(L, v) {\n          if (core.Utils.isVector(L)) {\n            return false;\n          }\n\n          return L.equals(v);\n        };\n\n        var retval;\n\n        do {\n          var lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\n          var lim2 = evaluate(__.Limit.limit(g, x, lim, depth)); //if it's in indeterminate form apply L'Hospital's rule\n\n          var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0); //pull the derivatives\n\n          if (indeterminate) {\n            var ft = __.diff(fin.clone(), x);\n\n            var gt = __.diff(gin.clone(), x);\n\n            var t_symbol = _.expand(_.divide(ft, gt));\n\n            f = t_symbol.getNum();\n            g = t_symbol.getDenom();\n          }\n        } while (indeterminate); //TODO: \n        //REMEMBER: \n        //- 1/cos(x)\n        //n/0 is still possible since we only checked for 0/0\n\n\n        var den_is_zero = lim2.equals(0);\n        var p = Number(gin.power);\n\n        if (lim1.isConstant(true) && den_is_zero && core.Utils.isInt(p)) {\n          if (core.Utils.even(p)) {\n            retval = core.Symbol.infinity(); //Add the correct sign to infinity based on the sign of the constant\n\n            if (lim1.lessThan(0)) {\n              retval.negate();\n            }\n          } else {\n            //The limit diverges for odd powers\n            retval = __.Limit.diverges();\n          }\n        } else if (den_is_zero) {\n          retval = __.Limit.diverges();\n        } else retval = _.divide(lim1, lim2);\n\n        return retval;\n      },\n      rewriteToLog: function rewriteToLog(symbol) {\n        var p = symbol.power.clone();\n        symbol.toLinear();\n        return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\n      },\n      getSubbed: function getSubbed(f, x, lim) {\n        var retval; //1. rewrite EX with base e\n\n        if (f.group === EX) {\n          f = __.rewriteToLog(f);\n        } //2. try simple substitution\n\n\n        try {\n          retval = f.sub(x, lim);\n        } catch (e) {\n          //Nope. No go, so just return the unsubbed function so we can test the limit instead.\n          retval = f;\n        }\n\n        return retval;\n      },\n      isInterval: function isInterval(limit) {\n        return core.Utils.isVector(limit);\n      },\n      isConvergent: function isConvergent(limit) {\n        //it's not convergent if it lies on the interval -Infinity to Infinity\n        if ( //It lies on the interval -Infinity to Infinity\n        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity || //We weren't able to calculate the limit\n        limit.containsFunction('limit')) {\n          return false; //Then no\n        }\n\n        return true; //It is\n      },\n      limit: function limit(symbol, x, lim, depth) {\n        //Simplify the symbol\n        symbol = core.Algebra.Simplify.simplify(symbol);\n        depth = depth || 1;\n\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        } //store the multiplier\n\n\n        var m = _.parse(symbol.multiplier); //strip the multiplier\n\n\n        symbol.toUnitMultiplier();\n\n        try {\n          //https://en.wikipedia.org/wiki/List_of_limits\n          var retval; //we try the simplest option first where c is some limit\n          //lim a as x->c = a where c \n\n          if (symbol.isConstant(true)) {\n            retval = symbol;\n          } else {\n            var point = {};\n            point[x] = lim; //lim x as x->c = c where c\n\n            try {\n              //evaluate the function at the given limit\n              var t = _.parse(symbol.sub(x, lim), point); //a constant or infinity is known so we're done\n\n\n              if (t.isConstant(true) || t.isInfinity) retval = t;\n            } catch (e) {\n              /*Nothing. Maybe we tried to divide by zero.*/\n            }\n\n            ;\n\n            if (!retval) {\n              //split the symbol in the numerator and the denominator\n              var num = symbol.getNum();\n              var den = symbol.getDenom();\n\n              if (den.isConstant(true)) {\n                //We still don't have a limit so we generate tests.\n                if (symbol.group === EX) {\n                  //https://en.wikipedia.org/wiki/List_of_limits\n                  //Speed boost for exponentials by detecting patterns\n                  var f = symbol.clone().toLinear();\n                  var p = symbol.power.clone();\n\n                  var _num = f.getNum();\n\n                  var _den = f.getDenom();\n\n                  var fn = core.Utils.decompose_fn(_den, x, true); //start detection of pattern (x/(x+1))^x\n\n                  if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\n                    retval = _.parse(format('(1/e^({0}))', fn.b));\n                  } else {\n                    var symbol_ = __.Limit.rewriteToLog(symbol.clone()); //get the base\n\n\n                    var pow = symbol_.power.clone();\n                    var base = symbol_.clone().toLinear();\n\n                    var lim_base = __.Limit.limit(base, x, lim, depth);\n\n                    var lim_pow = __.Limit.limit(pow, x, lim, depth);\n\n                    retval = _.pow(lim_base, lim_pow);\n                  }\n                } else if (symbol.group === FN && symbol.args.length === 1) {\n                  var evaluates; //Squeeze theorem lim f(g(x)) = lim f(lim g))\n\n                  var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\n\n                  if (core.Utils.isVector(arg)) {\n                    //get the limit over that interval\n                    retval = arg.map(function (e) {\n                      var clone = symbol.clone();\n                      clone.args[0] = e;\n                      return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\n                    });\n                    return _.multiply(m, retval);\n                  } //if the argument is constant then we're done\n                  else if (arg.isConstant(true)) {\n                      //double check that it evaluates\n                      var trial = _.symfunction(symbol.fname, [arg]); //trial evaluation\n\n\n                      try {\n                        evaluate(trial);\n                        evaluates = true;\n                      } catch (e) {\n                        evaluates = false;\n                      }\n                    }\n\n                  if (evaluates) {\n                    retval = trial;\n                  } else {\n                    //if the limit converges. We'll deal with non-convergent ones later\n                    if (__.Limit.isConvergent(arg)) {\n                      if (symbol.fname === LOG) {\n                        switch (arg.toString()) {\n                          //lim -> 0\n                          case '0':\n                            retval = Symbol.infinity().negate();\n                            break;\n\n                          case 'Infinity':\n                            retval = Symbol.infinity();\n                            break;\n\n                          case '-Infinity':\n                            retval = Symbol.infinity();\n                            break;\n                        }\n                      } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\n                        retval = __.Limit.interval(-1, 1);\n                      } else if (symbol.fname === TAN) {\n                        var s_arg = symbol.args[0];\n                        var n = s_arg.getNum();\n                        var d = s_arg.getDenom();\n                        var pi = n.toUnitMultiplier();\n\n                        if (lim.isInfinity || pi.equals('pi') && d.equals(2)) {\n                          retval = divergent();\n                        }\n                      } else if (symbol.fname === Settings.FACTORIAL) {\n                        if (arg.isInfinity) return Symbol.infinity();\n                      }\n                    }\n                  }\n                } else if (symbol.group === S) {\n                  if (symbol.power > 0) //these functions always converge to the limit\n                    return _.parse(symbol, point);else {\n                    //we're dealing with 1/x^n but remember that infinity has already been dealt\n                    //with by substitution\n                    if (core.Utils.even(symbol.power)) {\n                      //even powers converge to infinity\n                      retval = Symbol.infinity();\n                    } else {\n                      //odd ones don't\n                      retval = __.Limit.diverges();\n                    }\n                  }\n                } else if (symbol.group === CB) {\n                  //if the group no longer is CB then feed it back to this function\n                  if (symbol.group !== CB) {\n                    retval = __.Limit.limit(symbol, x, lim, depth);\n                  } else {\n                    var lim1, lim2; //loop through all the symbols\n                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\n                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\n\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\n                      return a.group - b.group;\n                    });\n                    var f = symbols.pop(); //calculate the first limit so we can keep going down the list\n\n                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth)); //reduces all the limits one at a time\n\n                    while (symbols.length) {\n                      //get the second limit\n                      var g = symbols.pop(); //get the limit of g\n\n                      lim2 = evaluate(__.Limit.limit(g, x, lim, depth)); //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\n\n                      if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {\n                        if (g.containsFunction(LOG)) {\n                          //swap them\n                          g = [f, f = g][0];\n                        } //invert the symbol\n\n\n                        g.invert();\n                        lim1 = __.Limit.divide(f, g, x, lim, depth);\n                      } else {\n                        //lim f*g = (lim f)*(lim g)\n                        lim1 = _.multiply(lim1, lim2); //let f*g equal f and h equal g \n\n                        f = _.multiply(f, g);\n                      }\n                    } //Done, lim1 is the limit we're looking for     \n\n\n                    retval = lim1;\n                  }\n                } else if (symbol.isComposite()) {\n                  var _lim;\n\n                  if (!symbol.isLinear()) symbol = _.expand(symbol); //Apply lim f+g = (lim f)+(lim g)\n\n                  retval = new Symbol(0);\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return b.group - a.group;\n                  });\n                  var _symbols = []; //Analyze the functions first\n\n                  var fns = new Symbol(0);\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i].clone();\n\n                    if (sym.group === FN || sym.group === CB && sym.hasFunc()) {\n                      fns = _.add(fns, sym);\n                    } else _symbols.push(sym);\n                  }\n\n                  _symbols.unshift(fns); //make sure that we didn't just repackage the exact same symbol\n\n\n                  if (_symbols.length !== 1) {\n                    symbols = _symbols;\n                  }\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i]; //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\n\n                    try {\n                      _lim = __.Limit.limit(sym, x, lim, depth);\n                    } catch (e) {\n                      _lim = __.Limit.diverges();\n                    }\n\n                    try {\n                      retval = _.add(retval, _lim);\n                    } catch (e) {\n                      if (depth++ > Settings.max_lim_depth) {\n                        return;\n                      }\n\n                      ;\n                      retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth); //rewrite the function to have a common denominator. \n                      //TODO: This is soooo slow at the moment.\n                      //                                            symbol = core.Utils.toCommonDenominator(original);\n                      //                                            retval = __.Limit.limit(symbol, x, lim);\n                    }\n                  }\n                }\n              } else {\n                retval = __.Limit.divide(num, den, x, lim, depth);\n              }\n            }\n          } //if we still don't have a solution\n\n\n          if (!retval) //return it symbolically\n            retval = _.symfunction('limit', [symbol, x, lim]);\n        } catch (e) {\n          //if all else fails return the symbolic function\n          retval = _.symfunction('limit', [symbol, x, lim]);\n        }\n\n        return _.multiply(m, retval);\n      }\n    },\n    Fresnel: {\n      S: function S(x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('S', arguments);\n      },\n      C: function C(x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('C', arguments);\n      }\n    }\n  };\n\n  nerdamer.register([{\n    name: 'diff',\n    visible: true,\n    numargs: [1, 3],\n    build: function build() {\n      return __.diff;\n    }\n  }, {\n    name: 'sum',\n    visible: true,\n    numargs: 4,\n    build: function build() {\n      return __.sum;\n    }\n  }, {\n    name: 'product',\n    visible: true,\n    numargs: 4,\n    build: function build() {\n      return __.product;\n    }\n  }, {\n    name: 'integrate',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      return __.integrate;\n    }\n  }, {\n    name: 'defint',\n    visible: true,\n    numargs: [3, 4],\n    build: function build() {\n      return __.defint;\n    }\n  }, {\n    name: 'S',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Fresnel.S;\n    }\n  }, {\n    name: 'C',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Fresnel.C;\n    }\n  }, {\n    name: 'limit',\n    visible: true,\n    numargs: [3, 4],\n    build: function build() {\n      return __.Limit.limit;\n    }\n  }]); //link registered functions externally\n\n  nerdamer.api();\n})();","require(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.array.filter\");\n\nrequire(\"core-js/modules/es6.regexp.replace\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nrequire(\"core-js/modules/es6.regexp.split\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\nrequire(\"core-js/modules/es6.array.map\");\n\nrequire(\"core-js/modules/es6.string.sub\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.number.constructor\");\n\nrequire(\"core-js/modules/es6.number.epsilon\");\n\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  //handle imports\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      _A = core.Algebra,\n      _C = core.Calculus,\n      explode = _C.integration.decompose_arg,\n      evaluate = core.Utils.evaluate,\n      remove = core.Utils.remove,\n      format = core.Utils.format,\n      build = core.Utils.build,\n      Symbol = core.Symbol,\n      isSymbol = core.Utils.isSymbol,\n      variables = core.Utils.variables,\n      S = core.groups.S,\n      PL = core.groups.PL,\n      CB = core.groups.CB,\n      CP = core.groups.CP,\n      FN = core.groups.FN,\n      Settings = core.Settings,\n      range = core.Utils.range,\n      isArray = core.Utils.isArray; // The search radius for the roots\n\n  core.Settings.SOLVE_RADIUS = 1000; // The maximum number to fish for on each side of the zero\n\n  core.Settings.ROOTS_PER_SIDE = 10; // Covert the number to multiples of pi if possible\n\n  core.Settings.make_pi_conversions = true; // The step size\n\n  core.Settings.STEP_SIZE = 0.1; //the maximum iterations for Newton's method\n\n  core.Settings.MAX_NEWTON_ITERATIONS = 200; //the maximum number of time non-linear solve tries another jump point\n\n  core.Settings.MAX_NON_LINEAR_TRIES = 12; //the amount of iterations the function will start to jump at\n\n  core.Settings.NON_LINEAR_JUMP_AT = 50; //the size of the jump\n\n  core.Settings.NON_LINEAR_JUMP_SIZE = 100; //the original starting point for nonlinear solving\n\n  core.Settings.NON_LINEAR_START = 0.01; //When points are generated as starting points for Newton's method, they are sliced into small\n  //slices to make sure that we have convergence on the right point. This defines the \n  //size of the slice\n\n  core.Settings.NEWTON_SLICES = 200; //The epsilon used in Newton's iteration\n\n  core.Settings.NEWTON_EPSILON = Number.EPSILON * 2; //The distance in which two solutions are deemed the same\n\n  core.Settings.SOLUTION_PROXIMITY = 1e-14; //Indicate wheter to filter the solutions are not\n\n  core.Settings.FILTER_SOLUTIONS = true; //the maximum number of recursive calls\n\n  core.Settings.MAX_SOLVE_DEPTH = 10;\n\n  core.Symbol.prototype.hasTrig = function () {\n    return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\n  };\n\n  core.Symbol.prototype.hasNegativeTerms = function () {\n    if (this.isComposite()) {\n      for (var x in this.symbols) {\n        var sym = this.symbols[x];\n        if (sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0)) return true;\n      }\n    }\n\n    return false;\n  };\n  /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n   * As such we can have this data type be supported completely outside of the core.\r\n   * This is an equation that has a left hand side and a right hand side\r\n   */\n\n\n  function Equation(lhs, rhs) {\n    if (rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY)) throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\n    this.LHS = lhs; //left hand side\n\n    this.RHS = rhs; //right and side\n  }\n\n  ; //UTILS ##!!\n\n  Equation.prototype = {\n    toString: function toString() {\n      return this.LHS.toString() + '=' + this.RHS.toString();\n    },\n    text: function text(option) {\n      return this.LHS.text(option) + '=' + this.RHS.text(option);\n    },\n    toLHS: function toLHS(expand) {\n      expand = typeof expand === 'undefined' ? true : false;\n      var eqn;\n\n      if (!expand) {\n        eqn = this.clone();\n      } else {\n        eqn = this.removeDenom();\n      }\n\n      var _t = _.subtract(eqn.LHS, eqn.RHS);\n\n      var retval = expand ? _.expand(_t) : _t;\n      return retval;\n    },\n    removeDenom: function removeDenom() {\n      var a = this.LHS.clone();\n      var b = this.RHS.clone(); //remove the denominator on both sides\n\n      var den = _.multiply(a.getDenom(), b.getDenom());\n\n      a = _.expand(_.multiply(a, den.clone()));\n      b = _.expand(_.multiply(b, den)); //swap the groups\n\n      if (b.group === CP && b.group !== CP) {\n        var t = a;\n        a = b;\n        b = t; //swap\n      } //scan to eliminate denominators\n\n\n      if (a.group === CB) {\n        var t = new Symbol(a.multiplier),\n            newRHS = b.clone();\n        a.each(function (y) {\n          if (y.power.lessThan(0)) newRHS = _.divide(newRHS, y);else t = _.multiply(t, y);\n        });\n        a = t;\n        b = newRHS;\n      } else if (a.group === CP) {\n        //the logic: loop through each and if it has a denominator then multiply it out on both ends\n        //and then start over\n        for (var x in a.symbols) {\n          var sym = a.symbols[x];\n\n          if (sym.group === CB) {\n            for (var y in sym.symbols) {\n              var sym2 = sym.symbols[y];\n\n              if (sym2.power.lessThan(0)) {\n                return new Equation(_.expand(_.multiply(sym2.clone().toLinear(), a)), _.expand(_.multiply(sym2.clone().toLinear(), b)));\n              }\n            }\n          }\n        }\n      }\n\n      return new Equation(a, b);\n    },\n    clone: function clone() {\n      return new Equation(this.LHS.clone(), this.RHS.clone());\n    },\n    sub: function sub(x, y) {\n      var clone = this.clone();\n      clone.LHS = clone.LHS.sub(x.clone(), y.clone());\n      clone.RHS = clone.RHS.sub(x.clone(), y.clone());\n      return clone;\n    },\n    isZero: function isZero() {\n      return core.Utils.evaluate(this.toLHS()).equals(0);\n    },\n    latex: function latex(option) {\n      return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\n    }\n  }; //overwrite the equals function\n\n  _.equals = function (a, b) {\n    return new Equation(a, b);\n  };\n  /**\r\n   * Sets two expressions equal\r\n   * @param {Symbol} symbol\r\n   * @returns {Expression}\r\n   */\n\n\n  core.Expression.prototype.equals = function (symbol) {\n    if (symbol instanceof core.Expression) symbol = symbol.symbol; //grab the symbol if it's an expression\n\n    var eq = new Equation(this.symbol, symbol);\n    return eq;\n  };\n\n  core.Expression.prototype.solveFor = function (x) {\n    var symbol;\n\n    if (this.symbol instanceof Equation) {\n      //exit right away if we already have the answer\n      //check the LHS\n      if (this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x)) return new core.Expression(this.symbol.LHS); //check the RHS\n\n      if (this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x)) return new core.Expression(this.symbol.RHS); //otherwise just bring it to LHS\n\n      symbol = this.symbol.toLHS();\n    } else {\n      symbol = this.symbol;\n    }\n\n    return _solve(symbol, x).map(function (x) {\n      return new core.Expression(x);\n    });\n  };\n\n  core.Expression.prototype.expand = function () {\n    if (this.symbol instanceof Equation) {\n      var clone = this.symbol.clone();\n      clone.RHS = _.expand(clone.RHS);\n      clone.LHS = _.expand(clone.LHS);\n      return new core.Expression(clone);\n    }\n\n    return new core.Expression(_.expand(this.symbol));\n  };\n\n  core.Expression.prototype.variables = function () {\n    if (this.symbol instanceof Equation) return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\n    return variables(this.symbol);\n  };\n\n  core.Matrix.jacobian = function (eqns, vars) {\n    var jacobian = new core.Matrix(); //get the variables if not supplied\n\n    if (!vars) {\n      vars = __.getSystemVariables(eqns);\n    }\n\n    vars.forEach(function (v, i) {\n      eqns.forEach(function (eq, j) {\n        var e = core.Calculus.diff(eq.clone(), v);\n        jacobian.set(j, i, e);\n      });\n    });\n    return jacobian;\n  };\n\n  core.Matrix.prototype.max = function () {\n    var max = new Symbol(0);\n    this.each(function (x) {\n      var e = x.abs();\n      if (e.gt(max)) max = e;\n    });\n    return max;\n  };\n\n  core.Matrix.cMatrix = function (value, vars) {\n    var m = new core.Matrix(); //make an initial guess\n\n    vars.forEach(function (v, i) {\n      m.set(i, 0, _.parse(value));\n    });\n    return m;\n  };\n\n  var setEq = function setEq(a, b) {\n    return _.equals(a, b);\n  }; //link the Equation class back to the core\n\n\n  core.Equation = Equation; //Loops through an array and attempts to fails a test. Stops if manages to fail.\n\n  var checkAll = core.Utils.checkAll = function (args, test) {\n    for (var i = 0; i < args.length; i++) {\n      if (test(args[i])) return false;\n    }\n\n    return true;\n  }; //version solve\n\n\n  var __ = core.Solve = {\n    version: '2.0.3',\n    solutions: [],\n    solve: function solve(eq, variable) {\n      var solution = _solve(eq, String(variable));\n\n      return new core.Vector(solution); //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\n    },\n\n    /**\r\n     * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n     * @param {Equation|String} eqn\r\n     * @returns {Symbol}\r\n     */\n    toLHS: function toLHS(eqn, expand) {\n      if (isSymbol(eqn)) return eqn; //If it's an equation then call its toLHS function instead\n\n      if (!(eqn instanceof Equation)) {\n        var es = eqn.split('='); //convert falsey values to zero\n\n        es[1] = es[1] || '0';\n        eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\n      }\n\n      return eqn.toLHS(expand);\n    },\n    getSystemVariables: function getSystemVariables(eqns) {\n      vars = variables(eqns[0], null, null, true); //get all variables\n\n      for (var i = 1, l = eqns.length; i < l; i++) {\n        vars = vars.concat(variables(eqns[i]));\n      } //remove duplicates\n\n\n      vars = core.Utils.arrayUnique(vars).sort(); //done\n\n      return vars;\n    },\n    solveNonLinearSystem: function solveNonLinearSystem(eqns, tries, start) {\n      if (tries < 0) return []; //can't find a solution\n\n      start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start; //the maximum number of times to jump\n\n      var max_tries = core.Settings.MAX_NON_LINEAR_TRIES; //halfway through the tries\n\n      var halfway = Math.floor(max_tries / 2); //initialize the number of tries to 10 if not specified\n\n      tries = typeof tries === 'undefined' ? max_tries : tries; //a point at which we check to see if we're converging. By inspection it seems that we can\n      //use around 20 iterations to see if we're converging. If not then we retry a jump of x\n\n      var jump_at = core.Settings.NON_LINEAR_JUMP_AT; //we jump by this many points at each pivot point\n\n      var jump = core.Settings.NON_LINEAR_JUMP_SIZE; //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\n\n      var found = true;\n\n      var create_subs = function create_subs(vars, matrix) {\n        return vars.map(function (x, i) {\n          return Number(matrix.get(i, 0));\n        });\n      };\n\n      var vars = __.getSystemVariables(eqns);\n\n      var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\n        return build(x, vars);\n      }, true);\n      var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\n      var o, y, iters, xn1, norm, lnorm, xn, d;\n      var f_eqns = eqns.map(function (eq) {\n        return build(eq, vars);\n      });\n      var J = jacobian.map(function (e) {\n        return build(e, vars);\n      }, true); //initial values\n\n      xn1 = core.Matrix.cMatrix(0, vars);\n      ; //initialize the c matrix with something close to 0. \n\n      var c = core.Matrix.cMatrix(start, vars);\n      iters = 0; //start of algorithm\n\n      do {\n        //if we've reached the max iterations then exit\n        if (iters > max_iter) {\n          break;\n          found = false;\n        } //set the substitution object\n\n\n        o = create_subs(vars, c); //set xn\n\n        xn = c.clone(); //make all the substitutions for each of the equations\n\n        f_eqns.forEach(function (f, i) {\n          c.set(i, 0, f.apply(null, o));\n        });\n        var m = new core.Matrix();\n        J.each(function (fn, i, j) {\n          var ans = fn.apply(null, o);\n          m.set(i, j, ans);\n        });\n        m = m.invert(); //preform the elimination\n\n        y = _.multiply(m, c).negate(); //the callback is to avoid overflow in the coeffient denonimator\n        //it converts it to a decimal and then back to a fraction. Some precision\n        //is lost be it's better than overflow. \n\n        d = y.subtract(xn1, function (x) {\n          return _.parse(Number(x));\n        });\n        xn1 = xn.add(y, function (x) {\n          return _.parse(Number(x));\n        }); //move c is now xn1\n\n        c = xn1; //get the norm\n        //the expectation is that we're converging to some answer as this point regardless of where we start\n        //this may have to be adjusted at some point because of erroneous assumptions\n\n        if (iters >= jump_at) {\n          //check the norm. If the norm is greater than one then it's time to try another point\n          if (norm > 1) {\n            //reset the start point at halway\n            if (tries === halfway) start = 0;\n            var sign = tries > halfway ? 1 : -1; //which side are we incrementing\n            //we increment +n at one side and -n at the other. \n\n            n = tries % Math.floor(halfway) + 1; //adjust the start point\n\n            start += sign * n * jump; //call restart\n\n            return __.solveNonLinearSystem(eqns, --tries, start);\n          }\n        }\n\n        lnorm = norm;\n        iters++;\n        norm = d.max(); //exit early. Revisit if we get bugs\n\n        if (Number(norm) === Number(lnorm)) break;\n      } while (Number(norm) >= Number.EPSILON); //return a blank set if nothing was found;\n\n\n      if (!found) return []; //return c since that's the answer\n\n      return __.systemSolutions(c, vars, true, function (x) {\n        return core.Utils.round(Number(x), 14);\n      });\n    },\n    systemSolutions: function systemSolutions(result, vars, expand_result, callback) {\n      var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\n      result.each(function (e, idx) {\n        var solution = (expand_result ? _.expand(e) : e).valueOf();\n        if (callback) solution = callback.call(e, solution);\n        var variable = vars[idx];\n\n        if (core.Settings.SOLUTIONS_AS_OBJECT) {\n          solutions[variable] = solution;\n        } else solutions.push([variable, solution]);\n        /*NO*/\n\n      }); //done\n\n      return solutions;\n    },\n    //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\n    solveSystem: function solveSystem(eqns, var_array) {\n      //check if a var_array was specified\n      //nerdamer.clearVars();// this deleted ALL variables: not what we want\n      //parse all the equations to LHS. Remember that they come in as strings\n      for (var i = 0; i < eqns.length; i++) {\n        eqns[i] = __.toLHS(eqns[i]);\n      }\n\n      var l = eqns.length,\n          m = new core.Matrix(),\n          c = new core.Matrix(),\n          expand_result = false,\n          vars;\n\n      if (typeof var_array === 'undefined') {\n        //check to make sure that all the equations are linear\n        if (!_A.allLinear(eqns)) return __.solveNonLinearSystem(eqns); //core.err('System must contain all linear equations!');\n\n        vars = __.getSystemVariables(eqns); // deletes only the variables of the linear equations in the nerdamer namespace\n\n        for (var i = 0; i < vars.length; i++) {\n          nerdamer.setVar(vars[i], \"delete\");\n        } // populate the matrix\n\n\n        for (var i = 0; i < l; i++) {\n          var e = eqns[i]; //store the expression\n\n          for (var j = 0; j < l; j++) {\n            var v = vars[j];\n            var coeffs = [];\n            e.each(function (x) {\n              if (x.contains(v)) {\n                coeffs = coeffs.concat(x.coeffs());\n              }\n            });\n            var cf = core.Utils.arraySum(coeffs);\n            m.set(i, j, cf);\n          } //strip the variables from the symbol so we're left with only the zeroth coefficient\n          //start with the symbol and remove each variable and its coefficient\n\n\n          var num = e.clone();\n          vars.map(function (e) {\n            num = num.stripVar(e, true);\n          });\n          c.set(i, 0, num.negate());\n        }\n      } else {\n        /**\r\n         * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n         * through each term and see if and check to see if it matches one of the variables.\r\n         * When a match is found we mark it. No other match should be found for that term. If it\r\n         * is we stop since it's not linear.\r\n         */\n        vars = var_array;\n        expand_result = true;\n\n        for (i = 0; i < l; i++) {\n          //prefill\n          c.set(i, 0, new Symbol(0));\n\n          var e = _.expand(eqns[i]).collectSymbols(); //expand and store\n          //go trough each of the variables\n\n\n          for (var j = 0; j < var_array.length; j++) {\n            m.set(i, j, new Symbol(0));\n            var v = var_array[j]; //go through the terms and sort the variables\n\n            for (var k = 0; k < e.length; k++) {\n              var term = e[k],\n                  check = false;\n\n              for (var z = 0; z < var_array.length; z++) {\n                //check to see if terms contain multiple variables\n                if (term.contains(var_array[z])) {\n                  if (check) core.err('Multiple variables found for term ' + term);\n                  check = true;\n                }\n              } //we made sure that every term contains one variable so it's safe to assume that if the\n              //variable is found then the remainder is the coefficient.\n\n\n              if (term.contains(v)) {\n                var tparts = explode(remove(e, k), v);\n                m.set(i, j, _.add(m.get(i, j), tparts[0]));\n              }\n            }\n          } //all the remaining terms go to the c matrix\n\n\n          for (k = 0; k < e.length; k++) {\n            c.set(i, 0, _.add(c.get(i, 0), e[k]));\n          }\n        } //consider case (a+b)*I+u\n\n      } //check if the system has a distinct solution\n\n\n      if (m.determinant().equals(0)) throw new core.exceptions.SolveError('System does not have a distinct solution'); // Use M^-1*c to solve system\n\n      m = m.invert();\n      var result = m.multiply(c); //correct the sign as per issue #410\n\n      if (core.Utils.isArray(var_array)) result.each(function (x) {\n        return x.negate();\n      });\n      return __.systemSolutions(result, vars, expand_result);\n    },\n\n    /**\r\n     * The quadratic function but only one side.\r\n     * @param {Symbol} c\r\n     * @param {Symbol} b\r\n     * @param {Symbol} a\r\n     * @returns {Symbol}\r\n     */\n    quad: function quad(c, b, a) {\n      var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))\n      /*b^2 - 4ac*/\n      ;\n\n      var det = _.pow(discriminant, Symbol(0.5));\n\n      var retval = [_.parse(_.divide(_.add(b.clone().negate(), det.clone()), _.multiply(new Symbol(2), a.clone()))), _.parse(_.divide(_.subtract(b.clone().negate(), det.clone()), _.multiply(new Symbol(2), a.clone())))];\n      return retval;\n    },\n\n    /**\r\n     * The cubic equation\r\n     * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n     * @param {Symbol} d_o\r\n     * @param {Symbol} c_o\r\n     * @param {Symbol} b_o\r\n     * @param {Symbol} a_o\r\n     * @returns {Array}\r\n     */\n    cubic: function cubic(d_o, c_o, b_o, a_o) {\n      //convert everything to text\n      var a = a_o.text(),\n          b = b_o.text(),\n          c = c_o.text(),\n          d = d_o.text();\n\n      var d0s = '({1})^2-3*({0})*({2})',\n          d0 = _.parse(format(d0s, a, b, c)),\n          Q = _.parse(format('((2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3}))^2-4*(({1})^2-3*({0})*({2}))^3)^(1/2)', a, b, c, d)),\n          C = _.parse(format('((1/2)*(({4})+2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3})))^(1/3)', a, b, c, d, Q)); //check if C equals 0\n\n\n      var scope = {}; //populate the scope object\n\n      variables(C).map(function (x) {\n        scope[x] = 1;\n      });\n      var Ct = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(C, scope);\n      });\n      if (Number(d0) === 0 && Number(Ct) === 0) //negate Q such that C != 0\n        C = _.parse(format('((1/2)*(-({4})+2*({1})^3-9*({0})*({1})*({2})+27*({0})^2*({3})))^(1/3)', a, b, c, d, Q));\n      var xs = ['-(b/(3*a))-C/(3*a)-(((b^2-3*a*c))/(3*a*C))', '-(b/(3*a))+(C*(1+i*sqrt(3)))/(6*a)+((1-i*sqrt(3))*(b^2-3*a*c))/(6*a*C)'.replace(/i/g, core.Settings.IMAGINARY), '-(b/(3*a))+(C*(1-i*sqrt(3)))/(6*a)+((1+i*sqrt(3))*(b^2-3*a*c))/(6*a*C)'.replace(/i/g, core.Settings.IMAGINARY)];\n      return xs.map(function (e, i) {\n        var o = {\n          a: a_o.clone(),\n          b: b_o.clone(),\n          c: c_o.clone(),\n          d: d_o.clone(),\n          C: C.clone()\n        };\n        return _.parse(e, o);\n      });\n    },\n\n    /**\r\n     * The quartic equation\r\n     * @param {Symbol} e\r\n     * @param {Symbol} d\r\n     * @param {Symbol} c\r\n     * @param {Symbol} b\r\n     * @param {Symbol} a\r\n     * @returns {Array}\r\n     */\n    quartic: function quartic(e, d, c, b, a) {\n      var scope = {};\n      core.Utils.arrayUnique(variables(a).concat(variables(b)).concat(variables(c)).concat(variables(d)).concat(variables(e))).map(function (x) {\n        scope[x] = 1;\n      });\n      a = a.toString();\n      b = b.toString();\n      c = c.toString();\n      d = d.toString();\n      e = e.toString();\n      var p, q, D, D0, D1, Q, x1, x2, x3, x4;\n      /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n       return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n       \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n       \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n       a, b, c, d, e), scope);\r\n       });*/\n\n      p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\n\n      q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString(); //a, b, c, d, e\n\n      D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\n\n      D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\n\n      Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\n\n      S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\n\n      x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\n\n      return [x1, x2, x3, x4];\n    },\n\n    /**\r\n     * Breaks the equation up in its factors and tries to solve the smaller parts\r\n     * @param {Symbol} symbol\r\n     * @param {String} solve_for\r\n     * @returns {Array}\r\n     */\n    divideAndConquer: function divideAndConquer(symbol, solve_for) {\n      var sols = []; //see if we can solve the factors\n\n      var factors = core.Algebra.Factor.factor(symbol);\n\n      if (factors.group === CB) {\n        factors.each(function (x) {\n          x = Symbol.unwrapPARENS(x);\n          sols = sols.concat(_solve(x, solve_for));\n        });\n      }\n\n      return sols;\n    },\n\n    /**\r\n     * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n     * @param {Symbol} eq\r\n     * @param {String} solve_for\r\n     * @returns {Array}\r\n     */\n    csolve: function csolve(eq, solve_for) {\n      return core.Utils.block('IGNORE_E', function () {\n        var f, p, pn, n, pf, r, theta, sr, sp, roots;\n        roots = [];\n        f = core.Utils.decompose_fn(eq, solve_for, true);\n\n        if (f.x.group === S) {\n          p = _.parse(f.x.power);\n          pn = Number(p);\n          n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\n          pf = Symbol.toPolarFormArray(n);\n          r = pf[0];\n          theta = pf[1];\n          sr = r.toString();\n          sp = p.toString();\n          var k, root, str;\n\n          for (var i = 0; i < pn; i++) {\n            k = i;\n            str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\n            root = _.parse(str);\n            roots.push(root);\n          }\n        }\n\n        return roots;\n      }, true);\n    },\n\n    /**\r\n     * Generates starting points for the Newton solver given an expression at zero.\r\n     * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n     * Builds on the fact that if the sign changes over an interval then a zero\r\n     * must exist on that interval\r\n     * @param {Symbol} symbol\r\n     * @param {Number} step\r\n     * @param {Array} points\r\n     * @returns {Array}\r\n     */\n    getPoints: function getPoints(symbol, step, points) {\n      step = step || 0.01;\n      points = points || [];\n      var f = build(symbol);\n      var x0 = 0;\n      var start = Math.round(x0),\n          last = f(start),\n          last_sign = last / Math.abs(last),\n          rside = core.Settings.ROOTS_PER_SIDE,\n          // the max number of roots on right side\n      lside = rside; // the max number of roots on left side\n      // check around the starting point\n\n      points.push(Math.floor(start / 2)); //half way from zero might be a good start\n\n      points.push(Math.abs(start)); //|f(0)| could be a good start\n\n      points.push(start); //|f(0)| could be a good start\n      //adjust for log. A good starting point to include for log is 0.1\n\n      symbol.each(function (x) {\n        if (x.containsFunction(core.Settings.LOG)) points.push(0.1);\n      });\n      var left = range(-core.Settings.SOLVE_RADIUS, start, step),\n          right = range(start, core.Settings.SOLVE_RADIUS, step);\n\n      var test_side = function test_side(side, num_roots) {\n        var xi, val, sign;\n        var hits = [];\n\n        for (var i = 0, l = side.length; i < l; i++) {\n          xi = side[i]; //the point being evaluated\n\n          val = f(xi);\n          sign = val / Math.abs(val); //Don't add non-numeric values\n\n          if (isNaN(val) || !isFinite(val) || hits.length > num_roots) {\n            continue;\n          } //compare the signs. The have to be different if they cross a zero\n\n\n          if (sign !== last_sign) {\n            hits.push(xi); //take note of the possible zero location\n          }\n\n          last_sign = sign;\n        }\n\n        points = points.concat(hits);\n      };\n\n      test_side(left, lside);\n      test_side(right, rside);\n      return points;\n    },\n    Newton: function Newton(point, f, fp) {\n      var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\n          iter = 0; //first try the point itself. If it's zero viola. We're done\n\n      var x0 = point,\n          x;\n\n      do {\n        var fx0 = f(x0); //store the result of the function\n        //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\n\n        if (x0 === 0 && fx0 === 0) {\n          x = 0;\n          break;\n        }\n\n        iter++;\n        if (iter > maxiter) return; //naximum iterations reached\n\n        x = x0 - fx0 / fp(x0);\n        var e = Math.abs(x - x0);\n        x0 = x;\n      } while (e > Settings.NEWTON_EPSILON); //check if the number is indeed zero. 1e-13 seems to give the most accurate results\n\n\n      if (Math.abs(f(x)) <= 1e-13) return x;\n    },\n    rewrite: function rewrite(rhs, lhs, for_variable) {\n      lhs = lhs || new Symbol(0);\n\n      if (rhs.isComposite() && rhs.isLinear()) {\n        //try to isolate the square root\n        //container for the square roots\n        var sqrts = []; //all else\n\n        var rem = [];\n        rhs.each(function (x) {\n          x = x.clone();\n\n          if (x.fname === 'sqrt' && x.contains(for_variable)) {\n            sqrts.push(x);\n          } else {\n            rem.push(x);\n          }\n        }, true);\n\n        if (sqrts.length === 1) {\n          //move the remainder to the RHS\n          lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2))); //square both sides\n\n          rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\n        }\n      } else {\n        rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\n      }\n\n      var c = 0,\n          //a counter to see if we have all terms with the variable\n      l = rhs.length; //try to rewrite the whole thing\n\n      if (rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\n        rhs.distributeMultiplier();\n        var t = new Symbol(0); //first bring all the terms containing the variable to the lhs\n\n        rhs.each(function (x) {\n          if (x.contains(for_variable)) {\n            c++;\n            t = _.add(t, x.clone());\n          } else lhs = _.subtract(lhs, x.clone());\n        });\n        rhs = t; //if not all the terms contain the variable so it's in the form\n        //a*x^2+x\n\n        if (c !== l) {\n          return __.rewrite(rhs, lhs, for_variable);\n        } else {\n          return [rhs, lhs];\n        }\n      } else if (rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\n        if (rhs.multiplier.lessThan(0)) {\n          rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\n          lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\n        }\n\n        if (lhs.equals(0)) return new Symbol(0);else {\n          var t = new Symbol(1);\n          rhs.each(function (x) {\n            if (x.contains(for_variable)) t = _.multiply(t, x.clone());else lhs = _.divide(lhs, x.clone());\n          });\n          rhs = t;\n          return __.rewrite(rhs, lhs, for_variable);\n        }\n      } else if (!rhs.isLinear() && rhs.contains(for_variable)) {\n        var p = _.parse(rhs.power.clone().invert());\n\n        rhs = _.pow(rhs, p.clone());\n        lhs = _.pow(_.expand(lhs), p.clone());\n        return __.rewrite(rhs, lhs, for_variable);\n      } else if (rhs.group === FN || rhs.group === S || rhs.group === PL) {\n        return [rhs, lhs];\n      }\n    },\n    sqrtSolve: function sqrtSolve(symbol, v) {\n      var sqrts = new Symbol(0);\n      var rem = new Symbol(0);\n\n      if (symbol.isComposite()) {\n        symbol.each(function (x) {\n          if (x.fname === 'sqrt' && x.contains(v)) {\n            sqrts = _.add(sqrts, x.clone());\n          } else {\n            rem = _.add(rem, x.clone());\n          }\n        }); //quick and dirty ATM\n\n        if (!sqrts.equals(0)) {\n          var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2))))); //square both sides\n\n\n          var solutions = _solve(t, v); //test the points. The dumb way of getting the answers\n\n\n          solutions = solutions.filter(function (e) {\n            if (e.isImaginary()) return e;\n            var subs = {};\n            subs[v] = e;\n            var point = evaluate(symbol, subs);\n            if (point.equals(0)) return e;\n          });\n          return solutions;\n        }\n      }\n    }\n  };\n  /*\r\n   * \r\n   * @param {String[]|String|Equation} eqns\r\n   * @param {type} solve_for\r\n   * @returns {Array}\r\n   */\n\n\n  var _solve = function _solve(eqns, solve_for, solutions, depth) {\n    depth = depth || 0;\n\n    if (depth++ > Settings.MAX_SOLVE_DEPTH) {\n      return solutions;\n    } //make preparations if it's an Equation\n\n\n    if (eqns instanceof Equation) {\n      //if it's zero then we're done\n      if (eqns.isZero()) return [new Symbol(0)]; //if the lhs = x then we're done\n\n      if (eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\n        return [eqns.RHS];\n      } //if the rhs = x then we're done\n\n\n      if (eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\n        return [eqns.LHS];\n      }\n    } //unwrap the vector since what we want are the elements\n\n\n    if (eqns instanceof core.Vector) eqns = eqns.elements;\n    solve_for = solve_for || 'x'; //assumes x by default\n    //If it's an array then solve it as a system of equations\n\n    if (isArray(eqns)) {\n      return __.solveSystem.apply(undefined, arguments);\n    } //parse out functions. Fix for issue #300\n    //eqns = core.Utils.evaluate(eqns);\n\n\n    solutions = solutions || []; //mark existing solutions as not to have duplicates\n\n    var existing = {}; //Is usued to add solutions to set. \n    //TODO: Set is now implemented and should be utilized\n\n    var add_to_result = function add_to_result(r, has_trig) {\n      var r_is_symbol = isSymbol(r);\n      if (r === undefined || typeof r === 'number' && isNaN(r)) return;\n\n      if (isArray(r)) {\n        r.map(function (sol) {\n          add_to_result(sol);\n        });\n      } else {\n        if (r.valueOf() !== 'null') {\n          if (!r_is_symbol) r = _.parse(r); //try to convert the number to multiples of pi\n\n          if (core.Settings.make_pi_conversions && has_trig) {\n            var temp = _.divide(r.clone(), new Symbol(Math.PI)),\n                m = temp.multiplier,\n                a = Math.abs(m.num),\n                b = Math.abs(m.den);\n\n            if (a < 10 && b < 10) r = _.multiply(temp, new Symbol('pi'));\n          } //convert to a string so we can mark it as a known solution\n\n\n          var r_str = r.toString();\n          if (!existing[r_str]) solutions.push(r);\n          /*NO*/\n          //mark the answer as seen\n\n          existing[r_str] = true;\n        }\n      }\n    }; //maybe we get lucky\n\n\n    if (eqns.group === S && eqns.contains(solve_for)) {\n      add_to_result(new Symbol(0));\n      return solutions;\n    }\n\n    if (eqns.group === CB) {\n      var sf = String(solve_for); //everything else belongs to the coeff\n      //get the denominator and make sure it doesn't have x since we don't know how to solve for those\n\n      eqns.each(function (x) {\n        if (x.contains(sf)) _solve(x, solve_for, solutions);\n      });\n      return solutions;\n    }\n\n    if (eqns.group === FN && eqns.fname === 'sqrt') {\n      eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\n    } //pass in false to not expand equations such as (x+y)^5.\n    //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\n\n\n    var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\n        vars = core.Utils.variables(eq),\n        //get a list of all the variables\n    numvars = vars.length; //how many variables are we dealing with\n    //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\n\n    if (core.Utils.isInt(eq.power) && eq.power > 0) {\n      eq = _.parse(eq).toLinear();\n    } //if we're dealing with a single variable then we first check if it's a \n    //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \n    //Don't waste time\n\n\n    if (eq.group === S || eq.group === CB && eq.contains(solve_for)) return [new Symbol(0)]; //force to polynomial. We go through each and then we look at what it would \n    //take for its power to be an integer\n    //if the power is a fractional we divide by the fractional power\n\n    var fractionals = {},\n        cfact;\n\n    var correct_denom = function correct_denom(symbol) {\n      symbol = _.expand(symbol);\n      var original = symbol.clone(); //preserve the original\n\n      if (symbol.symbols) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x]; //get the denominator of the sub-symbol\n\n          var den = sym.getDenom();\n\n          if (!den.isConstant(true) && symbol.isComposite()) {\n            var t = new Symbol(0);\n            symbol.each(function (e) {\n              t = _.add(t, _.multiply(e, den.clone()));\n            });\n            return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\n          }\n\n          var parts = explode(sym, solve_for);\n          var is_sqrt = parts[1].fname === core.Settings.SQRT;\n          var v = Symbol.unwrapSQRT(parts[1]);\n          var p = v.power.clone(); //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\n          //this needs to be terminated if p = 1/2\n\n          if (!isSymbol(p) && !p.equals(1 / 2)) {\n            if (p.den.gt(1)) {\n              if (is_sqrt) {\n                symbol = _.subtract(symbol, sym.clone());\n                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\n                return correct_denom(symbol);\n              }\n\n              var c = fractionals[p.den];\n              fractionals[p.den] = c ? c++ : 1;\n            } else if (p.sign() === -1) {\n              var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\n              //unwrap the symbol's denoniator\n\n\n              symbol.each(function (y, index) {\n                if (y.contains(solve_for)) {\n                  symbol.symbols[index] = _.multiply(y, factor.clone());\n                }\n              });\n              fractionals = {};\n              return correct_denom(_.parse(symbol));\n            } else if (sym.group === PL) {\n              var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\n\n              if (min_p < 0) {\n                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\n\n                var corrected = new Symbol(0);\n                original.each(function (x) {\n                  corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\n                }, true);\n                return corrected;\n              }\n            }\n          }\n        }\n      }\n\n      return symbol;\n    }; //separate the equation\n\n\n    var separate = function separate(eq) {\n      var lhs = new Symbol(0),\n          rhs = new Symbol(0);\n      eq.each(function (x) {\n        if (x.contains(solve_for, true)) lhs = _.add(lhs, x.clone());else rhs = _.subtract(rhs, x.clone());\n      });\n      return [lhs, rhs];\n    };\n\n    __.inverseFunctionSolve = function (name, lhs, rhs) {\n      //ax+b comes back as [a, x, ax, b];\n      var parts = explode(lhs.args[0], solve_for); //check if x is by itself\n\n      var x = parts[1];\n\n      if (x.group === S) {\n        return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\n      }\n    }; //first remove any denominators\n\n\n    eq = correct_denom(eq);\n    if (eq.equals(0)) return [eq]; //correct fractionals. I can only handle one type right now\n\n    var fkeys = core.Utils.keys(fractionals);\n\n    if (fkeys.length === 1) {\n      //make a note of the factor\n      cfact = fkeys[0];\n      eq.each(function (x, index) {\n        if (x.contains(solve_for)) {\n          var parts = explode(x, solve_for);\n          var v = parts[1];\n          var p = v.power;\n\n          if (p.den.gt(1)) {\n            v.power = p.multiply(new core.Frac(cfact));\n            eq.symbols[index] = _.multiply(v, parts[0]);\n          }\n        }\n      });\n      eq = _.parse(eq);\n    } //try for nested sqrts as per issue #486\n\n\n    add_to_result(__.sqrtSolve(eq, solve_for)); //polynomial single variable\n\n    if (numvars === 1) {\n      if (eq.isPoly(true)) {\n        //try to factor and solve\n        var factors = new core.Algebra.Classes.Factors();\n        core.Algebra.Factor.factor(eq, factors); //if the equation has more than one symbolic factor then solve those individually\n\n        if (factors.getNumberSymbolics() > 1) {\n          for (var x in factors.factors) {\n            add_to_result(_solve(factors.factors[x], solve_for));\n          }\n        } else {\n          var coeffs = core.Utils.getCoeffs(eq, solve_for),\n              deg = coeffs.length - 1,\n              was_calculated = false;\n\n          if (vars[0] === solve_for) {\n            //check to see if all the coefficients are constant\n            if (checkAll(coeffs, function (x) {\n              return x.group !== core.groups.N;\n            })) {\n              var roots = core.Algebra.proots(eq); //if all the roots are integers then return those\n\n              if (checkAll(roots, function (x) {\n                return !core.Utils.isInt(x);\n              })) {\n                //roots have been calculates\n                was_calculated = true;\n                roots.map(function (x) {\n                  add_to_result(new Symbol(x));\n                });\n              }\n            }\n\n            if (!was_calculated) {\n              eqns = _.parse(eqns);\n              if (eqns instanceof core.Equation) eqns = eqns.toLHS(); //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\n\n              if (deg === 1) add_to_result(_.divide(coeffs[0], coeffs[1].negate()));else if (deg === 2) {\n                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\n              } else if (deg === 3) {\n                var solutions = []; //set to blank\n                //first try to factor and solve\n\n                var factored = core.Algebra.Factor.factor(eqns); //if it was successfully factored\n\n                var solutions = !factored.equals(eqns) ? _solve(factored, solve_for) : [];\n                if (solutions.length > 0) add_to_result(solutions);else add_to_result(__.cubic.apply(undefined, coeffs));\n              } else {\n                /*\r\n                 var sym_roots = csolve(eq, solve_for); \r\n                 if(sym_roots.length === 0)\r\n                 sym_roots = divnconsolve(eq, solve_for);\r\n                 if(sym_roots.length > 0) \r\n                 add_to_result(sym_roots);\r\n                 else\r\n                 */\n                _A.proots(eq).map(add_to_result);\n              }\n            }\n          }\n        }\n      } else {\n        try {\n          //Attempt Newton\n          //since it's not a polynomial then we'll try to look for a solution using Newton's method\n          //this is not a very broad search but takes the positions that something is better than nothing\n          var has_trig = eq.hasTrig(); // we get all the points where a possible zero might exist.\n\n          var points1 = __.getPoints(eq, 0.1);\n\n          var points2 = __.getPoints(eq, 0.05);\n\n          var points3 = __.getPoints(eq, 0.01);\n\n          var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\n            return a - b;\n          }); //generate slices\n          //points = core.Utils.arrayAddSlices(points, Settings.NEWTON_SLICES); \n          //compile the function and the derivative of the function\n\n          var f = build(eq.clone());\n\n          var d = _C.diff(eq.clone());\n\n          var fp = build(d);\n\n          for (var i = 0; i < points.length; i++) {\n            var point = points[i];\n            add_to_result(__.Newton(point, f, fp), has_trig);\n          }\n\n          solutions.sort();\n        } catch (e) {\n          console.log(e);\n        }\n      }\n    } else {\n      //The idea here is to go through the equation and collect the coefficients\n      //place them in an array and call the quad or cubic function to get the results\n      if (!eq.hasFunc(solve_for) && eq.isComposite()) {\n        try {\n          var factored = core.Algebra.Factor.factor(eq.clone());\n\n          if (factored.group === CB) {\n            factored.each(function (x) {\n              add_to_result(_solve(x, solve_for));\n            });\n          } else {\n            var coeffs = core.Utils.getCoeffs(eq, solve_for);\n            var l = coeffs.length,\n                deg = l - 1; //the degree of the polynomial\n            //get the denominator and make sure it doesn't have x\n            //handle the problem based on the degree\n\n            switch (deg) {\n              case 0:\n                var separated = separate(eq);\n                var lhs = separated[0],\n                    rhs = separated[1];\n\n                if (lhs.group === core.groups.EX) {\n                  add_to_result(_.parse(core.Utils.format(core.Settings.LOG + '(({0})/({2}))/' + core.Settings.LOG + '({1})', rhs, lhs.value, lhs.multiplier)));\n                }\n\n                break;\n\n              case 1:\n                //nothing to do but to return the quotient of the constant and the LT\n                //e.g. 2*x-1\n                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\n                break;\n\n              case 2:\n                add_to_result(__.quad.apply(undefined, coeffs));\n                break;\n\n              case 3:\n                add_to_result(__.cubic.apply(undefined, coeffs));\n                break;\n\n              case 4:\n                add_to_result(__.quartic.apply(undefined, coeffs));\n                break;\n\n              default:\n                add_to_result(__.csolve(eq, solve_for));\n                if (solutions.length === 0) add_to_result(__.divideAndConquer(eq, solve_for));\n            }\n\n            if (solutions.length === 0) {\n              //try factoring\n              add_to_result(_solve(factored, solve_for, solutions, depth));\n            }\n          }\n        } catch (e) {\n          /*something went wrong. EXITING*/\n          ;\n        }\n      } else {\n        try {\n          var rw = __.rewrite(eq, null, solve_for);\n\n          var lhs = rw[0];\n          var rhs = rw[1];\n\n          if (lhs.group === FN) {\n            if (lhs.fname === 'abs') {\n              add_to_result([rhs.clone(), rhs.negate()]);\n            } else if (lhs.fname === 'sin') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\n            } else if (lhs.fname === 'cos') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\n            } else if (lhs.fname === 'tan') {\n              //asin\n              add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\n            } else if (lhs.fname === core.Settings.LOG) {\n              //ax+b comes back as [a, x, ax, b];\n              var parts = explode(lhs.args[0], solve_for); //check if x is by itself\n\n              var x = parts[1];\n\n              if (x.group === S) {\n                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\n                var eq = new Equation(x, rhs).toLHS();\n                add_to_result(_solve(eq, solve_for));\n              }\n            } else add_to_result(_.subtract(lhs, rhs));\n          } else {\n            var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\n\n            if (neq.equals(eq)) throw new Error('Stopping. No stop condition exists');\n            add_to_result(_solve(neq, solve_for));\n          }\n        } catch (error) {\n          //Let's try this another way\n          try {\n            //1. if the symbol is in the form a*b*c*... then the solution is zero if \n            //either a or b or c is zero.\n            if (eq.group === CB) add_to_result(0);else if (eq.group === CP) {\n              var separated = separate(eq);\n              var lhs = separated[0],\n                  rhs = separated[1]; //reduce the equation\n\n              if (lhs.group === core.groups.EX && lhs.value === solve_for) {\n                //change the base of both sides\n                var p = lhs.power.clone().invert();\n                add_to_result(_.pow(rhs, p));\n              }\n            }\n          } catch (error) {\n            ;\n          }\n        }\n      }\n    }\n\n    if (cfact) {\n      solutions = solutions.map(function (x) {\n        return _.pow(x, new Symbol(cfact));\n      });\n    }\n\n    return solutions;\n  }; //Register the functions for external use\n\n\n  nerdamer.register([{\n    name: 'solveEquations',\n    parent: 'nerdamer',\n    numargs: -1,\n    visible: true,\n    build: function build() {\n      return _solve; //comment out to return a vector\n\n      /*\r\n       return function() {\r\n       return core.Utils.convertToVector(solve.apply(null, arguments));\r\n       };\r\n       */\n    }\n  }, {\n    name: 'solve',\n    parent: 'Solve',\n    numargs: 2,\n    visible: true,\n    build: function build() {\n      return core.Solve.solve;\n    }\n  },\n  /*\r\n   {\r\n   name: 'polysolve',\r\n   parent: 'Solve',\r\n   visible: true,\r\n   build: function(){ return polysolve; }\r\n   },\r\n   */\n  {\n    name: 'setEquation',\n    parent: 'Solve',\n    visible: true,\n    build: function build() {\n      return setEq;\n    }\n  }]);\n  nerdamer.api();\n})();","require(\"core-js/modules/es6.array.is-array\");\n\nrequire(\"core-js/modules/es6.array.reduce\");\n\nrequire(\"core-js/modules/es6.string.sub\");\n\nrequire(\"core-js/modules/es6.regexp.search\");\n\nrequire(\"core-js/modules/es6.array.filter\");\n\nrequire(\"core-js/modules/es6.regexp.replace\");\n\nrequire(\"core-js/modules/es6.array.some\");\n\nrequire(\"core-js/modules/es6.array.map\");\n\nrequire(\"core-js/modules/es7.object.values\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.array.index-of\");\n\nrequire(\"core-js/modules/es6.string.trim\");\n\nrequire(\"core-js/modules/es6.number.constructor\");\n\nrequire(\"core-js/modules/es6.math.sign\");\n\nrequire(\"core-js/modules/es6.array.fill\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\n/*\r\n* Author : Martin Donk\r\n* Website : http://www.nerdamer.com\r\n* Email : martin.r.donk@gmail.com\r\n* License : MIT\r\n* Source : https://github.com/jiggzson/nerdamer\r\n*/\n\n/* global module */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n}\n\n(function () {\n  \"use strict\";\n  /*shortcuts*/\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      N = core.groups.N,\n      P = core.groups.P,\n      S = core.groups.S,\n      EX = core.groups.EX,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      keys = core.Utils.keys,\n      variables = core.Utils.variables,\n      format = core.Utils.format,\n      round = core.Utils.round,\n      Frac = core.Frac,\n      isInt = core.Utils.isInt,\n      Symbol = core.Symbol,\n      CONST_HASH = core.Settings.CONST_HASH,\n      math = core.Utils.importFunctions(),\n      evaluate = core.Utils.evaluate; //*************** CLASSES ***************//\n\n  /**\r\n  * Converts a symbol into an equivalent polynomial arrays of \r\n  * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n  * Univariate polymials only. \r\n  * @param {Symbol|Number} symbol\r\n  * @param {String} variable The variable name of the polynomial\r\n  * @param {int} order\r\n  */\n\n  function Polynomial(symbol, variable, order) {\n    if (core.Utils.isSymbol(symbol)) {\n      this.parse(symbol);\n      this.variable = this.variable || variable;\n    } else if (!isNaN(symbol)) {\n      order = order || 0;\n      if (variable === undefined) throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\n      this.coeffs = [];\n      this.coeffs[order] = symbol;\n      this.fill(symbol);\n    } else if (typeof symbol === 'string') {\n      this.parse(_.parse(symbol));\n    }\n  }\n  /**\r\n   * Creates a Polynomial given an array of coefficients\r\n   * @param {int[]} arr\r\n   * @param {String} variable\r\n   * @returns {Polynomial}\r\n   */\n\n\n  Polynomial.fromArray = function (arr, variable) {\n    if (typeof variable === 'undefined') throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\n    var p = new Polynomial();\n    p.coeffs = arr;\n    p.variable = variable;\n    return p;\n  };\n\n  Polynomial.fit = function (c1, c2, n, base, p, variable) {\n    //after having looped through and mod 10 the number to get the matching factor\n    var terms = new Array(p + 1),\n        t = n - c2;\n    terms[0] = c2; //the constants is assumed to be correct\n    //constant for x^p is also assumed know so add\n\n    terms[p] = c1;\n    t -= c1 * Math.pow(base, p); //start fitting\n\n    for (var i = p - 1; i > 0; i--) {\n      var b = Math.pow(base, i),\n          //we want as many wholes as possible\n      q = t / b,\n          sign = Math.sign(q);\n      var c = sign * Math.floor(Math.abs(q));\n      t -= c * b;\n      terms[i] = c;\n    }\n\n    if (t !== 0) return null;\n\n    for (var i = 0; i < terms.length; i++) {\n      terms[i] = new Frac(terms[i]);\n    }\n\n    return Polynomial.fromArray(terms, variable);\n  };\n\n  Polynomial.prototype = {\n    /**\r\n     * Converts Symbol to Polynomial\r\n     * @param {Symbol} symbol\r\n     * @param {Array} c - a collector array\r\n     * @returns {Polynomial}\r\n     */\n    parse: function parse(symbol, c) {\n      this.variable = variables(symbol)[0];\n      if (!symbol.isPoly()) throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\n      c = c || [];\n      if (!symbol.power.absEquals(1)) symbol = _.expand(symbol);\n\n      if (symbol.group === core.groups.N) {\n        c[0] = symbol.multiplier;\n      } else if (symbol.group === core.groups.S) {\n        c[symbol.power.toDecimal()] = symbol.multiplier;\n      } else {\n        for (var x in symbol.symbols) {\n          var sub = symbol.symbols[x],\n              p = sub.power;\n          if (core.Utils.isSymbol(p)) throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\n          p = sub.group === N ? 0 : p.toDecimal();\n\n          if (sub.symbols) {\n            this.parse(sub, c);\n          } else {\n            c[p] = sub.multiplier;\n          }\n        }\n      }\n\n      this.coeffs = c;\n      this.fill();\n    },\n\n    /**\r\n    * Fills in the holes in a polynomial with zeroes\r\n    * @param {Number} x - The number to fill the holes with\r\n    */\n    fill: function fill(x) {\n      x = Number(x) || 0;\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        if (this.coeffs[i] === undefined) {\n          this.coeffs[i] = new Frac(x);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n    * Removes higher order zeros or a specific coefficient\r\n    * @returns {Array}\r\n    */\n    trim: function trim() {\n      var l = this.coeffs.length;\n\n      while (l--) {\n        var c = this.coeffs[l];\n        var equalsZero = c.equals(0);\n\n        if (c && equalsZero) {\n          if (l === 0) break;\n          this.coeffs.pop();\n        } else break;\n      }\n\n      return this;\n    },\n\n    /*\r\n     * Returns polynomial mod p **currently fails**\r\n     * @param {Number} p\r\n     * @returns {Polynomial}\r\n     */\n    modP: function modP(p) {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = this.coeffs[i];\n\n        if (c < 0) {\n          //go borrow\n          var b; //a coefficient > 0\n\n          for (var j = i; j < l; j++) {\n            //starting from where we left off\n            if (this.coeffs[j] > 0) {\n              b = this.coeffs[j];\n              break;\n            }\n          }\n\n          if (b) {\n            //if such a coefficient exists\n            for (j; j > i; j--) {\n              //go down the line and adjust using p\n              this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\n              this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\n            }\n\n            c = this.coeffs[i]; //reset c\n          }\n        }\n\n        var d = c.mod(p);\n        var w = c.subtract(d).divide(p);\n\n        if (!w.equals(0)) {\n          var up_one = i + 1;\n          var next = this.coeffs[up_one] || new Frac(0);\n          next = next.add(w);\n          this.coeffs[up_one] = new Frac(next);\n          this.coeffs[i] = new Frac(d);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n    * Adds together 2 polynomials\r\n    * @param {Polynomial} poly\r\n    */\n    add: function add(poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.add(b);\n      }\n\n      return this;\n    },\n\n    /**\r\n    * Adds together 2 polynomials\r\n    * @param {Polynomial} poly\r\n    */\n    subtract: function subtract(poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.subtract(b);\n      }\n\n      return this;\n    },\n    divide: function divide(poly) {\n      var variable = this.variable,\n          dividend = core.Utils.arrayClone(this.coeffs),\n          divisor = core.Utils.arrayClone(poly.coeffs),\n          n = dividend.length,\n          mp = divisor.length - 1,\n          quotient = []; //loop through the dividend\n\n      for (var i = 0; i < n; i++) {\n        var p = n - (i + 1); //get the difference of the powers\n\n        var d = p - mp; //get the quotient of the coefficients\n\n        var q = dividend[p].divide(divisor[mp]);\n        if (d < 0) break; //the divisor is not greater than the dividend\n        //place it in the quotient\n\n        quotient[d] = q;\n\n        for (var j = 0; j <= mp; j++) {\n          //reduce the dividend\n          dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));\n        }\n      } //clean up\n\n\n      var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(),\n          //pass in x for safety\n      p2 = Polynomial.fromArray(quotient, variable || 'x');\n      return [p2, p1];\n    },\n    multiply: function multiply(poly) {\n      var l1 = this.coeffs.length,\n          l2 = poly.coeffs.length,\n          c = []; //array to be returned\n\n      for (var i = 0; i < l1; i++) {\n        var x1 = this.coeffs[i];\n\n        for (var j = 0; j < l2; j++) {\n          var k = i + j,\n              //add the powers together\n          x2 = poly.coeffs[j],\n              e = c[k] || new Frac(0); //get the existing term from the new array\n\n          c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\n        }\n      }\n\n      this.coeffs = c;\n      return this;\n    },\n\n    /**\r\n     * Checks if a polynomial is zero\r\n     * @returns {Boolean}\r\n     */\n    isZero: function isZero() {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var e = this.coeffs[i];\n        if (!e.equals(0)) return false;\n      }\n\n      return true;\n    },\n\n    /** \r\n     * Substitutes in a number n into the polynomial p(n)\r\n     * @param {Number} n\r\n     * @returns {Frac}\r\n     */\n    sub: function sub(n) {\n      var sum = new Frac(0),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var t = this.coeffs[i];\n        if (!t.equals(0)) sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\n      }\n\n      return sum;\n    },\n\n    /**\r\n     * Returns a clone of the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    clone: function clone() {\n      var p = new Polynomial();\n      p.coeffs = this.coeffs;\n      p.variable = this.variable;\n      return p;\n    },\n\n    /**\r\n     * Gets the degree of the polynomial\r\n     * @returns {Number}\r\n     */\n    deg: function deg() {\n      this.trim();\n      return this.coeffs.length - 1;\n    },\n\n    /**\r\n     * Returns a lead coefficient\r\n     * @returns {Frac}\r\n     */\n    lc: function lc() {\n      return this.coeffs[this.deg()].clone();\n    },\n\n    /**\r\n     * Converts polynomial into a monic polynomial\r\n     * @returns {Polynomial}\r\n     */\n    monic: function monic() {\n      var lc = this.lc(),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        this.coeffs[i] = this.coeffs[i].divide(lc);\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Returns the GCD of two polynomials\r\n     * @param {Polynomial} poly\r\n     * @returns {Polynomial}\r\n     */\n    gcd: function gcd(poly) {\n      //get the maximum power of each\n      var mp1 = this.coeffs.length - 1,\n          mp2 = poly.coeffs.length - 1,\n          T; //swap so we always have the greater power first\n\n      if (mp1 < mp2) {\n        return poly.gcd(this);\n      }\n\n      var a = this;\n\n      while (!poly.isZero()) {\n        var t = poly.clone();\n        a = a.clone();\n        T = a.divide(t);\n        poly = T[1];\n        a = t;\n      }\n\n      var gcd = core.Math2.QGCD.apply(null, a.coeffs);\n\n      if (!gcd.equals(1)) {\n        var l = a.coeffs.length;\n\n        for (var i = 0; i < l; i++) {\n          a.coeffs[i] = a.coeffs[i].divide(gcd);\n        }\n      }\n\n      return a;\n    },\n\n    /**\r\n     * Differentiates the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    diff: function diff() {\n      var new_array = [],\n          l = this.coeffs.length;\n\n      for (var i = 1; i < l; i++) {\n        new_array.push(this.coeffs[i].multiply(new Frac(i)));\n      }\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Integrates the polynomial\r\n     * @returns {Polynomial} \r\n     */\n    integrate: function integrate() {\n      var new_array = [0],\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = new Frac(i + 1);\n        new_array[c] = this.coeffs[i].divide(c);\n      }\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Returns the Greatest common factor of the polynomial\r\n     * @param {bool} toPolynomial - true if a polynomial is wanted\r\n     * @returns {Frac|Polynomial}\r\n     */\n    gcf: function gcf(toPolynomial) {\n      //get the first nozero coefficient and returns its power\n      var fnz = function fnz(a) {\n        for (var i = 0; i < a.length; i++) {\n          if (!a[i].equals(0)) return i;\n        }\n      },\n          ca = [];\n\n      for (var i = 0; i < this.coeffs.length; i++) {\n        var c = this.coeffs[i];\n        if (!c.equals(0) && ca.indexOf(c) === -1) ca.push(c);\n      }\n\n      var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\n\n      if (toPolynomial) {\n        var parr = [];\n        parr[p[1] - 1] = p[0];\n        p = Polynomial.fromArray(parr, this.variable).fill();\n      }\n\n      return p;\n    },\n\n    /**\r\n     * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n     * @param {bool} incl_img - Include imaginary numbers \r\n     */\n    quad: function quad(incl_img) {\n      var roots = [];\n      if (this.coeffs.length > 3) throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\n      if (this.coeffs.length === 0) throw new Error('Polynomial array has no terms');\n      var a = this.coeffs[2] || 0,\n          b = this.coeffs[1] || 0,\n          c = this.coeffs[0];\n      var dsc = b * b - 4 * a * c;\n      if (dsc < 0 && !incl_img) return roots;else {\n        roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\n        roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\n      }\n      return roots;\n    },\n\n    /**\r\n     * Makes polynomial square free\r\n     * @returns {Array}\r\n     */\n    squareFree: function squareFree() {\n      var a = this.clone(),\n          i = 1,\n          b = a.clone().diff(),\n          c = a.clone().gcd(b),\n          w = a.divide(c)[0];\n      var output = Polynomial.fromArray([new Frac(1)], a.variable);\n\n      while (!c.equalsNumber(1)) {\n        var y = w.gcd(c);\n        var z = w.divide(y)[0]; //one of the factors may have shown up since it's square but smaller than the \n        //one where finding\n\n        if (!z.equalsNumber(1) && i > 1) {\n          var t = z.clone();\n\n          for (var j = 1; j < i; j++) {\n            t.multiply(z.clone());\n          }\n\n          z = t;\n        }\n\n        output = output.multiply(z);\n        i++;\n        w = y;\n        c = c.divide(y)[0];\n      }\n\n      return [output, w, i];\n    },\n\n    /**\r\n     * Converts polynomial to Symbol\r\n     * @returns {Symbol}\r\n     */\n    toSymbol: function toSymbol() {\n      var l = this.coeffs.length,\n          variable = this.variable;\n      if (l === 0) return new core.Symbol(0);\n      var end = l - 1,\n          str = '';\n\n      for (var i = 0; i < l; i++) {\n        //place the plus sign for all but the last one\n        var plus = i === end ? '' : '+',\n            e = this.coeffs[i];\n        if (!e.equals(0)) str += e + '*' + variable + '^' + i + plus;\n      }\n\n      return _.parse(str);\n    },\n\n    /**\r\n     * Checks if polynomial is equal to a number\r\n     * @param {Number} x\r\n     * @returns {Boolean}\r\n     */\n    equalsNumber: function equalsNumber(x) {\n      this.trim();\n      return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\n    },\n    toString: function toString() {\n      return this.toSymbol().toString();\n    }\n  };\n  /**\r\n   * TODO\r\n   * ===================================================================================\r\n   * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n   * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n   * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n   * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n   * ===================================================================================\r\n  * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n  * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n  * so the symbol multiplier carries the coefficients for all contained symbols.\r\n  * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n  * @param {Array} c The coefficient array\r\n  * @param {boolean} with_order \r\n  * @return {Array}\r\n  */\n\n  Symbol.prototype.coeffs = function (c, with_order) {\n    if (with_order && !this.isPoly(true)) _.error('Polynomial expected when requesting coefficients with order');\n    c = c || [];\n    var s = this.clone().distributeMultiplier();\n\n    if (s.isComposite()) {\n      for (var x in s.symbols) {\n        var sub = s.symbols[x];\n\n        if (sub.isComposite()) {\n          sub.clone().distributeMultiplier().coeffs(c, with_order);\n        } else {\n          if (with_order) c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;else {\n            c.push(sub.multiplier);\n          }\n        }\n      }\n    } else {\n      if (with_order) c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;else {\n        if (s.group === CB && s.isImaginary()) {\n          var m = new Symbol(s.multiplier);\n          s.each(function (x) {\n            //add the imaginary part\n            if (x.isConstant(true) || x.imaginary) m = _.multiply(m, x);\n          });\n          c.push(m);\n        } else c.push(s.multiplier);\n      }\n    } //fill the holes\n\n\n    if (with_order) {\n      for (var i = 0; i < c.length; i++) {\n        if (c[i] === undefined) c[i] = new Symbol(0);\n      }\n    }\n\n    return c;\n  };\n\n  Symbol.prototype.tBase = function (map) {\n    if (typeof map === 'undefined') throw new Error('Symbol.tBase requires a map object!');\n    var terms = [];\n    var symbols = this.collectSymbols(null, null, null, true),\n        l = symbols.length;\n\n    for (var i = 0; i < l; i++) {\n      var symbol = symbols[i],\n          g = symbol.group,\n          nterm = new MVTerm(symbol.multiplier, [], map);\n\n      if (g === CB) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x];\n          nterm.terms[map[x]] = sym.power;\n        }\n      } else {\n        nterm.terms[map[symbol.value]] = symbol.power;\n      }\n\n      terms.push(nterm.fill());\n      nterm.updateCount();\n    }\n\n    return terms;\n  };\n\n  Symbol.prototype.altVar = function (x) {\n    var m = this.multiplier.toString(),\n        p = this.power.toString();\n    return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\n  };\n  /**\r\n   * Checks to see if the symbols contain the same variables\r\n   * @param {Symbol} symbol\r\n   * @returns {Boolean}\r\n   */\n\n\n  Symbol.prototype.sameVars = function (symbol) {\n    if (!(this.symbols || this.group === symbol.group)) return false;\n\n    for (var x in this.symbols) {\n      var a = this.symbols[x],\n          b = symbol.symbols[x];\n      if (!b) return false;\n      if (a.value !== b.value) return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Groups the terms in a symbol with respect to a variable\r\n   * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n   * @returns {Factors}\r\n   */\n\n\n  Symbol.prototype.groupTerms = function (x) {\n    x = String(x);\n    var f, p, egrouped;\n    var grouped = [];\n    this.each(function (e) {\n      if (e.group === PL) {\n        egrouped = e.groupTerms(x);\n\n        for (var i = 0; i < egrouped.length; i++) {\n          var el = egrouped[i];\n          if (el) grouped[i] = el;\n        }\n      } else {\n        f = core.Utils.decompose_fn(e, x, true);\n        p = f.x.value === x ? Number(f.x.power) : 0; //check if there's an existing value\n\n        grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\n      }\n    });\n    return grouped;\n  };\n  /**\r\n   * Use this to collect Factors\r\n   * @returns {Symbol[]}\r\n   */\n\n\n  Symbol.prototype.collectFactors = function () {\n    var factors = [];\n    if (this.group === CB) this.each(function (x) {\n      factors.push(x.clone());\n    });else factors.push(this.clone());\n    return factors;\n  };\n  /**\r\n   * A container class for factors\r\n   * @returns {Factors}\r\n   */\n\n\n  function Factors() {\n    this.factors = {};\n    this.length = 0;\n  }\n\n  ;\n\n  Factors.prototype.getNumberSymbolics = function () {\n    var n = 0;\n    this.each(function (x) {\n      if (!x.isConstant(true)) n++;\n    });\n    return n;\n  };\n  /**\r\n   * Adds the factors to the factor object\r\n   * @param {Symbo} s\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.add = function (s) {\n    if (s.equals(0)) return this; //nothing to add\n    //we don't want to carry -1 as a factor. If a factor already exists,\n    //then add the minus one to that factor and return.\n\n    if (s.equals(-1) && this.length > 0) {\n      var fo = core.Utils.firstObject(this.factors, null, true);\n      this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\n      delete this.factors[fo.key];\n      this.length--;\n      return this;\n    }\n\n    if (s.group === CB) {\n      var factors = this;\n      if (!s.multiplier.equals(1)) factors.add(new Symbol(s.multiplier));\n      s.each(function (x) {\n        factors.add(x);\n      });\n    } else {\n      if (this.preAdd) //if a preAdd function was defined call it to do prep\n        s = this.preAdd(s);\n      if (this.pFactor) //if the symbol isn't linear add back the power\n        s = _.pow(s, new Symbol(this.pFactor));\n      var is_constant = s.isConstant();\n      if (is_constant && s.equals(1)) return this; //don't add 1\n\n      var v = is_constant ? s.value : s.text();\n\n      if (v in this.factors) {\n        this.factors[v] = _.multiply(this.factors[v], s); //did the addition cancel out the existing factor? If so remove it and decrement the length\n\n        if (this.factors[v].equals(1)) {\n          delete this.factors[v];\n          this.length--;\n        }\n      } else {\n        this.factors[v] = s;\n        this.length++;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Converts the factor object to a Symbol\r\n   * @returns {Symbol}\r\n   */\n\n\n  Factors.prototype.toSymbol = function () {\n    var factored = new Symbol(1);\n    var factors = Object.values(this.factors).sort(function (a, b) {\n      return a.group > b.group;\n    });\n\n    for (var i = 0, l = factors.length; i < l; i++) {\n      var f = factors[i]; //don't wrap group S or FN\n\n      var factor = f.power.equals(1) && f.fname !== ''\n      /* don't wrap it twice */\n      ? _.symfunction(core.PARENTHESIS, [f]) : f;\n      factored = _.multiply(factored, factor);\n    }\n\n    if (factored.fname === '') factored = Symbol.unwrapPARENS(factored);\n    return factored;\n  };\n  /**\r\n   * Merges 2 factor objects into one\r\n   * @param {Factor} o\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.merge = function (o) {\n    for (var x in o) {\n      if (x in this.factors) this.factors[x] = _.multiply(this.factors[x], o[x]);else this.factors[x] = o[x];\n    }\n\n    return this;\n  };\n  /**\r\n   * The iterator for the factor object\r\n   * @param {Function} f - callback\r\n   * @returns {Factor}\r\n   */\n\n\n  Factors.prototype.each = function (f) {\n    for (var x in this.factors) {\n      var factor = this.factors[x];\n      if (factor.fname === core.PARENTHESIS && factor.isLinear()) factor = factor.args[0];\n      f.call(this, factor, x);\n    }\n\n    return this;\n  };\n  /**\r\n   * Return the number of factors contained in the factor object\r\n   * @returns {int}\r\n   */\n\n\n  Factors.prototype.count = function () {\n    return keys(this.factors).length;\n  };\n  /**\r\n   * Cleans up factors from -1\r\n   * @returns {undefined}\r\n   */\n\n\n  Factors.prototype.clean = function () {\n    try {\n      var h = core.Settings.CONST_HASH;\n\n      if (this.factors[h].lessThan(0)) {\n        if (this.factors[h].equals(-1)) delete this.factors[h];else this.factors[h].negate();\n        this.each(function (x) {\n          x.negate();\n        });\n      }\n    } catch (e) {}\n\n    ;\n  };\n\n  Factors.prototype.toString = function () {\n    return this.toSymbol().toString();\n  }; //a wrapper for performing multivariate division\n\n\n  function MVTerm(coeff, terms, map) {\n    this.terms = terms || [];\n    this.coeff = coeff;\n    this.map = map; //careful! all maps are the same object\n\n    this.sum = new core.Frac(0);\n    this.image = undefined;\n  }\n\n  ;\n\n  MVTerm.prototype.updateCount = function () {\n    this.count = this.count || 0;\n\n    for (var i = 0; i < this.terms.length; i++) {\n      if (!this.terms[i].equals(0)) this.count++;\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.getVars = function () {\n    var vars = [];\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var term = this.terms[i],\n          rev_map = this.getRevMap();\n      if (!term.equals(0)) vars.push(this.rev_map[i]);\n    }\n\n    return vars.join(' ');\n  };\n\n  MVTerm.prototype.len = function () {\n    if (typeof this.count === 'undefined') {\n      this.updateCount();\n    }\n\n    return this.count;\n  };\n\n  MVTerm.prototype.toSymbol = function (rev_map) {\n    rev_map = rev_map || this.getRevMap();\n    var symbol = new Symbol(this.coeff);\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var v = rev_map[i],\n          t = this.terms[i];\n      if (t.equals(0) || v === CONST_HASH) continue;\n      var mapped = new Symbol(v);\n      mapped.power = t;\n      symbol = _.multiply(symbol, mapped);\n    }\n\n    return symbol;\n  };\n\n  MVTerm.prototype.getRevMap = function () {\n    if (this.rev_map) return this.rev_map;\n    var o = {};\n\n    for (var x in this.map) {\n      o[this.map[x]] = x;\n    }\n\n    this.rev_map = o;\n    return o;\n  };\n\n  MVTerm.prototype.generateImage = function () {\n    this.image = this.terms.join(' ');\n    return this;\n  }, MVTerm.prototype.getImg = function () {\n    if (!this.image) this.generateImage();\n    return this.image;\n  }, MVTerm.prototype.fill = function () {\n    var l = this.map.length;\n\n    for (var i = 0; i < l; i++) {\n      if (typeof this.terms[i] === 'undefined') this.terms[i] = new core.Frac(0);else {\n        this.sum = this.sum.add(this.terms[i]);\n      }\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.divide = function (mvterm) {\n    var c = this.coeff.divide(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.multiply = function (mvterm) {\n    var c = this.coeff.multiply(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.isZero = function () {\n    return this.coeff.equals(0);\n  };\n\n  MVTerm.prototype.toString = function () {\n    return '{ coeff: ' + this.coeff.toString() + ', terms: [' + this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\n  };\n\n  core.Utils.toMapObj = function (arr) {\n    var c = 0,\n        o = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      var v = arr[i];\n\n      if (typeof o[v] === 'undefined') {\n        o[v] = c;\n        c++;\n      }\n    }\n\n    o.length = c;\n    return o;\n  };\n\n  core.Utils.filledArray = function (v, n, clss) {\n    var a = [];\n\n    while (n--) {\n      a[n] = clss ? new clss(v) : v;\n    }\n\n    return a;\n  };\n\n  core.Utils.arrSum = function (arr) {\n    var sum = 0,\n        l = arr.length;\n\n    for (var i = 0; i < l; i++) {\n      sum += arr[i];\n    }\n\n    return sum;\n  };\n  /**\r\n   * Determines if 2 arrays have intersecting elements.\r\n   * @param {Array} a\r\n   * @param {Array} b\r\n   * @returns {Boolean} True if a and b have intersecting elements.\r\n   */\n\n\n  core.Utils.haveIntersection = function (a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n\n    return a.some(function (e) {\n      return b.indexOf(e) > -1;\n    });\n  };\n  /**\r\n   * Substitutes out functions as variables so they can be used in regular algorithms\r\n   * @param {Symbol} symbol\r\n   * @param {Object} map\r\n   * @returns {String} The expression string\r\n   */\n\n\n  core.Utils.subFunctions = function (symbol, map) {\n    map = map || {};\n    var subbed = [];\n    symbol.each(function (x) {\n      if (x.group === FN || x.previousGroup === FN) {\n        //we need a new variable name so why not use one of the existing\n        var val = core.Utils.text(x, 'hash'),\n            tvar = map[val];\n\n        if (!tvar) {\n          //generate a unique enough name\n          var t = x.fname + keys(map).length;\n          map[val] = t;\n          subbed.push(x.altVar(t));\n        } else subbed.push(x.altVar(tvar));\n      } else if (x.group === CB || x.group === PL || x.group === CP) {\n        subbed.push(core.Utils.subFunctions(x, map));\n      } else subbed.push(x.text());\n    });\n    if (symbol.group === CP || symbol.group === PL) return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\n    ;\n    if (symbol.group === CB) return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\n    return symbol.text();\n  };\n\n  core.Utils.getFunctionsSubs = function (map) {\n    var subs = {}; //prepare substitutions\n\n    for (var x in map) {\n      subs[map[x]] = _.parse(x);\n    }\n\n    return subs;\n  };\n\n  var __ = core.Algebra = {\n    version: '1.4.5',\n    init: function () {}(),\n    proots: function proots(symbol, decp) {\n      //the roots will be rounded up to 7 decimal places.\n      //if this causes trouble you can explicitly pass in a different number of places\n      //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\n      decp = decp || 7;\n      var zeros = 0;\n      var known_roots = [];\n\n      var get_roots = function get_roots(rarr, powers, max) {\n        var roots = calcroots(rarr, powers, max).concat(known_roots);\n\n        for (var i = 0; i < zeros; i++) {\n          roots.unshift(0);\n        }\n\n        return roots;\n      };\n\n      if (symbol instanceof Symbol && symbol.isPoly()) {\n        symbol.distributeMultiplier(); //make it so the symbol has a constants as the lowest term\n\n        if (symbol.group === PL) {\n          var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\n          var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\n          symbol = _.expand(_.divide(symbol, lowest_symbol));\n          known_roots.push(0); //add zero since this is a known root\n        }\n\n        if (symbol.group === core.groups.S) {\n          return [0];\n        } else if (symbol.group === core.groups.PL) {\n          var powers = keys(symbol.symbols),\n              minpower = core.Utils.arrayMin(powers),\n              symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\n        }\n\n        var variable = keys(symbol.symbols).sort().pop(),\n            sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\n            g = sym.group,\n            powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\n            rarr = [],\n            max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\n        // Prepare the data\n\n        for (var i = 1; i <= max; i++) {\n          var c = 0; //if there is no power then the hole must be filled with a zero\n\n          if (powers.indexOf(i + '') !== -1) {\n            if (g === S) {\n              c = sym.multiplier;\n            } else {\n              c = sym.symbols[i].multiplier;\n            }\n          } // Insert the coeffient but from the front\n\n\n          rarr.unshift(c);\n        }\n\n        rarr.push(symbol.symbols[CONST_HASH].multiplier);\n        if (sym.group === S) rarr[0] = sym.multiplier; //the symbol maybe of group CP with one variable\n\n        return get_roots(rarr, powers, max);\n      } else if (core.Utils.isArray(symbol)) {\n        var parr = symbol;\n        var rarr = [],\n            powers = [],\n            last_power = 0;\n\n        for (var i = 0; i < parr.length; i++) {\n          var coeff = parr[i][0],\n              pow = parr[i][1],\n              d = pow - last_power - 1; //insert the zeros\n\n          for (var j = 0; j < d; j++) {\n            rarr.unshift(0);\n          }\n\n          rarr.unshift(coeff);\n          if (pow !== 0) powers.push(pow);\n          last_power = pow;\n        }\n\n        var max = Math.max.apply(undefined, powers);\n        return get_roots(rarr, powers, max);\n      } else {\n        throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\n      }\n\n      function calcroots(rarr, powers, max) {\n        var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\n        // Make a clone of the coefficients before appending the max power\n\n        var p = rarr.slice(0); // Divide the string up into its individual entries, which--presumably--are separated by whitespace\n\n        rarr.unshift(max);\n\n        if (max > MAXDEGREE) {\n          throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\n        }\n\n        var zeroi = [],\n            // Vector of imaginary components of roots\n        degreePar = {}; // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\n\n        degreePar.Degree = max;\n\n        for (i = 0; i < max; i++) {\n          zeroi.push(0);\n        }\n\n        var zeror = zeroi.slice(0); // Vector of real components of roots\n        // Find the roots\n        //--> Begin Jenkins-Traub\n\n        /*\r\n         * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n        */\n\n        function QuadSD_ak1(NN, u, v, p, q, iPar) {\n          // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\n          // iPar is a dummy variable for passing in the two parameters--a and b--by reference\n          q[0] = iPar.b = p[0];\n          q[1] = iPar.a = -(u * iPar.b) + p[1];\n\n          for (var i = 2; i < NN; i++) {\n            q[i] = -(u * iPar.a + v * iPar.b) + p[i];\n            iPar.b = iPar.a;\n            iPar.a = q[i];\n          }\n\n          return;\n        }\n\n        function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\n          // This routine calculates scalar quantities used to compute the next K polynomial and\n          // new estimates of the quadratic coefficients.\n          // calcSC -\tinteger variable set here indicating how the calculations are normalized\n          // to avoid overflow.\n          // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\n          // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\n          var sdPar = new Object(),\n              // TYPE = 3 indicates the quadratic is almost a factor of K\n          dumFlag = 3; // Synthetic division of K by the quadratic 1, u, v\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(N, u, v, K, qk, sdPar);\n          iPar.c = sdPar.a;\n          iPar.d = sdPar.b;\n\n          if (Math.abs(iPar.c) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 1])) {\n            if (Math.abs(iPar.d) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 2])) return dumFlag;\n          }\n\n          iPar.h = v * b;\n\n          if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {\n            // TYPE = 2 indicates that all formulas are divided by d\n            dumFlag = 2;\n            iPar.e = a / iPar.d;\n            iPar.f = iPar.c / iPar.d;\n            iPar.g = u * b;\n            iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);\n            iPar.a1 = -a + iPar.f * b;\n            iPar.a7 = iPar.h + (iPar.f + u) * a;\n          } else {\n            // TYPE = 1 indicates that all formulas are divided by c;\n            dumFlag = 1;\n            iPar.e = a / iPar.c;\n            iPar.f = iPar.d / iPar.c;\n            iPar.g = iPar.e * u;\n            iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;\n            iPar.a1 = -(a * (iPar.d / iPar.c)) + b;\n            iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;\n          }\n\n          return dumFlag;\n        }\n\n        function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\n          // Computes the next K polynomials using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\n          var temp;\n\n          if (tFlag == 3) {\n            // Use unscaled form of the recurrence\n            K[1] = K[0] = 0.0;\n\n            for (var i = 2; i < N; i++) {\n              K[i] = qk[i - 2];\n            }\n\n            return;\n          }\n\n          temp = tFlag == 1 ? b : a;\n\n          if (Math.abs(iPar.a1) > 10.0 * DBL_EPSILON * Math.abs(temp)) {\n            // Use scaled form of the recurrence\n            iPar.a7 /= iPar.a1;\n            iPar.a3 /= iPar.a1;\n            K[0] = qp[0];\n            K[1] = -(qp[0] * iPar.a7) + qp[1];\n\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\n            }\n          } else {\n            // If a1 is nearly zero, then use a special form of the recurrence\n            K[0] = 0.0;\n            K[1] = -(qp[0] * iPar.a7);\n\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\n            }\n          }\n\n          return;\n        }\n\n        function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\n          // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\n          // iPar.a = uu, iPar.b = vv\n          var a4, a5, b1, b2, c1, c2, c3, c4, temp;\n          iPar.b = iPar.a = 0.0; // The quadratic is zeroed\n\n          if (tFlag != 3) {\n            if (tFlag != 2) {\n              a4 = a + u * b + h * f;\n              a5 = c + (u + v * f) * d;\n            } else {\n              a4 = (a + g) * f + h;\n              a5 = (f + u) * c + v * d;\n            } // Evaluate new quadratic coefficients\n\n\n            b1 = -(K[N - 1] / p[N]);\n            b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\n            c1 = v * b2 * a1;\n            c2 = b1 * a7;\n            c3 = b1 * b1 * a3;\n            c4 = -(c2 + c3) + c1;\n            temp = -c4 + a5 + b1 * a4;\n\n            if (temp != 0.0) {\n              iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\n              iPar.b = v * (1.0 + c4 / temp);\n            }\n          }\n\n          return;\n        }\n\n        function Quad_ak1(a, b1, c, iPar) {\n          // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\n          // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\n          // zeros are real and both zeros are complex. The smaller real zero is found directly from\n          // the product of the zeros c/a.\n          // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\n          var b, d, e;\n          iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\n\n          if (a == 0) {\n            iPar.sr = b1 != 0 ? -(c / b1) : iPar.sr;\n            return;\n          }\n\n          if (c == 0) {\n            iPar.lr = -(b1 / a);\n            return;\n          } // Compute discriminant avoiding overflow\n\n\n          b = b1 / 2.0;\n\n          if (Math.abs(b) < Math.abs(c)) {\n            e = c >= 0 ? a : -a;\n            e = -e + b * (b / Math.abs(c));\n            d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\n          } else {\n            e = -(a / b * (c / b)) + 1.0;\n            d = Math.sqrt(Math.abs(e)) * Math.abs(b);\n          }\n\n          if (e >= 0) {\n            // Real zeros\n            d = b >= 0 ? -d : d;\n            iPar.lr = (-b + d) / a;\n            iPar.sr = iPar.lr != 0 ? c / iPar.lr / a : iPar.sr;\n          } else {\n            // Complex conjugate zeros\n            iPar.lr = iPar.sr = -(b / a);\n            iPar.si = Math.abs(d / a);\n            iPar.li = -iPar.si;\n          }\n\n          return;\n        }\n\n        function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\n          // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\n          // zeros are equimodular or nearly so.\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\n          // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\n          // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\n          var qPar = new Object(),\n              ee,\n              mp,\n              omp,\n              relstp,\n              t,\n              u,\n              ui,\n              v,\n              vi,\n              zm,\n              i,\n              j = 0,\n              tFlag,\n              triedFlag = 0; // Integer variables\n\n          iPar.NZ = 0; // Number of zeros found\n\n          u = uu; // uu and vv are coefficients of the starting quadratic\n\n          v = vv;\n\n          do {\n            qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n            Quad_ak1(1.0, u, v, qPar);\n            iPar.szr = qPar.sr;\n            iPar.szi = qPar.si;\n            iPar.lzr = qPar.lr;\n            iPar.lzi = qPar.li; // Return if roots of the quadratic are real and not close to multiple or nearly\n            // equal and of opposite sign.\n\n            if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr)) break; // Evaluate polynomial by quadratic synthetic division\n\n            QuadSD_ak1(NN, u, v, p, qp, sdPar);\n            mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b); // Compute a rigorous bound on the rounding error in evaluating p\n\n            zm = Math.sqrt(Math.abs(v));\n            ee = 2.0 * Math.abs(qp[0]);\n            t = -(iPar.szr * sdPar.b);\n\n            for (i = 1; i < N; i++) {\n              ee = ee * zm + Math.abs(qp[i]);\n            }\n\n            ee = ee * zm + Math.abs(t + sdPar.a);\n            ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON; // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\n\n            if (mp <= 20.0 * ee) {\n              iPar.NZ = 2;\n              break;\n            }\n\n            j++; // Stop iteration after 20 steps\n\n            if (j > 20) break;\n\n            if (j >= 2) {\n              if (relstp <= 0.01 && mp >= omp && !triedFlag) {\n                // A cluster appears to be stalling the convergence. Five fixed shift\n                // steps are taken with a u, v close to the cluster.\n                relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);\n                u -= u * relstp;\n                v += v * relstp;\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n\n                for (i = 0; i < 5; i++) {\n                  tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                  nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                }\n\n                triedFlag = 1;\n                j = 0;\n              }\n            }\n\n            omp = mp; // Calculate next K polynomial and new u and v\n\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vi = sdPar.b; // If vi is zero, the iteration is not converging\n\n            if (vi != 0) {\n              relstp = Math.abs((-v + vi) / vi);\n              u = ui;\n              v = vi;\n            }\n          } while (vi != 0);\n\n          return;\n        }\n\n        function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\n          // Variable-shift H-polynomial iteration for a real zero\n          // sss\t- starting iterate = sdPar.a\n          // NZ\t\t- number of zeros found = iPar.NZ\n          // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\n          var ee,\n              kv,\n              mp,\n              ms,\n              omp,\n              pv,\n              s,\n              t,\n              dumFlag,\n              i,\n              j,\n              nm1 = N - 1; // Integer variables\n\n          iPar.NZ = j = dumFlag = 0;\n          s = sdPar.a;\n\n          for (;;) {\n            pv = p[0]; // Evaluate p at s\n\n            qp[0] = pv;\n\n            for (i = 1; i < NN; i++) {\n              qp[i] = pv = pv * s + p[i];\n            }\n\n            mp = Math.abs(pv); // Compute a rigorous bound on the error in evaluating p\n\n            ms = Math.abs(s);\n            ee = 0.5 * Math.abs(qp[0]);\n\n            for (i = 1; i < NN; i++) {\n              ee = ee * ms + Math.abs(qp[i]);\n            } // Iteration has converged sufficiently if the polynomial value is less than\n            // 20 times this bound\n\n\n            if (mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\n              iPar.NZ = 1;\n              iPar.szr = s;\n              iPar.szi = 0.0;\n              break;\n            }\n\n            j++; // Stop iteration after 10 steps\n\n            if (j > 10) break;\n\n            if (j >= 2) {\n              if (Math.abs(t) <= 0.001 * Math.abs(-t + s) && mp > omp) {\n                // A cluster of zeros near the real axis has been encountered.\n                // Return with iFlag set to initiate a quadratic iteration.\n                dumFlag = 1;\n                iPar.a = s;\n                break;\n              } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\n\n            } //End if (j >= 2)\n            // Return if the polynomial value has increased significantly\n\n\n            omp = mp; // Compute t, the next polynomial and the new iterate\n\n            qk[0] = kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              qk[i] = kv = kv * s + K[i];\n            }\n\n            if (Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\n              // Use the scaled form of the recurrence if the value of K at s is non-zero\n              t = -(pv / kv);\n              K[0] = qp[0];\n\n              for (i = 1; i < N; i++) {\n                K[i] = t * qk[i - 1] + qp[i];\n              }\n            } else {\n              // Use unscaled form\n              K[0] = 0.0;\n\n              for (i = 1; i < N; i++) {\n                K[i] = qk[i - 1];\n              }\n            }\n\n            kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              kv = kv * s + K[i];\n            }\n\n            t = Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON ? -(pv / kv) : 0.0;\n            s += t;\n          }\n\n          return dumFlag;\n        }\n\n        function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\n          // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\n          // quadratic case. Initiates one of the variable shift iterations and returns with the\n          // number of zeros found.\n          // L2\tlimit of fixed shift steps\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // NZ\tnumber of zeros found\n          var sdPar = new Object(),\n              // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\n          calcPar = new Object(),\n              // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\n          qk = new Array(MDP1),\n              svk = new Array(MDP1),\n              a,\n              b,\n              betas,\n              betav,\n              oss,\n              ots,\n              otv,\n              ovv,\n              s,\n              ss,\n              ts,\n              tss,\n              tv,\n              tvv,\n              ui,\n              vi,\n              vv,\n              fflag,\n              i,\n              iFlag = 1,\n              j,\n              spass,\n              stry,\n              tFlag,\n              vpass,\n              vtry; // Integer variables\n\n          iPar.NZ = 0;\n          betav = betas = 0.25;\n          oss = sr;\n          ovv = v; //Evaluate polynomial by synthetic division\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(NN, u, v, p, qp, sdPar);\n          a = sdPar.a;\n          b = sdPar.b;\n          calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\n          tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n          for (j = 0; j < L2; j++) {\n            fflag = 1; // Calculate next K polynomial and estimate v\n\n            nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk); // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\n            // sdPar.a = ui, sdPar.b = vi\n\n            newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vv = vi = sdPar.b; // Estimate s\n\n            ss = K[N - 1] != 0.0 ? -(p[N] / K[N - 1]) : 0.0;\n            ts = tv = 1.0;\n\n            if (j != 0 && tFlag != 3) {\n              // Compute relative measures of convergence of s and v sequences\n              tv = vv != 0.0 ? Math.abs((vv - ovv) / vv) : tv;\n              ts = ss != 0.0 ? Math.abs((ss - oss) / ss) : ts; // If decreasing, multiply the two most recent convergence measures\n\n              tvv = tv < otv ? tv * otv : 1.0;\n              tss = ts < ots ? ts * ots : 1.0; // Compare with convergence criteria\n\n              vpass = tvv < betav ? 1 : 0;\n              spass = tss < betas ? 1 : 0;\n\n              if (spass || vpass) {\n                // At least one sequence has passed the convergence test.\n                // Store variables before iterating\n                for (i = 0; i < N; i++) {\n                  svk[i] = K[i];\n                }\n\n                s = ss; // Choose iteration according to the fastest converging sequence\n\n                stry = vtry = 0;\n\n                for (;;) {\n                  if (fflag && (fflag = 0) == 0 && spass && (!vpass || tss < tvv)) {\n                    ; // Do nothing. Provides a quick \"short circuit\".\n                  } else {\n                    QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\n                    a = sdPar.a;\n                    b = sdPar.b;\n                    if (iPar.NZ > 0) return; // Quadratic iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    iFlag = vtry = 1;\n                    betav *= 0.25; // Try linear iteration if it has not been tried and the s sequence is converging\n\n                    if (stry || !spass) {\n                      iFlag = 0;\n                    } else {\n                      for (i = 0; i < N; i++) {\n                        K[i] = svk[i];\n                      }\n                    }\n                  } //fflag = 0;\n\n\n                  if (iFlag != 0) {\n                    // Use sdPar for passing in s instead of defining a brand-new variable.\n                    // sdPar.a = s\n                    sdPar.a = s;\n                    iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\n                    s = sdPar.a;\n                    if (iPar.NZ > 0) return; // Linear iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    stry = 1;\n                    betas *= 0.25;\n\n                    if (iFlag != 0) {\n                      // If linear iteration signals an almost double real zero, attempt quadratic iteration\n                      ui = -(s + s);\n                      vi = s * s;\n                      continue;\n                    }\n                  } // Restore variables\n\n\n                  for (i = 0; i < N; i++) {\n                    K[i] = svk[i];\n                  } // Try quadratic iteration if it has not been tried and the v sequence is converging\n\n\n                  if (!vpass || vtry) break; // Break out of infinite for loop\n                } // Re-compute qp and scalar values to continue the second stage\n\n\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                a = sdPar.a;\n                b = sdPar.b;\n                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n              }\n            }\n\n            ovv = vv;\n            oss = ss;\n            otv = tv;\n            ots = ts;\n          }\n\n          return;\n        }\n\n        function rpSolve(degPar, p, zeror, zeroi) {\n          var N = degPar.Degree,\n              RADFAC = 3.14159265358979323846 / 180,\n              // Degrees-to-radians conversion factor = PI/180\n          LB2 = Math.LN2,\n              // Dummy variable to avoid re-calculating this value in loop below\n          MDP1 = degPar.Degree + 1,\n              K = new Array(MDP1),\n              pt = new Array(MDP1),\n              qp = new Array(MDP1),\n              temp = new Array(MDP1),\n              // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\n          qPar = new Object(),\n              // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\n          Fxshfr_Par = new Object(),\n              bnd,\n              DBL_EPSILON,\n              df,\n              dx,\n              factor,\n              ff,\n              moduli_max,\n              moduli_min,\n              sc,\n              x,\n              xm,\n              aa,\n              bb,\n              cc,\n              sr,\n              t,\n              u,\n              xxx,\n              j,\n              jj,\n              l,\n              NM1,\n              NN,\n              zerok; // Integer variables\n          // Calculate the machine epsilon and store in the variable DBL_EPSILON.\n          // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\n\n          aa = 1.0;\n\n          do {\n            DBL_EPSILON = aa;\n            aa /= 2;\n            bb = 1.0 + aa;\n          } while (bb > 1.0);\n\n          var LO = Number.MIN_VALUE / DBL_EPSILON,\n              cosr = Math.cos(94.0 * RADFAC),\n              // = -0.069756474\n          sinr = Math.sin(94.0 * RADFAC),\n              // = 0.99756405\n          xx = Math.sqrt(0.5),\n              // = 0.70710678\n          yy = -xx;\n          Fxshfr_Par.NZ = j = 0;\n          Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0; // Remove zeros at the origin, if any\n\n          while (p[N] == 0) {\n            zeror[j] = zeroi[j] = 0;\n            N--;\n            j++;\n          }\n\n          NN = N + 1; // >>>>> Begin Main Loop <<<<<\n\n          while (N >= 1) {\n            // Main loop\n            // Start the algorithm for one zero\n            if (N <= 2) {\n              // Calculate the final zero or pair of zeros\n              if (N < 2) {\n                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\n                zeroi[degPar.Degree - 1] = 0;\n              } else {\n                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n                Quad_ak1(p[0], p[1], p[2], qPar);\n                zeror[degPar.Degree - 2] = qPar.sr;\n                zeroi[degPar.Degree - 2] = qPar.si;\n                zeror[degPar.Degree - 1] = qPar.lr;\n                zeroi[degPar.Degree - 1] = qPar.li;\n              }\n\n              break;\n            } // Find the largest and smallest moduli of the coefficients\n\n\n            moduli_max = 0.0;\n            moduli_min = Number.MAX_VALUE;\n\n            for (i = 0; i < NN; i++) {\n              x = Math.abs(p[i]);\n              if (x > moduli_max) moduli_max = x;\n              if (x != 0 && x < moduli_min) moduli_min = x;\n            } // Scale if there are large or very small coefficients\n            // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\n            // is done to avoid overflow and to avoid undetected underflow interfering with the\n            // convergence criterion.\n            // The factor is a power of the base.\n\n\n            sc = LO / moduli_min;\n\n            if (sc <= 1.0 && moduli_max >= 10 || sc > 1.0 && Number.MAX_VALUE / sc >= moduli_max) {\n              sc = sc == 0 ? Number.MIN_VALUE : sc;\n              l = Math.floor(Math.log(sc) / LB2 + 0.5);\n              factor = Math.pow(2.0, l);\n\n              if (factor != 1.0) {\n                for (i = 0; i < NN; i++) {\n                  p[i] *= factor;\n                }\n              }\n            } // Compute lower bound on moduli of zeros\n\n\n            for (var i = 0; i < NN; i++) {\n              pt[i] = Math.abs(p[i]);\n            }\n\n            pt[N] = -pt[N];\n            NM1 = N - 1; // Compute upper estimate of bound\n\n            x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\n\n            if (pt[NM1] != 0) {\n              // If Newton step at the origin is better, use it\n              xm = -pt[N] / pt[NM1];\n              x = xm < x ? xm : x;\n            } // Chop the interval (0, x) until ff <= 0\n\n\n            xm = x;\n\n            do {\n              x = xm;\n              xm = 0.1 * x;\n              ff = pt[0];\n\n              for (var i = 1; i < NN; i++) {\n                ff = ff * xm + pt[i];\n              }\n            } while (ff > 0); // End do-while loop\n\n\n            dx = x; // Do Newton iteration until x converges to two decimal places\n\n            do {\n              df = ff = pt[0];\n\n              for (var i = 1; i < N; i++) {\n                ff = x * ff + pt[i];\n                df = x * df + ff;\n              } // End for i\n\n\n              ff = x * ff + pt[N];\n              dx = ff / df;\n              x -= dx;\n            } while (Math.abs(dx / x) > 0.005); // End do-while loop\n\n\n            bnd = x; // Compute the derivative as the initial K polynomial and do 5 steps with no shift\n\n            for (var i = 1; i < N; i++) {\n              K[i] = (N - i) * p[i] / N;\n            }\n\n            K[0] = p[0];\n            aa = p[N];\n            bb = p[NM1];\n            zerok = K[NM1] == 0 ? 1 : 0;\n\n            for (jj = 0; jj < 5; jj++) {\n              cc = K[NM1];\n\n              if (zerok) {\n                // Use unscaled form of recurrence\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = K[j - 1];\n                } // End for i\n\n\n                K[0] = 0;\n                zerok = K[NM1] == 0 ? 1 : 0;\n              } else {\n                // Used scaled form of recurrence if value of K at 0 is nonzero\n                t = -aa / cc;\n\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = t * K[j - 1] + p[j];\n                } // End for i\n\n\n                K[0] = p[0];\n                zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0 ? 1 : 0;\n              }\n            } // Save K for restarts with new shifts\n\n\n            for (var i = 0; i < N; i++) {\n              temp[i] = K[i];\n            } // Loop to select the quadratic corresponding to each new shift\n\n\n            for (jj = 1; jj <= 20; jj++) {\n              // Quadratic corresponds to a double shift to a non-real point and its\n              // complex conjugate. The point has modulus BND and amplitude rotated\n              // by 94 degrees from the previous shift.\n              xxx = -(sinr * yy) + cosr * xx;\n              yy = sinr * xx + cosr * yy;\n              xx = xxx;\n              sr = bnd * xx;\n              u = -(2.0 * sr); // Second stage calculation, fixed quadratic\n\n              Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\n\n              if (Fxshfr_Par.NZ != 0) {\n                // The second stage jumps directly to one of the third stage iterations and\n                // returns here if successful. Deflate the polynomial, store the zero or\n                // zeros, and return to the main algorithm.\n                j = degPar.Degree - N;\n                zeror[j] = Fxshfr_Par.szr;\n                zeroi[j] = Fxshfr_Par.szi;\n                NN = NN - Fxshfr_Par.NZ;\n                N = NN - 1;\n\n                for (var i = 0; i < NN; i++) {\n                  p[i] = qp[i];\n                }\n\n                if (Fxshfr_Par.NZ != 1) {\n                  zeror[j + 1] = Fxshfr_Par.lzr;\n                  zeroi[j + 1] = Fxshfr_Par.lzi;\n                }\n\n                break;\n              } else {\n                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\n                for (var i = 0; i < N; i++) {\n                  K[i] = temp[i];\n                }\n              }\n            } // Return with failure if no convergence with 20 shifts\n\n\n            if (jj > 20) {\n              degPar.Degree -= N;\n              break;\n            }\n          } // >>>>> End Main Loop <<<<<\n\n\n          return;\n        } //--> End Jenkins-Traub\n\n\n        rpSolve(degreePar, p, zeror, zeroi);\n        var l = zeroi.length; //format the output\n\n        for (i = 0; i < l; i++) {\n          // We round the imaginary part to avoid having something crazy like 5.67e-16.\n          var img = round(zeroi[i], decp + 8),\n              real = round(zeror[i], decp + 8); // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\n          // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \n          // the original otherwise the rounding was worth it.\n\n          real = decp - String(real).length > 2 ? real : zeror[i];\n          var sign = img < 0 ? '-' : ''; // Remove the zeroes\n\n          if (real === 0) {\n            real = '';\n          }\n\n          if (img === 0) {\n            img = '';\n          } // Remove 1 as the multiplier and discard imaginary part if there isn't one.\n\n\n          img = Math.abs(img) === 1 ? sign + 'i' : img ? img + '*i' : '';\n          var num = real && img ? real + '+' + img : real + img;\n          zeror[i] = num.replace(/\\+\\-/g, '-');\n        }\n\n        return zeror;\n      }\n    },\n    roots: function roots(symbol) {\n      if (symbol.isConstant(true, true)) {\n        return core.Utils.nroots(symbol);\n      }\n\n      var roots = __.proots(symbol).map(function (x) {\n        return _.parse(x);\n      });\n\n      return core.Vector.fromArray(roots);\n    },\n    froot: function froot(f, guess, dx) {\n      var newtonraph = function newtonraph(xn) {\n        var mesh = 1e-12,\n            // If the derivative was already provided then don't recalculate.\n        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\n            // If the function was passed in as a function then don't recalculate.\n        fn = f instanceof Function ? f : core.Utils.build(f),\n            max = 10000,\n            done = false,\n            safety = 0;\n\n        while (!done) {\n          var x = xn - fn(xn) / df(xn); //absolute values for both x & xn ensures that we indeed have the radius    \n\n          var r = Math.abs(x) - Math.abs(xn),\n              delta = Math.abs(r);\n          xn = x;\n          if (delta < mesh) done = true;else if (safety > max) {\n            xn = null;\n            done = true;\n          }\n          safety++;\n        }\n\n        return xn;\n      };\n\n      return newtonraph(Number(guess));\n    },\n    quad: function quad(a, b, c) {\n      var q = function q(a, b, c, sign) {\n        return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\n      };\n\n      return [q(a, b, c, 1), q(a, b, c, -1)];\n    },\n    sumProd: function sumProd(a, b) {\n      return __.quad(-b, a, -1).map(function (x) {\n        return x.invert();\n      });\n    },\n    coeffs: function coeffs(symbol, wrt, _coeffs) {\n      wrt = String(wrt);\n      symbol = _.expand(symbol);\n      _coeffs = _coeffs || [new Symbol(0)]; //we cannot get coeffs for group EX\n\n      if (symbol.group === EX && symbol.contains(wrt, true)) _.error('Unable to get coefficients using expression ' + symbol.toString());\n      var vars = variables(symbol);\n\n      if (vars.length <= 1 && vars[0] === wrt) {\n        var a = new Polynomial(symbol).coeffs.map(function (x) {\n          return new Symbol(x);\n        });\n\n        for (var i = 0, l = a.length; i < l; i++) {\n          var coeff = a[i],\n              e = _coeffs[i];\n          if (e) coeff = _.add(e, coeff);\n          _coeffs[i] = coeff; //transfer it all over\n        }\n      } else {\n        if (!wrt) _.error('Polynomial contains more than one variable. Please specify which variable is to be used!'); //if the variable isn't part of this polynomial then we're looking at x^0\n\n        if (vars.indexOf(wrt) === -1) {\n          _coeffs[0] = _.add(symbol, _coeffs[0]);\n        } else {\n          _coeffs = _coeffs || [new Symbol(0)];\n\n          if (symbol.group === CB) {\n            var s = symbol.symbols[wrt];\n            if (!s) _.error('Expression is not a polynomial!');\n            var p = Number(s.power);\n            coeff = _.divide(symbol.clone(), s.clone());\n            if (coeff.contains(wrt, true) || p < 0 || !isInt(p)) _.error('Expression is not a polynomial!');\n            var e = _coeffs[p];\n            if (e) coeff = _.add(e, coeff);\n            _coeffs[p] = coeff;\n          } else if (symbol.group === CP) {\n            symbol.each(function (x) {\n              __.coeffs(x.clone(), wrt, _coeffs);\n            }, true);\n          }\n        }\n      } //fill holes\n\n\n      for (var i = 0, l = _coeffs.length; i < l; i++) {\n        if (typeof _coeffs[i] === 'undefined') _coeffs[i] = new Symbol(0);\n      }\n\n      return _coeffs;\n    },\n\n    /**\r\n     * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n     * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n     * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n     * @param {Symbol} e\r\n     * @param {String} for_variable\r\n     * @param {Array} powers\r\n     * @returns {Array} An array of the powers\r\n     */\n    //assumes you've already verified that it's a polynomial\n    polyPowers: function polyPowers(e, for_variable, powers) {\n      powers = powers || [];\n      var g = g = e.group;\n\n      if (g === PL && for_variable === e.value) {\n        powers = powers.concat(keys(e.symbols));\n      } else if (g === CP) {\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s];\n          var g = symbol.group,\n              v = symbol.value;\n          if (g === S && for_variable === v) powers.push(symbol.power);else if (g === PL || g === CP) powers = __.polyPowers(symbol, for_variable, powers);else if (g === CB && symbol.contains(for_variable)) {\n            var t = symbol.symbols[for_variable];\n            if (t) powers.push(t.power);\n          } else if (g === N || for_variable !== v) powers.push(0);\n        }\n      } else if (g === CB && e.contains(for_variable)) {\n        powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\n      }\n\n      return core.Utils.arrayUnique(powers).sort();\n    },\n    //The factor object\n    Factor: {\n      //splits the symbol in symbol and constant\n      split: function split(symbol) {\n        var c = new Symbol(1); //the constants part\n\n        var s = new Symbol(1); //the symbolic part\n\n        __.Factor.factor(symbol, new Factors()).each(function (x) {\n          var t = _.parse(x);\n\n          if (x.isConstant(true)) {\n            c = _.multiply(c, t);\n          } else {\n            s = _.multiply(s, t);\n          }\n        });\n\n        return [c, s];\n      },\n      mix: function mix(o, include_negatives) {\n        var factors = keys(o);\n        var l = factors.length;\n        var m = []; //create a row which we'r going to be mixing\n\n        for (var i = 0; i < l; i++) {\n          var factor = factors[i],\n              p = o[factor];\n          var ll = m.length;\n\n          for (var j = 0; j < ll; j++) {\n            var t = m[j] * factor;\n            m.push(t);\n            if (include_negatives) m.push(-t);\n          }\n\n          for (var j = 1; j <= p; j++) {\n            m.push(Math.pow(factor, j));\n          }\n        }\n\n        return m;\n      },\n      //TODO: this method is to replace common factoring\n      common: function common(symbol, factors) {\n        try {\n          if (symbol.group === CP) {\n            //this may have the unfortunate side effect of expanding and factoring again\n            //to only end up with the same result. \n            //TODO: try to avoid this\n            //collect the symbols and sort to have the longest first. Thinking is that the longest terms \n            //has to contain the variable in order for it to be factorable\n            var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\n              return (b.length || 1) - (a.length || 1);\n            });\n\n            var map = {}; //create a map of common factors\n\n            var coeffs = [];\n\n            for (var i = 0; i < symbols.length; i++) {\n              var sym = symbols[i];\n              coeffs.push(sym.multiplier.clone());\n              sym.each(function (x) {\n                var p = Number(x.power); //This check exits since we have a symbolic power.\n                //For the future... think about removing this check and modify for symbolic powers\n\n                if (isNaN(p)) throw new Error('exiting'); //loop through the symbols and lump together common terms\n\n                if (x.value in map) {\n                  if (p < map[x.value][0]) map[x.value][0] = p;\n                  map[x.value][1].push(x);\n                } else map[x.value] = [p, [x]];\n              });\n            } //the factor\n\n\n            var factor = new Symbol(1);\n\n            for (var x in map) {\n              //if this factor is found in all terms since the length of \n              //matching variable terms matches the number of original terms\n              if (map[x][1].length === symbols.length) {\n                //generate a symbol and multiply into the factor\n                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\n              }\n            } //get coefficient factor\n\n\n            var c = core.Math2.QGCD.apply(null, coeffs);\n\n            if (!c.equals(1)) {\n              factors.add(new Symbol(c));\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbols[i].multiplier = symbols[i].multiplier.divide(c);\n              }\n            } //if we actuall found any factors\n\n\n            if (!factor.equals(1)) {\n              factors.add(factor);\n              symbol = new Symbol(0);\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      zeroes: function zeroes(symbol, factors) {\n        var exit = function exit() {\n          throw new core.exceptions.ValueLimitExceededError('Exiting');\n        };\n\n        try {\n          var vars, term, sum, p, e;\n          symbol = _.expand(symbol.clone());\n          e = symbol.toString();\n          vars = variables(symbol);\n          sum = new Symbol(0);\n          var terms = [];\n          var powers = []; //start setting each variable to zero\n\n          for (var i = 0, l = vars.length; i < vars.length; i++) {\n            var subs = {}; //we want to create a subs object with all but the current variable set to zero\n\n            for (var j = 0; j < l; j++) {\n              if (i !== j) //make sure we're not looking at the same variable\n                subs[vars[j]] = 0;\n            }\n\n            term = _.parse(e, subs);\n            var tp = term.power; //the temporary power has to be an integer as well\n\n            if (!isInt(tp)) exit();\n            terms.push(term);\n            powers.push(term.power);\n          } //get the gcd. This will be the p in (a^n+b^m)^p\n          //if the gcd equals 1 meaning n = m then we need a tie breakder\n\n\n          if (core.Utils.allSame(powers)) {\n            //get p given x number of terms\n            var n_terms = symbol.length; //the number of zeroes determines\n\n            var n_zeroes = terms.length;\n\n            if (n_zeroes === 2) {\n              p = new Frac(powers[0] / (n_terms - 1));\n            }\n\n            if (n_zeroes === 3) {\n              p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\n            }\n            /*\r\n            //get the lowest possible power\r\n            //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n            symbol.each(function(x) {\r\n                if(x.group === CB)\r\n                    x.each(function(y) {\r\n                        if(!p || y.power.lessThan(p))\r\n                            //p = Number(y.power);\r\n                            p = y.power;\r\n                    });\r\n                else if(!p || x.power.lessThan(p))\r\n                    //p = Number(x.power);\r\n                    p = x.power;\r\n            });\r\n            */\n\n          } else //p is just the gcd of the powers\n            p = core.Math2.QGCD.apply(null, powers); //if we don't have an integer then exit\n\n\n          if (!isInt(p)) exit(); //build the factor\n\n          for (var i = 0; i < terms.length; i++) {\n            var t = terms[i];\n            var n = t.power.clone().divide(p);\n            t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\n            t.power = p.clone();\n            sum = _.add(sum, t);\n          } //by now we have the factor of zeroes. We'll know if we got it right because \n          //we'll get a remainder of zero each time we divide by it\n\n\n          if (sum.group !== CP) return symbol; //nothing to do\n\n          while (true) {\n            var d = __.div(symbol.clone(), sum.clone());\n\n            if (d[1].equals(0)) {\n              symbol = d[0];\n              factors.add(sum.clone());\n              if (symbol.equals(1)) //we've reached 1 so done.\n                break;\n            } else break;\n          }\n        } catch (e) {}\n\n        ;\n        return symbol;\n      },\n      factor: function factor(symbol, factors) {\n        var _symbol = _.parse(symbol);\n\n        var retval = __.Factor._factor(_symbol, factors);\n\n        if (retval.equals(symbol)) {\n          return retval;\n        }\n\n        if (retval.group === CB) {\n          var t = new Symbol(1);\n          /* \r\n           * NOTE: for sign issues with factor START DEBUGGING HERE\r\n           */\n          //move the sign to t\n\n          if (retval.multiplier.lessThan(0)) {\n            t.negate();\n            retval.negate();\n          }\n\n          retval.each(function (x) {\n            var factored = __.Factor._factor(x);\n\n            if (factored.group === CB) {\n              factored.each(function (y) {\n                var _factored = __.Factor._factor(y);\n\n                t = _.multiply(t, _factored);\n              });\n            } else {\n              t = _.multiply(t, factored);\n            }\n          });\n          retval = t;\n        }\n\n        return retval;\n      },\n      quadFactor: function quadFactor(symbol, factors) {\n        if (symbol.isPoly() && __.degree(symbol.equals(2))) {\n          //We've  already checked that we're dealing with a polynomial\n          var v = core.Utils.variables(symbol)[0]; //get the variable\n\n          var coeffs = __.coeffs(symbol, v); //factor the lead coefficient\n\n\n          var cf = __.Factor._factor(coeffs[2].clone()); //check if we have factors\n\n\n          if (cf.group === CB) {\n            var symbols = cf.collectSymbols(); //if the factors are greater than 2 we're done so exit\n\n            if (symbols.length > 2) return symbol; //if we have two factors then attempt to factor the polynomial\n            //let the factors be f1 and f1\n            //let the factors be (ax+b)(cx+d)\n            //let the coefficients be c1x^2+c2x+c3\n            //then a(x1)+c(x2)=c2 and x1*x2=c3\n            //we can solve for x1 and x2\n\n            var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\n\n            var b = _.parse(coeffs[1]).negate();\n\n            var a = _.parse(symbols[1]); //solve the system\n\n\n            var root = __.quad(a, b, c).filter(function (x) {\n              if (core.Utils.isInt(x)) return x;\n            }); //if we have one root then find the other one by dividing the constant\n\n\n            if (root.length === 1) {\n              var root1 = root[0];\n\n              var root2 = _.divide(coeffs[0], _.parse(root1));\n\n              if (core.Utils.isInt(root2)) {\n                //we found them both\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        }\n\n        return symbol;\n      },\n      _factor: function _factor(symbol, factors) {\n        //some items cannot be factored any further so return those right away\n        if (symbol.group === FN) {\n          var arg = symbol.args[0];\n          if (arg.group === S && arg.isSimple()) return symbol;\n        } else if (symbol.group === S && symbol.isSimple()) return symbol; //expand the symbol to get it in a predictable form. If this step\n        //is skipped some factors are missed.\n\n\n        if (symbol.group === CP) {\n          symbol.distributeMultiplier();\n          var t = new Symbol(0);\n          symbol.each(function (x) {\n            if (x.group === CP && x.power.greaterThan(1) || x.group === CB) x = _.expand(x);\n            t = _.add(t, x);\n          });\n          t.power = symbol.power;\n          symbol = t;\n        }\n\n        if (symbol.group === FN && symbol.fname !== 'sqrt') symbol = core.Utils.evaluate(symbol); //make a copy of the symbol to return if something goes wrong\n\n        var untouched = symbol.clone();\n\n        try {\n          if (symbol.group === CB) {\n            var den_array, num_array, den, num, dfact, nfact; //grab the denominator and strip the multiplier and power. Store them in an array\n\n            den_array = __.Simplify.strip(symbol.getDenom());\n            num_array = __.Simplify.strip(symbol.getNum());\n            den = den_array.pop();\n            num = num_array.pop(); //if the numerator equals the symbol then we've hit the simplest form and then we're done\n\n            if (num.equals(symbol)) return symbol;\n            nfact = __.Factor.factor(num);\n            dfact = __.Factor.factor(den);\n\n            var n = __.Simplify.unstrip(num_array, nfact);\n\n            var d = __.Simplify.unstrip(den_array, dfact);\n\n            var retval = _.divide(n, d);\n\n            return retval;\n          }\n\n          if (symbol.group === S) return symbol; //absolutely nothing to do\n\n          if (symbol.isConstant()) {\n            if (symbol.equals(1)) return symbol.clone();\n            var ret = core.Math2.factor(symbol);\n            return ret;\n          }\n\n          var p = symbol.power.clone();\n\n          if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\n            var sign = p.sign();\n            symbol.toLinear();\n            factors = factors || new Factors();\n            var map = {};\n            symbol = _.parse(core.Utils.subFunctions(symbol, map));\n\n            if (keys(map).length > 0) {\n              //it might have functions\n              factors.preAdd = function (factor) {\n                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\n\n                return ret;\n              };\n            } //strip the power\n\n\n            if (!symbol.isLinear()) {\n              factors.pFactor = symbol.power.toString();\n              symbol.toLinear();\n            }\n\n            var vars = variables(symbol); //bypass for imaginary. TODO: find a better solution\n\n            if (symbol.isImaginary()) {\n              vars.push(core.Settings.IMAGINARY);\n            }\n\n            var multiVar = vars.length > 1; //minor optimization. Seems to cut factor time by half in some cases.\n\n            if (multiVar) {\n              var all_S = true,\n                  all_unit = true;\n              symbol.each(function (x) {\n                if (x.group !== S) all_S = false;\n                if (!x.multiplier.equals(1)) all_unit = false;\n              });\n\n              if (all_S && all_unit) {\n                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\n              }\n            } //factor the coefficients\n\n\n            var coeff_factors = new Factors();\n            symbol = __.Factor.coeffFactor(symbol, coeff_factors);\n            coeff_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            }); //factor the power\n\n            var power_factors = new Factors();\n            symbol = __.Factor.powerFactor(symbol, power_factors);\n            power_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            });\n\n            if (!multiVar) {\n              //pass in vars[0] for safety\n              var v = vars[0];\n              symbol = __.Factor.squareFree(symbol, factors, v);\n              var t_factors = new Factors();\n              symbol = __.Factor.trialAndError(symbol, t_factors, v); //generate a symbol based off the last factors\n\n              var tf_symbol = t_factors.toSymbol(); //if nothing was factored then return the factors\n\n              if (tf_symbol.equals(untouched)) return tf_symbol;\n\n              for (var x in t_factors.factors) {\n                //store the current factor in t_factor\n                var t_factor = t_factors.factors[x];\n                factors.add(_.pow(t_factor, _.parse(p)));\n              } //if we still don't have a factor and it's quadratic then let's just do a quad factor\n\n\n              if (symbol.equals(untouched)) symbol = __.Factor.quadFactor(symbol, factors);\n            } else {\n              symbol = __.Factor.mfactor(symbol, factors); //put back the sign of power\n\n              factors.each(function (x) {\n                if (sign < 0) x.power.negate();\n              });\n            } //last minute clean up\n\n\n            symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\n            factors.add(_.pow(symbol, _.parse(p)));\n            var retval = factors.toSymbol();\n            return retval;\n          }\n\n          return symbol;\n        } catch (e) {\n          //no need to stop the show because something went wrong :). Just return the unfactored.\n          return untouched;\n        }\n      },\n      reduce: function reduce(symbol, factors) {\n        if (symbol.group === CP && symbol.length === 2) {\n          var symbols = symbol.collectSymbols().sort(function (a, b) {\n            return b.multiplier - a.multiplier;\n          });\n\n          if (symbols[0].power.equals(symbols[1].power)) {\n            //x^n-a^n\n            var n = _.parse(symbols[0].power),\n                a = symbols[0].clone().toLinear(),\n                b = symbols[1].clone().toLinear(); //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\n\n\n            factors.add(_.add(a.clone(), b.clone())); //flip the sign\n\n            b.negate(); //turn n into a number\n\n            var nn = Number(n); //the remainder\n\n            var result = new Symbol(0);\n\n            for (var i = 1; i <= nn; i++) {\n              var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\n                  bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\n\n              result = _.add(result, _.multiply(aa, bb));\n            }\n\n            return result;\n          }\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Makes Symbol square free\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @@param {String} variable The variable which is being factored \r\n       * @returns {[Symbol, Factor]}\r\n       */\n      squareFree: function squareFree(symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n        var poly = new Polynomial(symbol, variable);\n        var sqfr = poly.squareFree();\n        var p = sqfr[2]; //if we found a square then the p entry in the array will be non-unit\n\n        if (p !== 1) {\n          //make sure the remainder doesn't have factors\n          var t = sqfr[1].toSymbol();\n          t.power = t.power.multiply(new Frac(p)); //send the factor to be fatored to be sure it's completely factored\n\n          factors.add(__.Factor.factor(t));\n          return __.Factor.squareFree(sqfr[0].toSymbol(), factors);\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Factors the powers such that the lowest power is a constant\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @returns {[Symbol, Factor]}\r\n       */\n      powerFactor: function powerFactor(symbol, factors) {\n        //only PL need apply\n        if (symbol.group !== PL || symbol.previousGroup === EX) return symbol;\n        var k = keys(symbol.symbols); //we expect only numeric powers so return all else\n\n        if (!core.Utils.allNumeric(k)) return symbol;\n        var d = core.Utils.arrayMin(k);\n        var retval = new Symbol(0);\n\n        var q = _.parse(symbol.value + '^' + d);\n\n        symbol.each(function (x) {\n          x = _.divide(x, q.clone());\n          retval = _.add(retval, x);\n        });\n        factors.add(q);\n        return retval;\n      },\n\n      /**\r\n       * Removes GCD from coefficients\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @returns {Symbol}\r\n       */\n      coeffFactor: function coeffFactor(symbol, factors) {\n        if (symbol.isComposite()) {\n          var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\n\n          if (!gcd.equals(1)) {\n            symbol.each(function (x) {\n              if (x.isComposite()) {\n                x.each(function (y) {\n                  y.multiplier = y.multiplier.divide(gcd);\n                });\n              } else x.multiplier = x.multiplier.divide(gcd);\n            });\n          }\n\n          symbol.updateHash();\n          if (factors) factors.add(new Symbol(gcd));\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * The name says it all :)\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @@param {String} variable \r\n       * @returns {Symbol}\r\n       */\n      trialAndError: function trialAndError(symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n\n        var poly = new Polynomial(symbol, variable),\n            cnst = poly.coeffs[0],\n            cfactors = core.Math2.ifactor(cnst),\n            roots = __.proots(symbol);\n\n        for (var i = 0; i < roots.length; i++) {\n          var r = roots[i],\n              p = 1;\n\n          if (!isNaN(r)) {\n            //if it's a number\n            for (var x in cfactors) {\n              //check it's raised to a power\n              var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\n\n              if (isInt(n)) {\n                r = x; //x must be the root since n gave us a whole\n\n                p = n;\n                break;\n              }\n            }\n\n            var root = new Frac(r),\n                terms = [new Frac(root.num).negate()];\n            terms[p] = new Frac(root.den); //convert to Frac. The den is coeff of LT and the num is coeff of constant\n\n            var div = Polynomial.fromArray(terms, poly.variable).fill(),\n                t = poly.divide(div);\n\n            if (t[1].equalsNumber(0)) {\n              //if it's zero we have a root and divide it out\n              poly = t[0];\n              factors.add(div.toSymbol());\n            }\n          }\n        }\n\n        if (!poly.equalsNumber(1)) {\n          poly = __.Factor.search(poly, factors);\n        }\n\n        return poly.toSymbol();\n      },\n      search: function search(poly, factors, base) {\n        base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\n\n        var v = poly.variable; //the polynmial variable name\n\n        /**\r\n         * Attempt to remove a root by division given a number by first creating\r\n         * a polynomial fromt he given information\r\n         * @param {int} c1 - coeffient for the constant\r\n         * @param {int} c2 - coefficient for the LT\r\n         * @param {int} n - the number to be used to construct the polynomial\r\n         * @param {int} p - the power at which to create the polynomial\r\n         * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n         */\n\n        var check = function check(c1, c2, n, p) {\n          var candidate = Polynomial.fit(c1, c2, n, base, p, v);\n\n          if (candidate && candidate.coeffs.length > 1) {\n            var t = poly.divide(candidate);\n\n            if (t[1].equalsNumber(0)) {\n              factors.add(candidate.toSymbol());\n              return [t[0], candidate];\n            }\n          }\n\n          return null;\n        };\n\n        var cnst = poly.coeffs[0],\n            cfactors = core.Math2.ifactor(cnst),\n            lc = poly.lc(),\n            ltfactors = core.Math2.ifactor(lc),\n            subbed = poly.sub(base),\n            nfactors = __.Factor.mix(core.Math2.ifactor(subbed), subbed < 0),\n            cp = Math.ceil(poly.coeffs.length / 2),\n            lc_is_neg = lc.lessThan(0),\n            cnst_is_neg = cnst.lessThan(0);\n\n        ltfactors['1'] = 1;\n        cfactors['1'] = 1;\n\n        while (cp--) {\n          for (var x in ltfactors) {\n            for (var y in cfactors) {\n              for (var i = 0; i < nfactors.length; i++) {\n                var factor_found = check(x, y, nfactors[i], cp);\n\n                if (factor_found) {\n                  poly = factor_found[0];\n                  if (!core.Utils.isPrime(poly.sub(base))) poly = __.Factor.search(poly, factors);\n                  return poly;\n                } else if (!factor_found) {\n                  if (lc_is_neg && cnst_is_neg) factor_found = check(-x, -y, nfactors[i], cp);else if (lc_is_neg) factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\n                  else if (cnst_is_neg) factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\n                }\n              }\n            }\n          }\n        }\n\n        return poly;\n      },\n\n      /**\r\n       * Equivalent of square free factor for multivariate polynomials\r\n       * @param {type} symbol\r\n       * @param {type} factors\r\n       * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n       */\n      mSqfrFactor: function mSqfrFactor(symbol, factors) {\n        if (symbol.group !== FN) {\n          var vars = variables(symbol).reverse();\n\n          for (var i = 0; i < vars.length; i++) {\n            do {\n              if (vars[i] === symbol.value) {\n                //the derivative tells us nothing since this symbol is already the factor\n                factors.add(symbol);\n                symbol = new Symbol(1);\n                continue;\n              }\n\n              var diff = core.Calculus.diff(symbol, vars[i]);\n\n              var d = __.Factor.coeffFactor(diff);\n\n              if (d.equals(0)) break; //trial division to see if factors have whole numbers. \n              //This can be optimized by stopping as soon as can_divide is false\n              //this will also need utilize big number at some point\n\n              var can_divide = true;\n\n              if (d.isConstant() && symbol.isComposite()) {\n                //check the coefficients\n                symbol.each(function (x) {\n                  if (x.multiplier % d !== 0) can_divide = false;\n                }, true);\n              } //if we can divide then do so\n\n\n              if (can_divide) {\n                var div = __.div(symbol, d.clone()),\n                    is_factor = div[1].equals(0);\n\n                if (div[0].isConstant()) {\n                  factors.add(div[0]);\n                  break;\n                }\n              } else is_factor = false;\n\n              if (is_factor) {\n                factors.add(div[0]);\n                symbol = d;\n              }\n            } while (is_factor);\n          }\n        }\n\n        return symbol;\n      },\n      //difference of squares factorization\n      sqdiff: function sqdiff(symbol, factors) {\n        try {\n          var remove_square = function remove_square(x) {\n            return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n              return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\n            }, true);\n          };\n\n          var separated = core.Utils.separate(symbol.clone());\n          var obj_array = []; //get the unique variables\n\n          for (var x in separated) {\n            if (x !== 'constants') {\n              obj_array.push(separated[x]);\n            }\n          }\n\n          obj_array.sort(function (a, b) {\n            return b.power - a.power;\n          }); //if we have the same number of variables as unique variables then we can apply the difference of squares\n\n          if (obj_array.length === 2) {\n            var a, b;\n            a = obj_array.pop();\n            b = obj_array.pop();\n\n            if (a.isComposite() && b.power.equals(2)) {\n              //remove the square from b\n              b = remove_square(b);\n\n              var f = __.Factor.factor(_.add(a, separated.constants));\n\n              if (f.power.equals(2)) {\n                f.toLinear();\n                factors.add(_.subtract(f.clone(), b.clone()));\n                factors.add(_.add(f, b));\n                symbol = new Symbol(1);\n              }\n            } else {\n              a = a.powSimp();\n              b = b.powSimp();\n\n              if ((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2)) {\n                if (a.multiplier.lessThan(0)) {\n                  var t = b;\n                  b = a;\n                  a = t;\n                }\n\n                if (a.multiplier.greaterThan(0)) {\n                  a = remove_square(a);\n                  b = remove_square(b);\n                }\n\n                factors.add(_.subtract(a.clone(), b.clone()));\n                factors.add(_.add(a, b));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      //factoring for multivariate\n      mfactor: function mfactor(symbol, factors) {\n        if (symbol.group === FN) {\n          if (symbol.fname === 'sqrt') {\n            var factors2 = new Factors(),\n                arg = __.Factor.common(symbol.args[0].clone(), factors2);\n\n            arg = __.Factor.coeffFactor(arg, factors2);\n            symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\n            factors2.each(function (x) {\n              symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\n            });\n          } else factors.add(symbol);\n        } else {\n          //square free factorization\n          symbol = __.Factor.mSqfrFactor(symbol, factors); //try factor out common factors\n          //symbol = __.Factor.common(symbol, factors);\n\n          var vars = variables(symbol),\n              symbols = symbol.collectSymbols().map(function (x) {\n            return Symbol.unwrapSQRT(x);\n          }),\n              sorted = {},\n              maxes = {},\n              l = vars.length,\n              n = symbols.length; //take all the variables in the symbol and organize by variable name\n          //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\n\n          for (var i = 0; i < l; i++) {\n            var v = vars[i];\n            sorted[v] = new Symbol(0);\n\n            for (var j = 0; j < n; j++) {\n              var s = symbols[j];\n\n              if (s.contains(v)) {\n                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\n                if (!maxes[v] || p < maxes[v]) maxes[v] = p;\n                sorted[v] = _.add(sorted[v], s.clone());\n              }\n            }\n          }\n\n          for (var x in sorted) {\n            var r = _.parse(x + '^' + maxes[x]);\n\n            var div = _.divide(sorted[x], r);\n\n            var new_factor = _.expand(div);\n\n            if (new_factor.equals(1)) break; //why divide by one. Just move \n\n            var divided = __.div(symbol.clone(), new_factor);\n\n            if (divided[0].equals(0)) {\n              //cant factor anymore\n              break;\n            }\n\n            var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\n\n            if (divided[1].equals(0) && !neg_numeric_factor) {\n              //we found at least one factor\n              //factors.add(new_factor);\n              var d = __.div(symbol.clone(), divided[0].clone());\n\n              var r = d[0];\n              symbol = d[1]; //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\n              //and we just return the symbol;\n              //If r equals zero then there's nothing left to do so we're done\n\n              if (r.equals(-1) && !symbol.equals(0)) return symbol;\n              var factor = divided[0];\n\n              if (symbol.equals(factor)) {\n                var rem = __.Factor.reduce(factor, factors);\n\n                if (!symbol.equals(rem)) return __.Factor.mfactor(rem, factors);\n              } else {\n                factors.add(factor); //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\n\n                if (symbol.equals(0)) return r;\n              }\n\n              if (r.isConstant('all')) {\n                factors.add(r);\n                return r;\n              }\n\n              return __.Factor.mfactor(r, factors);\n            }\n          }\n        } //difference of squares factorization\n\n\n        symbol = __.Factor.sqdiff(symbol, factors); //factors by fishing for zeroes\n\n        symbol = __.Factor.zeroes(symbol, factors);\n        return symbol;\n      }\n    },\n\n    /**\r\n     * Checks to see if a set of \"equations\" is linear. \r\n     * @param {type} set\r\n     * @returns {Boolean}\r\n     */\n    allLinear: function allLinear(set) {\n      var l = set.length;\n\n      for (var i = 0; i < l; i++) {\n        if (!__.isLinear(set[i])) return false;\n      }\n\n      return true;\n    },\n\n    /*\r\n     * Checks to see if the \"equation\" is linear\r\n     * @param {Symbol} e\r\n     * @returns {boolean}\r\n     */\n    isLinear: function isLinear(e) {\n      var status = false,\n          g = e.group;\n\n      if (g === PL || g === CP) {\n        status = true;\n\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s],\n              sg = symbol.group;\n\n          if (sg === FN || sg === EX) {\n            status = false;\n          }\n\n          if (sg === CB) {\n            //needs further checking since it might be imaginary\n            status = variables(symbol).length === 1;\n          } else {\n            if (sg === PL || sg === CP) status = __.isLinear(symbol);else {\n              if (symbol.group !== N && symbol.power.toString() !== '1') {\n                status = false;\n                break;\n              }\n            }\n          }\n        }\n      } else if (g === S && e.power === 1) status = true;\n\n      return status;\n    },\n    gcd: function gcd() {\n      var args;\n      if (arguments.length === 1 && arguments[0] instanceof core.Vector) args = arguments[0].elements;else args = core.Utils.arguments2Array(arguments); //short-circuit early\n\n      if (args.length === 0) return new Symbol(1);else if (args.length === 1) return args[0];\n      var appeared = [],\n          evaluate = false;\n\n      for (var i = 0; i < args.length; i++) {\n        if (args[i].group === FN && args[i].fname === 'gcd') {\n          //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\n          args = args.concat(arguments[i].args); //do not keep gcd in args\n\n          args.splice(i, 1);\n        } else {\n          //Look if there are any common variables such that\n          //gcd(a,b) => gcd(a,b); gcd(a,a) => a\n          var vars = variables(args[i]);\n\n          if (core.Utils.haveIntersection(vars, appeared)) {\n            //Ok, there are common variables\n            evaluate = true;\n            break;\n          } else appeared = appeared.concat(vars);\n        }\n      } //appeared.length is 0 when all arguments are group N\n\n\n      if (evaluate || appeared.length === 0) {\n        //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\n        if (args.every(function (symbol) {\n          return symbol.getDenom().equals(1);\n        })) {\n          var aggregate = args[0];\n\n          for (var i = 1; i < args.length; i++) {\n            aggregate = __.gcd_(args[i], aggregate);\n          }\n\n          return aggregate;\n        } else {\n          //gcd_ cannot handle denominators correctly\n          return _.divide(__.gcd.apply(null, args.map(function (symbol) {\n            return symbol.getNum();\n          })), __.lcm.apply(null, args.map(function (symbol) {\n            return symbol.getDenom();\n          })));\n        }\n      } else return _.symfunction('gcd', args);\n    },\n    gcd_: function gcd_(a, b) {\n      if (a.group === FN || a.group === P) a = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(a);\n      });\n      if (b.group === FN) b = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(b);\n      });\n\n      if (a.isConstant() && b.isConstant()) {\n        // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\n        return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\n      }\n\n      var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\n\n      a = _.multiply(a.clone(), den.clone());\n      b = _.multiply(b.clone(), den.clone()); //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\n\n      a = _.expand(a);\n      b = _.expand(b);\n\n      if (a.group === CB || b.group === CB) {\n        var q = _.divide(a.clone(), b.clone()); //get the quotient\n\n\n        var t = _.multiply(b.clone(), q.getDenom().invert()); //multiply by the denominator\n        //if they have a common factor then the result will not equal one \n\n\n        if (!t.equals(1)) return t;\n      } //just take the gcd of each component when either of them is in group EX\n\n\n      if (a.group === EX || b.group === EX) {\n        var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\n\n        var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\n\n        var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\n\n        return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\n      }\n\n      if (a.length < b.length) {\n        //swap'm\n        var t = a;\n        a = b;\n        b = t;\n      }\n\n      var vars_a = variables(a),\n          vars_b = variables(b);\n\n      if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {\n        a = new Polynomial(a);\n        b = new Polynomial(b);\n        return _.divide(a.gcd(b).toSymbol(), den);\n      } else {\n        //get the gcd of the multipiers\n        //get rid of gcd in coeffs\n        var multipliers = [];\n        a.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        b.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        var T;\n\n        while (!b.equals(0)) {\n          var t = b.clone();\n          a = a.clone();\n          T = __.div(a, t);\n          b = T[1];\n\n          if (T[0].equals(0)) {\n            //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\n            return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\n          }\n\n          a = t;\n        }\n\n        var gcd = core.Math2.QGCD.apply(undefined, multipliers);\n\n        if (!gcd.equals(1)) {\n          a.each(function (x) {\n            x.multiplier = x.multiplier.divide(gcd);\n          });\n        } //return symbolic function for gcd in indeterminate form\n\n\n        if (a.equals(1) && !a.isConstant() && !b.isConstant()) return _.divide(_.symfunction('gcd', arguments), den);\n        return _.divide(a, den);\n      }\n    },\n    lcm: function lcm() {\n      //https://math.stackexchange.com/a/319310\n      //generalization of the 2-variable formula of lcm\n      var args;\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof core.Vector) args = arguments[0].elements;else _.error('lcm expects either 1 vector or 2 or more arguments');\n      } else args = core.Utils.arguments2Array(arguments); //product of all arguments\n      //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n\n      var numer = args.reduce(function (prev, curr) {\n        return _.multiply(prev, curr.clone());\n      }, new Symbol(1)); //gcd of complementary terms\n\n      var denom_args = //https://stackoverflow.com/a/18223072\n      //take all complementary terms, e.g.\n      //[a,b,c] => [a*b, b*c, a*c]\n      //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\n      function (input, size) {\n        var results = [],\n            result,\n            mask,\n            i,\n            total = Math.pow(2, input.length);\n\n        for (mask = size; mask < total; mask++) {\n          result = [];\n          i = input.length - 1;\n\n          do {\n            if ((mask & 1 << i) !== 0) {\n              result.push(input[i]);\n            }\n          } while (i--);\n\n          if (result.length == size) {\n            results.push(result);\n          }\n        }\n\n        return results; //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n      }(arguments, arguments.length - 1).map(function (x) {\n        return x.reduce(function (prev, curr) {\n          return _.multiply(prev, curr.clone());\n        }, new Symbol(1));\n      }); //don't eat the gcd term if all arguments are symbols\n\n\n      if (args.every(function (x) {\n        return core.Utils.isVariableSymbol(x);\n      })) var denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));else var denom = __.gcd.apply(null, denom_args); //divide product of all arguments by gcd of complementary terms\n\n      return _.divide(numer, denom);\n    },\n\n    /**\r\n     * Divides one expression by another\r\n     * @param {Symbol} symbol1\r\n     * @param {Symbol} symbol2\r\n     * @returns {Array}\r\n     */\n    divide: function divide(symbol1, symbol2) {\n      var result, remainder, factored, den;\n      factored = core.Algebra.Factor.factor(symbol1.clone());\n      den = factored.getDenom();\n\n      if (!den.isConstant('all')) {\n        symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\n      } else //reset the denominator since we're not dividing by it anymore\n        den = new Symbol(1);\n\n      result = __.div(symbol1, symbol2);\n      remainder = _.divide(result[1], symbol2);\n      return _.divide(_.add(result[0], remainder), den);\n    },\n    div: function div(symbol1, symbol2) {\n      //division by constants\n      if (symbol2.isConstant()) {\n        symbol1.each(function (x) {\n          x.multiplier = x.multiplier.divide(symbol2.multiplier);\n        });\n        return [symbol1, new Symbol(0)];\n      } //so that factorized symbols don't affect the result\n\n\n      symbol1 = _.expand(symbol1);\n      symbol2 = _.expand(symbol2); //special case. May need revisiting\n\n      if (symbol1.group === S && symbol2.group === CP) {\n        var x = symbol1.value;\n        var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\n\n        if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\n          var k = Symbol.create(symbol1.multiplier);\n          return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\n        }\n      }\n\n      if (symbol1.group === S && symbol2.group === S) {\n        var r = _.divide(symbol1.clone(), symbol2.clone());\n\n        if (r.isConstant()) //we have a whole\n          return [r, new Symbol(0)];\n        return [new Symbol(0), symbol1.clone()];\n      }\n\n      var symbol1_has_func = symbol1.hasFunc(),\n          symbol2_has_func = symbol2.hasFunc(),\n          parse_funcs = false; //substitute out functions so we can treat them as regular variables\n\n      if (symbol1_has_func || symbol2_has_func) {\n        parse_funcs = true;\n\n        var map = {},\n            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\n            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\n            subs = core.Utils.getFunctionsSubs(map);\n      } //get a list of the variables\n\n\n      var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\n          quot,\n          rem; //treat imaginary numbers as variables\n\n      if (symbol1.isImaginary() || symbol2.isImaginary()) {\n        vars.push(core.Settings.IMAGINARY);\n      }\n\n      if (vars.length === 1) {\n        var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\n        quot = q[0].toSymbol();\n        rem = q[1].toSymbol();\n      } else {\n        vars.push(CONST_HASH); //this is for the numbers\n\n        var reconvert = function reconvert(arr) {\n          var symbol = new Symbol(0);\n\n          for (var i = 0; i < arr.length; i++) {\n            var x = arr[i].toSymbol();\n            symbol = _.add(symbol, x);\n          }\n\n          return symbol;\n        }; //Silly Martin. This is why you document. I don't remember now\n\n\n        var get_unique_max = function get_unique_max(term, any) {\n          var max = Math.max.apply(null, term.terms),\n              count = 0,\n              idx;\n\n          if (!any) {\n            for (var i = 0; i < term.terms.length; i++) {\n              if (term.terms[i].equals(max)) {\n                idx = i;\n                count++;\n              }\n\n              if (count > 1) return;\n            }\n          }\n\n          if (any) {\n            for (i = 0; i < term.terms.length; i++) {\n              if (term.terms[i].equals(max)) {\n                idx = i;\n                break;\n              }\n            }\n          }\n\n          return [max, idx, term];\n        }; //tries to find an LT in the dividend that will satisfy division\n\n\n        var get_det = function get_det(s, lookat) {\n          lookat = lookat || 0;\n          var det = s[lookat],\n              l = s.length;\n          if (!det) return; //eliminate the first term if it doesn't apply\n\n          var umax = get_unique_max(det);\n\n          for (var i = lookat + 1; i < l; i++) {\n            var term = s[i],\n                is_equal = det.sum.equals(term.sum);\n\n            if (!is_equal && umax) {\n              break;\n            }\n\n            if (is_equal) {\n              //check the differences of their maxes. The one with the biggest difference governs\n              //e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\n              var max1,\n                  max2,\n                  idx1,\n                  idx2,\n                  l2 = det.terms.length;\n\n              for (var j = 0; j < l2; j++) {\n                var item1 = det.terms[j],\n                    item2 = term.terms[j];\n\n                if (typeof max1 === 'undefined' || item1.greaterThan(max1)) {\n                  max1 = item1;\n                  idx1 = j;\n                }\n\n                if (typeof max2 === 'undefined' || item2.greaterThan(max2)) {\n                  max2 = item2;\n                  idx2 = j;\n                }\n              } //check their differences\n\n\n              var d1 = max1.subtract(term.terms[idx1]),\n                  d2 = max2.subtract(det.terms[idx2]);\n\n              if (d2 > d1) {\n                umax = [max2, idx2, term];\n                break;\n              }\n\n              if (d1 > d2) {\n                umax = [max1, idx1, det];\n                break;\n              }\n            } else {\n              //check if it's a suitable pick to determine the order\n              umax = get_unique_max(term); //if(umax) return umax;\n\n              if (umax) break;\n            }\n\n            umax = get_unique_max(term); //calculate a new unique max\n          } //if still no umax then any will do since we have a tie\n\n\n          if (!umax) return get_unique_max(s[0], true);\n          var e, idx;\n\n          for (var i = 0; i < s2.length; i++) {\n            var cterm = s2[i].terms; //confirm that this is a good match for the denominator\n\n            idx = umax[1];\n            if (idx === cterm.length - 1) return;\n            e = cterm[idx];\n            if (!e.equals(0)) break;\n          }\n\n          if (e.equals(0)) return get_det(s, ++lookat); //look at the next term\n\n          return umax;\n        };\n\n        var t_map = core.Utils.toMapObj(vars);\n\n        var init_sort = function init_sort(a, b) {\n          return b.sum.subtract(a.sum);\n        };\n\n        var is_larger = function is_larger(a, b) {\n          if (!a || !b) return false; //it's empty so...\n\n          for (var i = 0; i < a.terms.length; i++) {\n            if (a.terms[i].lessThan(b.terms[i])) return false;\n          }\n\n          return true;\n        };\n\n        var s1 = symbol1.tBase(t_map).sort(init_sort),\n            s2 = symbol2.tBase(t_map).sort(init_sort);\n        var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\n\n        var det = get_det(target); //we'll begin by assuming that this will let us know which term \n\n        var quotient = [];\n\n        if (det) {\n          var lead_var = det[1];\n\n          var can_divide = function can_divide(a, b) {\n            if (a[0].sum.equals(b[0].sum)) return a.length >= b.length;\n            return true;\n          };\n\n          var try_better_lead_var = function try_better_lead_var(s1, s2, lead_var) {\n            var checked = [];\n\n            for (var i = 0; i < s1.length; i++) {\n              var t = s1[i];\n\n              for (var j = 0; j < t.terms.length; j++) {\n                var cf = checked[j],\n                    tt = t.terms[j];\n                if (i === 0) checked[j] = tt; //add the terms for the first one\n                else if (cf && !cf.equals(tt)) checked[j] = undefined;\n              }\n            }\n\n            for (var i = 0; i < checked.length; i++) {\n              var t = checked[i];\n              if (t && !t.equals(0)) return i;\n            }\n\n            return lead_var;\n          };\n\n          var sf = function sf(a, b) {\n            var l1 = a.len(),\n                l2 = b.len();\n            var blv = b.terms[lead_var],\n                alv = a.terms[lead_var];\n            if (l2 > l1 && blv.greaterThan(alv)) return l2 - l1;\n            return blv.subtract(alv);\n          }; //check to see if there's a better lead_var\n\n\n          lead_var = try_better_lead_var(s1, s2, lead_var); //reorder both according to the max power\n\n          s1.sort(sf); //sort them both according to the leading variable power\n\n          s2.sort(sf); //try to adjust if den is larger\n\n          var fdt = s2[0],\n              fnt = s1[0];\n          var den = new MVTerm(new Frac(1), [], fnt.map);\n\n          if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\n            for (var i = 0; i < fnt.terms.length; i++) {\n              var d = fdt.terms[i].subtract(fnt.terms[i]);\n\n              if (!d.equals(0)) {\n                var nd = d.add(new Frac(1));\n                den.terms[i] = d;\n\n                for (var j = 0; j < s1.length; j++) {\n                  s1[j].terms[i] = s1[j].terms[i].add(nd);\n                }\n              } else den.terms[i] = new Frac(0);\n            }\n          }\n\n          var dividend_larger = is_larger(s1[0], s2[0]);\n\n          while (dividend_larger && can_divide(s1, s2)) {\n            var q = s1[0].divide(s2[0]);\n            quotient.push(q); //add what's divided to the quotient\n\n            s1.shift(); //the first one is guaranteed to be gone so remove from dividend\n\n            for (var i = 1; i < s2.length; i++) {\n              //loop through the denominator\n              var t = s2[i].multiply(q).generateImage(),\n                  l2 = s1.length; //if we're subtracting from 0\n\n              if (l2 === 0) {\n                t.coeff = t.coeff.neg();\n                s1.push(t);\n                s1.sort(sf);\n              }\n\n              for (var j = 0; j < l2; j++) {\n                var cur = s1[j];\n\n                if (cur.getImg() === t.getImg()) {\n                  cur.coeff = cur.coeff.subtract(t.coeff);\n\n                  if (cur.coeff.equals(0)) {\n                    core.Utils.remove(s1, j);\n                    j--; //adjust the iterator\n                  }\n\n                  break;\n                }\n\n                if (j === l2 - 1) {\n                  t.coeff = t.coeff.neg();\n                  s1.push(t);\n                  s1.sort(sf);\n                }\n              }\n            }\n\n            dividend_larger = is_larger(s1[0], s2[0]);\n\n            if (!dividend_larger && s1.length >= s2.length) {\n              //One more try since there might be a terms that is larger than the LT of the divisor\n              for (var i = 1; i < s1.length; i++) {\n                dividend_larger = is_larger(s1[i], s2[0]);\n\n                if (dividend_larger) {\n                  //take it from its current position and move it to the front\n                  s1.unshift(core.Utils.remove(s1, i));\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        quot = reconvert(quotient);\n        rem = reconvert(s1);\n\n        if (typeof den !== 'undefined') {\n          den = den.toSymbol();\n          quot = _.divide(quot, den.clone());\n          rem = _.divide(rem, den);\n        }\n      } //put back the functions\n\n\n      if (parse_funcs) {\n        quot = _.parse(quot.text(), subs);\n        rem = _.parse(rem.text(), subs);\n      }\n\n      return [quot, rem];\n    },\n    line: function line(v1, v2, x) {\n      if (core.Utils.isArray(v1)) v1 = core.Utils.convertToVector(v1);\n      if (core.Utils.isArray(v2)) v2 = core.Utils.convertToVector(v2);\n      x = _.parse(x || 'x');\n      if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2)) _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\n\n      var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\n          dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\n          m = _.divide(dy, dx),\n          a = _.multiply(x, m.clone()),\n          b = _.multiply(v1.e(1).clone(), m);\n\n      return _.add(_.subtract(a, b), v1.e(2).clone());\n    },\n    PartFrac: {\n      createTemplate: function createTemplate(den, denom_factors, f_array, v) {\n        //clean up the denominator function by factors so it reduces nicely\n        den = __.Factor.factor(den); //clean up factors. This is so inefficient but factors are wrapped in parens for safety\n\n        den.each(function (x, key) {\n          if (x.group === FN && x.fname === '' && x.args[0].group === S) {\n            var y = x.args[0];\n\n            if (this.symbols) {\n              delete this.symbols[key];\n              this.symbols[y.value] = y;\n            } else {\n              den = x.args[0];\n            }\n          }\n        });\n        var factors, factors_vec, f, p, deg, degrees, m;\n        factors = denom_factors.collectFactors();\n        factors_vec = []; //a vector for the template\n\n        degrees = [];\n        m = new Symbol(1);\n\n        for (var i = 0; i < factors.length; i++) {\n          //loop through the factors\n          var factor = Symbol.unwrapPARENS(factors[i]); //if in he for P^n where P is polynomial and n = integer\n\n          if (factor.power.greaterThan(1)) {\n            p = Number(factor.power);\n            f = factor.clone().toLinear(); //remove the power so we have only the function\n\n            deg = Number(__.degree(f, v)); //get the degree of f\n            //expand the factor\n\n            for (var j = 0; j < p; j++) {\n              var efactor = _.pow(f.clone(), new Symbol(j + 1));\n\n              f_array.push(efactor.clone());\n\n              var d = _.divide(den.clone(), efactor.clone());\n\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n          }\n          /*\r\n          Possible bug.\r\n          Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n          else if(factor.isConstant('all')) {\r\n              m = _.multiply(m, factor);\r\n          }\r\n          */\n          else {\n              //get the degree of the factor so we tack it on tot he factor. This should probably be an array\n              //but for now we note it on the symbol\n              deg = Number(__.degree(factor, v));\n              f_array.push(factor);\n\n              var d = _.divide(den.clone(), factor.clone());\n\n              d = _.expand(Symbol.unwrapPARENS(d));\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n        } //put back the constant\n\n\n        f_array = f_array.map(function (x) {\n          return _.multiply(x, m.clone());\n        });\n        return [f_array, factors_vec, degrees];\n      },\n      partfrac: function partfrac(symbol, v, as_array) {\n        var vars = variables(symbol);\n        v = v || _.parse(vars[0]); //make wrt optional and assume first variable\n\n        try {\n          var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;\n          num = _.expand(symbol.getNum());\n          den = _.expand(symbol.getDenom().toUnitMultiplier()); //move the entire multipier to the numerator\n\n          num.multiplier = symbol.multiplier; //we only have a meaningful change if n factors > 1. This means that\n          //the returned group will be a CB\n          //collect the terms wrt the x\n\n          nterms = num.groupTerms(v); //divide out wholes if top is larger\n\n          if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\n            div = __.div(num.clone(), _.expand(den.clone()));\n            r = div[0]; //remove the wholes\n\n            num = div[1]; //work with the remainder\n\n            nterms = num.groupTerms(v); //recalculate the nterms\n          } else r = new Symbol(0);\n\n          if (Number(__.degree(den, v)) === 1) {\n            var q = _.divide(num, den);\n\n            if (as_array) return [r, q];\n            return _.add(r, q);\n          } //first factor the denominator. This means that the strength of this\n          //algorithm depends on how well we can factor the denominator. \n\n\n          ofactors = __.Factor.factor(den); //create the template. This method will create the template for solving \n          //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\n\n          template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\n          tfactors = template[0]; //grab the factors\n\n          factors_vec = template[1]; //grab the factor vectors\n\n          degrees = template[2]; //grab the degrees\n          //make note of the powers of each term\n\n          powers = [nterms.length]; //create the dterms vector\n\n          dterms = [];\n          factors = [];\n          ks = [];\n          var factor, deg;\n          factors_vec.map(function (x, idx) {\n            factor = tfactors[idx];\n            deg = degrees[idx];\n\n            for (var i = 0; i < deg; i++) {\n              factors.push(factor.clone());\n              var k = Symbol.create(v, i);\n\n              var t = _.expand(_.multiply(x, k.clone())).groupTerms(v); //make a note of the power which corresponds to the length of the array\n\n\n              var p = t.length;\n              powers.push(p);\n              dterms.push(t);\n              ks.push(k.clone());\n            }\n          }); //get the max power\n\n          max = core.Utils.arrayMax(powers); //fill the holes and create a matrix\n\n          c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose(); //for each of the factors we do the same\n\n          M = new core.Matrix();\n\n          for (var i = 0; i < dterms.length; i++) {\n            M.elements.push(core.Utils.fillHoles(dterms[i], max));\n          } //solve the system of equations\n\n\n          var partials = _.multiply(M.transpose().invert(), c); //the results are backwards to reverse it\n          //partials.elements.reverse();\n          //convert it all back\n\n\n          var retval = as_array ? [r] : r;\n          partials.each(function (e, i) {\n            var term = _.multiply(ks[i], _.divide(e, factors[i]));\n\n            if (as_array) retval.push(term);else retval = _.add(retval, term);\n          }); //done\n\n          return retval;\n        } catch (e) {}\n\n        ;\n        return symbol;\n      }\n    },\n    degree: function degree(symbol, v, o) {\n      o = o || {\n        nd: [],\n        //numeric\n        sd: [],\n        //symbolic\n        depth: 0 //call depth\n\n      };\n\n      if (!v) {\n        var vars = variables(symbol); //The user must specify the variable for multivariate\n\n        if (vars.length > 1) throw new Error('You must specify the variable for multivariate polynomials!'); //if it's empty then we're dealing with a constant\n\n        if (vars.length === 0) return new Symbol(0); //assume the variable for univariate\n\n        v = _.parse(vars[0]);\n      } //store the group\n\n\n      var g = symbol.group; //we're going to trust the user and assume no EX. Calling isPoly \n      //would eliminate this but no sense in checking twice. \n\n      if (symbol.isComposite()) {\n        symbol = symbol.clone();\n        symbol.distributeExponent();\n        symbol.each(function (x) {\n          o.depth++; //mark a depth increase\n\n          __.degree(x, v, o);\n\n          o.depth--; //we're back\n        });\n      } else if (symbol.group === CB) {\n        symbol.each(function (x) {\n          o.depth++;\n\n          __.degree(x, v, o);\n\n          o.depth++;\n        });\n      } else if (g === EX && symbol.value === v.value) {\n        o.sd.push(symbol.power.clone());\n      } else if (g === S && symbol.value === v.value) {\n        o.nd.push(_.parse(symbol.power));\n      } else o.nd.push(new Symbol(0)); //get the max out of the array\n\n\n      var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\n\n      if (o.depth === 0 && o.sd.length > 0) {\n        if (deg !== undefined) o.sd.unshift(deg);\n        return _.symfunction('max', o.sd);\n      }\n\n      if (!core.Utils.isSymbol(deg)) deg = _.parse(deg); //return the degree\n\n      return deg;\n    },\n\n    /**\r\n     * Attempts to complete the square of a polynomial\r\n     * @param {type} symbol\r\n     * @param {type} v\r\n     * @param {type} raw\r\n     * @throws {Error} \r\n     * @returns {Object|Symbol[]}\r\n     */\n    sqComplete: function sqComplete(symbol, v, raw) {\n      if (!core.Utils.isSymbol(v)) v = _.parse(v);\n\n      var stop = function stop(msg) {\n        msg = msg || 'Stopping';\n        throw new core.exceptions.ValueLimitExceededError(msg);\n      }; //if not CP then nothing to do\n\n\n      if (!symbol.isPoly()) stop('Must be a polynomial!'); //declare vars\n\n      var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\n      br = core.Utils.inBrackets; //make a copy\n\n      symbol = symbol.clone();\n      deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\n      //must be in form ax^2 +/- bx +/- c\n\n      if (!deg.equals(2)) stop('Cannot complete square for degree ' + deg); //get the coeffs\n\n      coeffs = core.Algebra.coeffs(symbol, v);\n      a = coeffs[2]; //store the sign\n\n      sign = coeffs[1].sign(); //divide the linear term by two and square it\n\n      b = _.divide(coeffs[1], new Symbol(2)); //add the difference to the constant\n\n      c = _.pow(b.clone(), new Symbol(2));\n      if (raw) return [a, b, d];\n      sqrt_a = math.sqrt(a);\n      e = _.divide(math.sqrt(c), sqrt_a.clone()); //calculate d which is the constant\n\n      d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2))); //compute the square part\n\n      sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\n      return {\n        a: sym,\n        c: d,\n        f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\n      };\n    },\n    Simplify: {\n      strip: function strip(symbol) {\n        var c = _.parse(symbol.multiplier);\n\n        symbol.toUnitMultiplier();\n\n        var p = _.parse(symbol.power);\n\n        symbol.toLinear();\n        return [c, p, symbol];\n      },\n      unstrip: function unstrip(cp, symbol) {\n        var c = cp[0];\n        var p = cp[1];\n        return _.multiply(c, _.pow(symbol, p));\n      },\n      complexSimp: function complexSimp(num, den) {\n        var ac, bd, bc, ad, cd, r1, r2, i1, i2;\n        r1 = num.realpart();\n        i1 = num.imagpart();\n        r2 = den.realpart();\n        i2 = den.imagpart(); //apply complex arithmatic rule\n\n        ac = _.multiply(r1.clone(), r2.clone());\n        bd = _.multiply(i1.clone(), i2.clone());\n        bc = _.multiply(r2.clone(), i1);\n        ad = _.multiply(r1, i2.clone());\n        cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\n        return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\n      },\n      trigSimp: function trigSimp(symbol) {\n        if (symbol.containsFunction(['cos', 'sin', 'tan'])) {\n          symbol = symbol.clone(); //remove power and multiplier\n\n          var sym_array = __.Simplify.strip(symbol);\n\n          symbol = sym_array.pop(); //the default return value is the symbol\n\n          var retval = symbol.clone(); //rewrite the symbol\n\n          if (symbol.group === CP) {\n            var sym = new Symbol(0);\n            symbol.each(function (x) {\n              //rewrite the function\n              var tr = __.Simplify.trigSimp(x.fnTransform());\n\n              sym = _.add(sym, tr);\n            }, true); //put back the power and multiplier and return\n\n            retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\n          } else if (symbol.group === CB) {\n            //try for tangent\n            var n = symbol.getNum();\n            var d = symbol.getDenom();\n\n            if (n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\n              retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\n            }\n\n            if (retval.group === CB) {\n              var t = new Symbol(1);\n              retval.each(function (x) {\n                if (x.fname === 'tan') {\n                  x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\n                }\n\n                t = _.multiply(t, x);\n              });\n              retval = t;\n            }\n          }\n\n          retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\n          symbol = retval;\n        }\n\n        return symbol;\n      },\n      fracSimp: function fracSimp(symbol) {\n        //try a quick simplify of imaginary numbers\n        var den = symbol.getDenom();\n        var num = symbol.getNum();\n        if (num.isImaginary() && den.isImaginary()) symbol = __.Simplify.complexSimp(num, den);\n\n        if (symbol.isComposite()) {\n          if (symbol.power > 1) {\n            symbol = _.expand(symbol);\n          }\n\n          var symbols = symbol.collectSymbols(); //assumption 1.\n          //since it's a composite, it has a length of at least 1\n\n          var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\n          a = symbols.pop(); //grab the first symbol\n          //loop through each term and make denominator common\n\n          while (symbols.length) {\n            b = symbols.pop(); //grab the second symbol\n\n            d1 = _.parse(a.getDenom());\n            d2 = _.parse(b.getDenom());\n            n1 = a.getNum();\n            n2 = b.getNum();\n            c = _.multiply(d1.clone(), d2.clone());\n            x = _.multiply(n1, d2);\n            y = _.multiply(n2, d1);\n            a = _.divide(_.add(x, y), c);\n          }\n\n          den = _.expand(a.getDenom());\n          num = _.expand(a.getNum()); //simplify imaginary\n\n          if (num.isImaginary() && den.isImaginary()) {\n            retval = __.Simplify.complexSimp(num, den);\n          } else {\n            retval = _.divide(num, den);\n          } //we've already hit the simplest form so return that\n\n\n          if (retval.equals(symbol)) {\n            return symbol;\n          } //otherwise simplify it some more\n\n\n          return __.Simplify.simplify(retval);\n        }\n\n        return symbol;\n      },\n      ratSimp: function ratSimp(symbol) {\n        if (symbol.group === CB) {\n          var den = __.Simplify.fracSimp(symbol.getDenom());\n\n          var num = __.Simplify.fracSimp(symbol.getNum());\n\n          symbol = _.divide(num, den);\n        }\n\n        return symbol;\n      },\n      simplify: function simplify(symbol) {\n        //remove the multiplier to make calculation easier;\n        var sym_array = __.Simplify.strip(symbol);\n\n        symbol = sym_array.pop(); //remove gcd from denominator\n\n        symbol = __.Simplify.fracSimp(symbol); //nothing more to do\n\n        if (symbol.isConstant() || symbol.group === core.groups.S) {\n          sym_array.push(symbol);\n\n          var ret = __.Simplify.unstrip(sym_array, symbol);\n\n          return ret;\n        }\n\n        var simplified;\n        symbol = symbol.clone(); //make a copy\n        ////1. Try cos(x)^2+sin(x)^2 \n\n        simplified = __.Simplify.trigSimp(symbol); //simplify common denominators\n\n        simplified = __.Simplify.ratSimp(simplified); //first go for the \"cheapest\" simplification which may eliminate \n        //your problems right away. factor -> evaluate. Remember\n        //that there's no need to expand since factor already does that\n\n        simplified = __.Factor.factor(simplified); //If the simplfied is a sum then we can make a few more simplifications\n        //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\n\n        if (simplified.group === core.groups.CP && simplified.isLinear()) {\n          var m = simplified.multiplier.clone();\n          simplified.toUnitMultiplier(); //strip the multiplier\n\n          var r = new Symbol(0); //return the sum of simplifications\n\n          simplified.each(function (x) {\n            var s = __.Simplify.simplify(x);\n\n            r = _.add(r, s);\n          });\n          simplified = r; //put back the multiplier\n\n          r.multiplier = r.multiplier.multiply(m);\n        } //place back multiplier and return\n\n\n        var retval = __.Simplify.unstrip(sym_array, evaluate(simplified));\n\n        return retval;\n      }\n    },\n    Classes: {\n      Polynomial: Polynomial,\n      Factors: Factors,\n      MVTerm: MVTerm\n    }\n  };\n\n  nerdamer.useAlgebraDiv = function () {\n    var divide = __.divideFn = _.divide;\n    var calls = 0; //keep track of how many calls were made\n\n    _.divide = function (a, b) {\n      calls++;\n      var ans;\n      if (calls === 1) //check if this is the first call. If it is use algebra divide\n        ans = core.Algebra.divide(a, b);else //otherwise use parser divide\n        ans = divide(a, b);\n      calls = 0; //reset the number of calls back to none\n\n      return ans;\n    };\n  };\n\n  nerdamer.useParserDiv = function () {\n    if (__.divideFn) _.divide = __.divideFn;\n    delete __.divideFn;\n  };\n\n  nerdamer.register([{\n    name: 'factor',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Factor.factor;\n    }\n  }, {\n    name: 'simplify',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Simplify.simplify;\n    }\n  }, {\n    name: 'gcd',\n    visible: true,\n    numargs: [1],\n    build: function build() {\n      return __.gcd;\n    }\n  }, {\n    name: 'lcm',\n    visible: true,\n    numargs: [1],\n    build: function build() {\n      return __.lcm;\n    }\n  }, {\n    name: 'roots',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.roots;\n    }\n  }, {\n    name: 'divide',\n    visible: true,\n    numargs: 2,\n    build: function build() {\n      return __.divide;\n    }\n  }, {\n    name: 'div',\n    visible: true,\n    numargs: 2,\n    build: function build() {\n      return __.div;\n    }\n  }, {\n    name: 'partfrac',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      return __.PartFrac.partfrac;\n    }\n  }, {\n    name: 'deg',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      return __.degree;\n    }\n  }, {\n    name: 'coeffs',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      var f = function f() {\n        var coeffs = __.coeffs.apply(__, arguments);\n\n        return new core.Vector(coeffs);\n      };\n\n      return f;\n    }\n  }, {\n    name: 'line',\n    visible: true,\n    numargs: [2, 3],\n    build: function build() {\n      return __.line;\n    }\n  }, {\n    name: 'sqcomp',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      var f = function f(x, v) {\n        try {\n          v = v || variables(x)[0];\n\n          var sq = __.sqComplete(x.clone(), v);\n\n          return sq.f;\n        } catch (e) {\n          return x;\n        }\n      };\n\n      return f;\n    }\n  }]);\n  nerdamer.api();\n})();","/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n * Can be used to load all add-ons with one require\r\n */\nvar nerdamer = require('./nerdamer.core.js');\n\nrequire('./Algebra.js');\n\nrequire('./Calculus.js');\n\nrequire('./Solve.js');\n\nrequire('./Extra.js'); //export nerdamer\n\n\nmodule.exports = nerdamer;"],"sourceRoot":""}