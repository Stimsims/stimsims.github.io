{"version":3,"sources":["webpack:///./.cache/emitter.js","webpack:///./.cache/react-lifecycles-compat.js","webpack:///./.cache/page-renderer.js","webpack:///./.cache/api-runner-browser-plugins.js","webpack:///./.cache/register-service-worker.js","webpack:///./.cache/route-announcer-props.js","webpack:///./.cache/navigation.js","webpack:///./.cache/ensure-resources.js","webpack:///./.cache/production-app.js","webpack:///./.cache/gatsby-browser-entry.js","webpack:///./.cache/strip-prefix.js","webpack:///./.cache/prefetch.js","webpack:///./.cache/normalize-page-path.js","webpack:///./.cache/find-path.js","webpack:///./.cache/loader.js","webpack:///./.cache/public-page-renderer.js","webpack:///./.cache/create-react-context.js","webpack:///./.cache/async-requires.js","webpack:///./.cache/public-page-renderer-prod.js","webpack:///./.cache/api-runner-browser.js"],"names":["emitter","mitt","exports","polyfill","Component","PageRenderer","render","props","this","pathContext","pageContext","pageElement","apiRunner","loader","publicLoader","createElement","pageResources","component","key","path","page","element","result","pop","React","module","plugin","require","options","window","location","protocol","hostname","console","error","navigator","serviceWorker","register","then","reg","addEventListener","installingWorker","installing","log","state","controller","___swUpdated","___failedResources","reload","catch","e","RouteAnnouncerProps","id","style","position","top","width","height","padding","overflow","clip","whiteSpace","border","redirectMap","redirects","reduce","map","redirect","fromPath","maybeRedirect","pathname","___replace","toPath","onPreRouteUpdate","prevLocation","onRouteUpdate","navigate","to","parsePath","timeoutId","setTimeout","emit","loadPage","status","PageResourceStatus","Error","history","replaceState","href","clearTimeout","webpackCompilationHash","___webpackCompilationHash","postMessage","gatsbyApi","reachNavigate","shouldUpdateScroll","prevRouterProps","hash","results","routerProps","getSavedScrollPosition","args","_stateStorage","read","length","decodeURI","slice","RouteAnnouncer","announcementRef","createRef","componentDidUpdate","prevProps","nextProps","requestAnimationFrame","pageName","document","title","pageHeadings","querySelectorAll","textContent","newAnnouncement","current","innerText","ref","RouteUpdates","componentDidMount","prevState","shouldFireRouteUpdate","getSnapshotBeforeUpdate","Fragment","children","EnsureResources","loadPageSync","getDerivedStateFromProps","loadResources","rawPath","setState","shouldComponentUpdate","nextState","json","matchPath","shallowCompare","ProdLoader","asyncRequires","matchPaths","setLoader","setApiRunner","___emitter","___loader","globalHistory","listen","action","___push","replace","___navigate","apiRunnerAsync","RouteHandler","Provider","value","baseuri","basepath","LocationHandler","__BASE_PATH__","stripPrefix","encodeURI","pagePath","browserLoc","findMatchPath","match","search","Root","locationContext","WrappedRoot","NewRoot","renderer","undefined","ReactDOM","hydrate","domReady","getElementById","prefetchPathname","enqueue","StaticQueryContext","createContext","StaticQueryDataRenderer","staticQueryData","data","query","finalData","StaticQuery","Consumer","useStaticQuery","useContext","context","isNaN","Number","graphql","str","prefix","substr","supportedPrefetchStrategy","feature","fakeLink","relList","supports","err","support","url","Promise","resolve","reject","link","setAttribute","Object","keys","forEach","onload","onerror","getElementsByTagName","getElementsByName","parentNode","appendChild","req","XMLHttpRequest","open","send","preFetched","prefetch","charAt","pathCache","Map","trimPathname","rawPathname","decodeURIComponent","split","trimmedPathname","cleanPath","normalizePagePath","findPath","has","get","foundPath","set","instance","Success","preferDefault","m","default","createPageDataUrl","s","endsWith","doFetch","method","onreadystatechange","readyState","loadPageDataJson","loadObj","retries","responseText","jsonPayload","JSON","parse","assign","payload","notFound","toPageResources","pageData","componentChunkName","BaseLoader","loadComponent","pageDb","inFlightDb","pageDataDb","prefetchTriggered","Set","prefetchCompleted","prefetchDisabled","some","a","inFlight","all","loadAppData","allData","finalResult","createdAt","Date","response","delete","shouldPrefetch","connection","effectiveType","includes","saveData","doesConnectionSupportPrefetch","add","realPath","doPrefetch","hovering","getResourceURLsForPathname","createComponentUrls","isPageNotFound","appData","___chunkMapping","chunk","__PATH_PREFIX__","chunkName","components","pageDataUrl","prefetchHelper","crossOrigin","as","componentUrls","_loader","getResourcesForPathname","warn","i","getResourcesForPathnameSync","ProdPageRenderer","InternalPageRenderer","plugins","api","defaultReturn","argTransform","filter","previous","next"],"mappings":"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","file":"app-285c491d206d712b67c3.js","sourcesContent":["import mitt from \"mitt\"\n\nconst emitter = mitt()\nexport default emitter\n","exports.polyfill = Component => Component\n","import React, { createElement } from \"react\"\nimport PropTypes from \"prop-types\"\nimport { publicLoader } from \"./loader\"\nimport { apiRunner } from \"./api-runner-browser\"\n\n// Renders page\nclass PageRenderer extends React.Component {\n  render() {\n    const props = {\n      ...this.props,\n      pathContext: this.props.pageContext,\n    }\n\n    const [replacementElement] = apiRunner(`replaceComponentRenderer`, {\n      props: this.props,\n      loader: publicLoader,\n    })\n\n    const pageElement =\n      replacementElement ||\n      createElement(this.props.pageResources.component, {\n        ...props,\n        key: this.props.path || this.props.pageResources.page.path,\n      })\n\n    const wrappedPage = apiRunner(\n      `wrapPageElement`,\n      { element: pageElement, props },\n      pageElement,\n      ({ result }) => {\n        return { element: result, props }\n      }\n    ).pop()\n\n    return wrappedPage\n  }\n}\n\nPageRenderer.propTypes = {\n  location: PropTypes.object.isRequired,\n  pageResources: PropTypes.object.isRequired,\n  data: PropTypes.object,\n  pageContext: PropTypes.object.isRequired,\n}\n\nexport default PageRenderer\n","module.exports = [{\n      plugin: require('../node_modules/gatsby-plugin-twitter/gatsby-browser.js'),\n      options: {\"plugins\":[]},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-catch-links/gatsby-browser.js'),\n      options: {\"plugins\":[]},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-layout/gatsby-browser.js'),\n      options: {\"plugins\":[],\"component\":\"D:\\\\websites\\\\Mathstims\\\\mathstims\\\\src\\\\mycomponents\\\\views\\\\Website\\\\Shell\\\\index.js\"},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-typography/gatsby-browser.js'),\n      options: {\"plugins\":[],\"pathToConfigModule\":\"src/mycomponents/assets/fonts/typography.js\",\"omitGoogleFont\":true},\n    },{\n      plugin: require('../node_modules/gatsby-remark-images/gatsby-browser.js'),\n      options: {\"plugins\":[],\"maxWidth\":900},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-google-gtag/gatsby-browser.js'),\n      options: {\"plugins\":[],\"trackingIds\":[],\"gtagConfig\":{\"anonymize_ip\":true,\"cookie_expires\":0},\"pluginConfig\":{\"head\":true,\"respectDNT\":true}},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-manifest/gatsby-browser.js'),\n      options: {\"plugins\":[],\"name\":\"Stimsims\",\"short_name\":\"Stimsims\",\"description\":\"Experimenting in data driven, open ended math games\",\"categories\":[\"education\",\"entertainment\",\"games\"],\"dir\":\"ltr\",\"start_url\":\".\",\"background_color\":\"#1C0857\",\"theme_color\":\"#3A2088\",\"display\":\"fullscreen\",\"orientation\":\"portrait-primary\",\"lang\":\"en-US\",\"icon\":\"src/mycomponents/assets/images/website/favicon.png\"},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-offline/gatsby-browser.js'),\n      options: {\"plugins\":[],\"offlineGoogleAnalytics\":true,\"debug\":false,\"workboxConfig\":{\"runtimeCaching\":[{\"urlPattern\":{},\"handler\":\"networkOnly\"}]}},\n    },{\n      plugin: require('../node_modules/gatsby-plugin-netlify-cms/gatsby-browser.js'),\n      options: {\"plugins\":[],\"modulePath\":\"D:\\\\websites\\\\Mathstims\\\\mathstims/src/cms/cms.js\"},\n    },{\n      plugin: require('../gatsby-browser.js'),\n      options: {\"plugins\":[]},\n    }]\n","import { apiRunner } from \"./api-runner-browser\"\n\nif (\n  window.location.protocol !== `https:` &&\n  window.location.hostname !== `localhost`\n) {\n  console.error(\n    `Service workers can only be used over HTTPS, or on localhost for development`\n  )\n} else if (`serviceWorker` in navigator) {\n  navigator.serviceWorker\n    .register(`${__BASE_PATH__}/sw.js`)\n    .then(function (reg) {\n      reg.addEventListener(`updatefound`, () => {\n        apiRunner(`onServiceWorkerUpdateFound`, { serviceWorker: reg })\n        // The updatefound event implies that reg.installing is set; see\n        // https://w3c.github.io/ServiceWorker/#service-worker-registration-updatefound-event\n        const installingWorker = reg.installing\n        console.log(`installingWorker`, installingWorker)\n        installingWorker.addEventListener(`statechange`, () => {\n          switch (installingWorker.state) {\n            case `installed`:\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and the fresh content will\n                // have been added to the cache.\n\n                // We set a flag so Gatsby Link knows to refresh the page on next navigation attempt\n                window.___swUpdated = true\n                // We call the onServiceWorkerUpdateReady API so users can show update prompts.\n                apiRunner(`onServiceWorkerUpdateReady`, { serviceWorker: reg })\n\n                // If resources failed for the current page, reload.\n                if (window.___failedResources) {\n                  console.log(`resources failed, SW updated - reloading`)\n                  window.location.reload()\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a \"Content is cached for offline use.\" message.\n                console.log(`Content is now available offline!`)\n\n                // Post to service worker that install is complete.\n                // Delay to allow time for the event listener to be added --\n                // otherwise fetch is called too soon and resources aren't cached.\n                apiRunner(`onServiceWorkerInstalled`, { serviceWorker: reg })\n              }\n              break\n\n            case `redundant`:\n              console.error(`The installing service worker became redundant.`)\n              apiRunner(`onServiceWorkerRedundant`, { serviceWorker: reg })\n              break\n\n            case `activated`:\n              apiRunner(`onServiceWorkerActive`, { serviceWorker: reg })\n              break\n          }\n        })\n      })\n    })\n    .catch(function (e) {\n      console.error(`Error during service worker registration:`, e)\n    })\n}\n","// This is extracted to separate module because it's shared\n// between browser and SSR code\nexport const RouteAnnouncerProps = {\n  id: `gatsby-announcer`,\n  style: {\n    position: `absolute`,\n    top: 0,\n    width: 1,\n    height: 1,\n    padding: 0,\n    overflow: `hidden`,\n    clip: `rect(0, 0, 0, 0)`,\n    whiteSpace: `nowrap`,\n    border: 0,\n  },\n  \"aria-live\": `assertive`,\n  \"aria-atomic\": `true`,\n}\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport redirects from \"./redirects.json\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport emitter from \"./emitter\"\nimport { RouteAnnouncerProps } from \"./route-announcer-props\"\nimport { navigate as reachNavigate } from \"@reach/router\"\nimport { globalHistory } from \"@reach/router/lib/history\"\nimport { parsePath } from \"gatsby-link\"\n\n// Convert to a map for faster lookup in maybeRedirect()\nconst redirectMap = redirects.reduce((map, redirect) => {\n  map[redirect.fromPath] = redirect\n  return map\n}, {})\n\nfunction maybeRedirect(pathname) {\n  const redirect = redirectMap[pathname]\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== `production`) {\n      const pageResources = loader.loadPageSync(pathname)\n\n      if (pageResources != null) {\n        console.error(\n          `The route \"${pathname}\" matches both a page and a redirect; this is probably not intentional.`\n        )\n      }\n    }\n\n    window.___replace(redirect.toPath)\n    return true\n  } else {\n    return false\n  }\n}\n\nconst onPreRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onPreRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst onRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst navigate = (to, options = {}) => {\n  let { pathname } = parsePath(to)\n  const redirect = redirectMap[pathname]\n\n  // If we're redirecting, just replace the passed in pathname\n  // to the one we want to redirect to.\n  if (redirect) {\n    to = redirect.toPath\n    pathname = parsePath(to).pathname\n  }\n\n  // If we had a service worker update, no matter the path, reload window and\n  // reset the pathname whitelist\n  if (window.___swUpdated) {\n    window.location = pathname\n    return\n  }\n\n  // Start a timer to wait for a second before transitioning and showing a\n  // loader in case resources aren't around yet.\n  const timeoutId = setTimeout(() => {\n    emitter.emit(`onDelayedLoadPageResources`, { pathname })\n    apiRunner(`onRouteUpdateDelayed`, {\n      location: window.location,\n    })\n  }, 1000)\n\n  loader.loadPage(pathname).then(pageResources => {\n    // If no page resources, then refresh the page\n    // Do this, rather than simply `window.location.reload()`, so that\n    // pressing the back/forward buttons work - otherwise when pressing\n    // back, the browser will just change the URL and expect JS to handle\n    // the change, which won't always work since it might not be a Gatsby\n    // page.\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, ``, location.href)\n      window.location = pathname\n      clearTimeout(timeoutId)\n      return\n    }\n\n    // If the loaded page has a different compilation hash to the\n    // window, then a rebuild has occurred on the server. Reload.\n    if (process.env.NODE_ENV === `production` && pageResources) {\n      if (\n        pageResources.page.webpackCompilationHash !==\n        window.___webpackCompilationHash\n      ) {\n        // Purge plugin-offline cache\n        if (\n          `serviceWorker` in navigator &&\n          navigator.serviceWorker.controller !== null &&\n          navigator.serviceWorker.controller.state === `activated`\n        ) {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: `clearPathResources`,\n          })\n        }\n\n        console.log(`Site has changed on server. Reloading browser`)\n        window.location = pathname\n      }\n    }\n    reachNavigate(to, options)\n    clearTimeout(timeoutId)\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location }) {\n  const { pathname, hash } = location\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    // `pathname` for backwards compatibility\n    pathname,\n    routerProps: { location },\n    getSavedScrollPosition: args => this._stateStorage.read(args),\n  })\n  if (results.length > 0) {\n    // Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration\n    // @see https://github.com/gatsbyjs/gatsby/issues/12038\n    return results[results.length - 1]\n  }\n\n  if (prevRouterProps) {\n    const {\n      location: { pathname: oldPathname },\n    } = prevRouterProps\n    if (oldPathname === pathname) {\n      // Scroll to element if it exists, if it doesn't, or no hash is provided,\n      // scroll to top.\n      return hash ? decodeURI(hash.slice(1)) : [0, 0]\n    }\n  }\n  return true\n}\n\nfunction init() {\n  // The \"scroll-behavior\" package expects the \"action\" to be on the location\n  // object so let's copy it over.\n  globalHistory.listen(args => {\n    args.location.action = args.action\n  })\n\n  window.___push = to => navigate(to, { replace: false })\n  window.___replace = to => navigate(to, { replace: true })\n  window.___navigate = (to, options) => navigate(to, options)\n\n  // Check for initial page-load redirect\n  maybeRedirect(window.location.pathname)\n}\n\nclass RouteAnnouncer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.announcementRef = React.createRef()\n  }\n\n  componentDidUpdate(prevProps, nextProps) {\n    requestAnimationFrame(() => {\n      let pageName = `new page at ${this.props.location.pathname}`\n      if (document.title) {\n        pageName = document.title\n      }\n      const pageHeadings = document.querySelectorAll(`#gatsby-focus-wrapper h1`)\n      if (pageHeadings && pageHeadings.length) {\n        pageName = pageHeadings[0].textContent\n      }\n      const newAnnouncement = `Navigated to ${pageName}`\n      const oldAnnouncement = this.announcementRef.current.innerText\n      if (oldAnnouncement !== newAnnouncement) {\n        this.announcementRef.current.innerText = newAnnouncement\n      }\n    })\n  }\n\n  render() {\n    return <div {...RouteAnnouncerProps} ref={this.announcementRef}></div>\n  }\n}\n\n// Fire on(Pre)RouteUpdate APIs\nclass RouteUpdates extends React.Component {\n  constructor(props) {\n    super(props)\n    onPreRouteUpdate(props.location, null)\n  }\n\n  componentDidMount() {\n    onRouteUpdate(this.props.location, null)\n  }\n\n  componentDidUpdate(prevProps, prevState, shouldFireRouteUpdate) {\n    if (shouldFireRouteUpdate) {\n      onRouteUpdate(this.props.location, prevProps.location)\n    }\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      onPreRouteUpdate(this.props.location, prevProps.location)\n      return true\n    }\n\n    return false\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.props.children}\n        <RouteAnnouncer location={location} />\n      </React.Fragment>\n    )\n  }\n}\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired,\n}\n\nexport { init, shouldUpdateScroll, RouteUpdates }\n","import React from \"react\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport shallowCompare from \"shallow-compare\"\n\nclass EnsureResources extends React.Component {\n  constructor(props) {\n    super()\n    const { location, pageResources } = props\n    this.state = {\n      location: { ...location },\n      pageResources: pageResources || loader.loadPageSync(location.pathname),\n    }\n  }\n\n  static getDerivedStateFromProps({ location }, prevState) {\n    if (prevState.location.href !== location.href) {\n      const pageResources = loader.loadPageSync(location.pathname)\n      return {\n        pageResources,\n        location: { ...location },\n      }\n    }\n\n    return {\n      location: { ...location },\n    }\n  }\n\n  loadResources(rawPath) {\n    loader.loadPage(rawPath).then(pageResources => {\n      if (pageResources && pageResources.status !== PageResourceStatus.Error) {\n        this.setState({\n          location: { ...window.location },\n          pageResources,\n        })\n      } else {\n        window.history.replaceState({}, ``, location.href)\n        window.location = rawPath\n      }\n    })\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Always return false if we're missing resources.\n    if (!nextState.pageResources) {\n      this.loadResources(nextProps.location.pathname)\n      return false\n    }\n\n    // Check if the component or json have changed.\n    if (this.state.pageResources !== nextState.pageResources) {\n      return true\n    }\n    if (\n      this.state.pageResources.component !== nextState.pageResources.component\n    ) {\n      return true\n    }\n\n    if (this.state.pageResources.json !== nextState.pageResources.json) {\n      return true\n    }\n    // Check if location has changed on a page using internal routing\n    // via matchPath configuration.\n    if (\n      this.state.location.key !== nextState.location.key &&\n      nextState.pageResources.page &&\n      (nextState.pageResources.page.matchPath ||\n        nextState.pageResources.page.path)\n    ) {\n      return true\n    }\n    return shallowCompare(this, nextProps, nextState)\n  }\n\n  render() {\n    if (process.env.NODE_ENV !== `production` && !this.state.pageResources) {\n      throw new Error(\n        `EnsureResources was not able to find resources for path: \"${this.props.location.pathname}\"\nThis typically means that an issue occurred building components for that path.\nRun \\`gatsby clean\\` to remove any cached elements.`\n      )\n    }\n\n    return this.props.children(this.state)\n  }\n}\n\nexport default EnsureResources\n","import { apiRunner, apiRunnerAsync } from \"./api-runner-browser\"\nimport React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { Router, navigate, Location, BaseContext } from \"@reach/router\"\nimport { ScrollContext } from \"gatsby-react-router-scroll\"\nimport domReady from \"@mikaelkristiansson/domready\"\nimport {\n  shouldUpdateScroll,\n  init as navigationInit,\n  RouteUpdates,\n} from \"./navigation\"\nimport emitter from \"./emitter\"\nimport PageRenderer from \"./page-renderer\"\nimport asyncRequires from \"./async-requires\"\nimport {\n  setLoader,\n  ProdLoader,\n  publicLoader,\n  PageResourceStatus,\n} from \"./loader\"\nimport EnsureResources from \"./ensure-resources\"\nimport stripPrefix from \"./strip-prefix\"\n\n// Generated during bootstrap\nimport matchPaths from \"./match-paths.json\"\n\nconst loader = new ProdLoader(asyncRequires, matchPaths)\nsetLoader(loader)\nloader.setApiRunner(apiRunner)\n\nwindow.asyncRequires = asyncRequires\nwindow.___emitter = emitter\nwindow.___loader = publicLoader\n\nnavigationInit()\n\napiRunnerAsync(`onClientEntry`).then(() => {\n  // Let plugins register a service worker. The plugin just needs\n  // to return true.\n  if (apiRunner(`registerServiceWorker`).length > 0) {\n    require(`./register-service-worker`)\n  }\n\n  // In gatsby v2 if Router is used in page using matchPaths\n  // paths need to contain full path.\n  // For example:\n  //   - page have `/app/*` matchPath\n  //   - inside template user needs to use `/app/xyz` as path\n  // Resetting `basepath`/`baseuri` keeps current behaviour\n  // to not introduce breaking change.\n  // Remove this in v3\n  const RouteHandler = props => (\n    <BaseContext.Provider\n      value={{\n        baseuri: `/`,\n        basepath: `/`,\n      }}\n    >\n      <PageRenderer {...props} />\n    </BaseContext.Provider>\n  )\n\n  class LocationHandler extends React.Component {\n    render() {\n      const { location } = this.props\n      return (\n        <EnsureResources location={location}>\n          {({ pageResources, location }) => (\n            <RouteUpdates location={location}>\n              <ScrollContext\n                location={location}\n                shouldUpdateScroll={shouldUpdateScroll}\n              >\n                <Router\n                  basepath={__BASE_PATH__}\n                  location={location}\n                  id=\"gatsby-focus-wrapper\"\n                >\n                  <RouteHandler\n                    path={\n                      pageResources.page.path === `/404.html`\n                        ? stripPrefix(location.pathname, __BASE_PATH__)\n                        : encodeURI(\n                            pageResources.page.matchPath ||\n                              pageResources.page.path\n                          )\n                    }\n                    {...this.props}\n                    location={location}\n                    pageResources={pageResources}\n                    {...pageResources.json}\n                  />\n                </Router>\n              </ScrollContext>\n            </RouteUpdates>\n          )}\n        </EnsureResources>\n      )\n    }\n  }\n\n  const { pagePath, location: browserLoc } = window\n\n  // Explicitly call navigate if the canonical path (window.pagePath)\n  // is different to the browser path (window.location.pathname). But\n  // only if NONE of the following conditions hold:\n  //\n  // - The url matches a client side route (page.matchPath)\n  // - it's a 404 page\n  // - it's the offline plugin shell (/offline-plugin-app-shell-fallback/)\n  if (\n    pagePath &&\n    __BASE_PATH__ + pagePath !== browserLoc.pathname &&\n    !(\n      loader.findMatchPath(stripPrefix(browserLoc.pathname, __BASE_PATH__)) ||\n      pagePath === `/404.html` ||\n      pagePath.match(/^\\/404\\/?$/) ||\n      pagePath.match(/^\\/offline-plugin-app-shell-fallback\\/?$/)\n    )\n  ) {\n    navigate(__BASE_PATH__ + pagePath + browserLoc.search + browserLoc.hash, {\n      replace: true,\n    })\n  }\n\n  publicLoader.loadPage(browserLoc.pathname).then(page => {\n    if (!page || page.status === PageResourceStatus.Error) {\n      throw new Error(\n        `page resources for ${browserLoc.pathname} not found. Not rendering React`\n      )\n    }\n\n    window.___webpackCompilationHash = page.page.webpackCompilationHash\n\n    const Root = () => (\n      <Location>\n        {locationContext => <LocationHandler {...locationContext} />}\n      </Location>\n    )\n\n    const WrappedRoot = apiRunner(\n      `wrapRootElement`,\n      { element: <Root /> },\n      <Root />,\n      ({ result }) => {\n        return { element: result }\n      }\n    ).pop()\n\n    const NewRoot = () => WrappedRoot\n\n    const renderer = apiRunner(\n      `replaceHydrateFunction`,\n      undefined,\n      ReactDOM.hydrate\n    )[0]\n\n    domReady(() => {\n      renderer(\n        <NewRoot />,\n        typeof window !== `undefined`\n          ? document.getElementById(`___gatsby`)\n          : void 0,\n        () => {\n          apiRunner(`onInitialClientRender`)\n        }\n      )\n    })\n  })\n})\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport Link, {\n  withPrefix,\n  withAssetPrefix,\n  navigate,\n  push,\n  replace,\n  navigateTo,\n  parsePath,\n} from \"gatsby-link\"\nimport PageRenderer from \"./public-page-renderer\"\nimport loader from \"./loader\"\n\nconst prefetchPathname = loader.enqueue\n\nconst StaticQueryContext = React.createContext({})\n\nfunction StaticQueryDataRenderer({ staticQueryData, data, query, render }) {\n  const finalData = data\n    ? data.data\n    : staticQueryData[query] && staticQueryData[query].data\n\n  return (\n    <React.Fragment>\n      {finalData && render(finalData)}\n      {!finalData && <div>Loading (StaticQuery)</div>}\n    </React.Fragment>\n  )\n}\n\nconst StaticQuery = props => {\n  const { data, query, render, children } = props\n\n  return (\n    <StaticQueryContext.Consumer>\n      {staticQueryData => (\n        <StaticQueryDataRenderer\n          data={data}\n          query={query}\n          render={render || children}\n          staticQueryData={staticQueryData}\n        />\n      )}\n    </StaticQueryContext.Consumer>\n  )\n}\n\nconst useStaticQuery = query => {\n  if (\n    typeof React.useContext !== `function` &&\n    process.env.NODE_ENV === `development`\n  ) {\n    throw new Error(\n      `You're likely using a version of React that doesn't support Hooks\\n` +\n        `Please update React and ReactDOM to 16.8.0 or later to use the useStaticQuery hook.`\n    )\n  }\n  const context = React.useContext(StaticQueryContext)\n\n  // query is a stringified number like `3303882` when wrapped with graphql, If a user forgets\n  // to wrap the query in a grqphql, then casting it to a Number results in `NaN` allowing us to\n  // catch the misuse of the API and give proper direction\n  if (isNaN(Number(query))) {\n    throw new Error(`useStaticQuery was called with a string but expects to be called using \\`graphql\\`. Try this:\n\nimport { useStaticQuery, graphql } from 'gatsby';\n\nuseStaticQuery(graphql\\`${query}\\`);\n`)\n  }\n\n  if (context[query] && context[query].data) {\n    return context[query].data\n  } else {\n    throw new Error(\n      `The result of this StaticQuery could not be fetched.\\n\\n` +\n        `This is likely a bug in Gatsby and if refreshing the page does not fix it, ` +\n        `please open an issue in https://github.com/gatsbyjs/gatsby/issues`\n    )\n  }\n}\n\nStaticQuery.propTypes = {\n  data: PropTypes.object,\n  query: PropTypes.string.isRequired,\n  render: PropTypes.func,\n  children: PropTypes.func,\n}\n\nfunction graphql() {\n  throw new Error(\n    `It appears like Gatsby is misconfigured. Gatsby related \\`graphql\\` calls ` +\n      `are supposed to only be evaluated at compile time, and then compiled away. ` +\n      `Unfortunately, something went wrong and the query was left in the compiled code.\\n\\n` +\n      `Unless your site has a complex or custom babel/Gatsby configuration this is likely a bug in Gatsby.`\n  )\n}\n\nexport {\n  Link,\n  withAssetPrefix,\n  withPrefix,\n  graphql,\n  parsePath,\n  navigate,\n  push, // TODO replace for v3\n  replace, // TODO remove replace for v3\n  navigateTo, // TODO: remove navigateTo for v3\n  StaticQueryContext,\n  StaticQuery,\n  PageRenderer,\n  useStaticQuery,\n  prefetchPathname,\n}\n","/**\n * Remove a prefix from a string. Return the input string if the given prefix\n * isn't found.\n */\n\nexport default (str, prefix = ``) => {\n  if (!prefix) {\n    return str\n  }\n\n  prefix += `/`\n\n  if (str.substr(0, prefix.length) === prefix) {\n    return str.slice(prefix.length - 1)\n  }\n\n  return str\n}\n","const support = function (feature) {\n  if (typeof document === `undefined`) {\n    return false\n  }\n  const fakeLink = document.createElement(`link`)\n  try {\n    if (fakeLink.relList && typeof fakeLink.relList.supports === `function`) {\n      return fakeLink.relList.supports(feature)\n    }\n  } catch (err) {\n    return false\n  }\n  return false\n}\n\nconst linkPrefetchStrategy = function (url, options) {\n  return new Promise((resolve, reject) => {\n    if (typeof document === `undefined`) {\n      reject()\n      return\n    }\n\n    const link = document.createElement(`link`)\n    link.setAttribute(`rel`, `prefetch`)\n    link.setAttribute(`href`, url)\n\n    Object.keys(options).forEach(key => {\n      link.setAttribute(key, options[key])\n    })\n\n    link.onload = resolve\n    link.onerror = reject\n\n    const parentElement =\n      document.getElementsByTagName(`head`)[0] ||\n      document.getElementsByName(`script`)[0].parentNode\n    parentElement.appendChild(link)\n  })\n}\n\nconst xhrPrefetchStrategy = function (url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(`GET`, url, true)\n\n    req.onload = () => {\n      if (req.status === 200) {\n        resolve()\n      } else {\n        reject()\n      }\n    }\n\n    req.send(null)\n  })\n}\n\nconst supportedPrefetchStrategy = support(`prefetch`)\n  ? linkPrefetchStrategy\n  : xhrPrefetchStrategy\n\nconst preFetched = {}\n\nconst prefetch = function (url, options) {\n  return new Promise(resolve => {\n    if (preFetched[url]) {\n      resolve()\n      return\n    }\n\n    supportedPrefetchStrategy(url, options)\n      .then(() => {\n        resolve()\n        preFetched[url] = true\n      })\n      .catch(() => {}) // 404s are logged to the console anyway\n  })\n}\n\nexport default prefetch\n","export default path => {\n  if (path === undefined) {\n    return path\n  }\n  if (path === `/`) {\n    return `/`\n  }\n  if (path.charAt(path.length - 1) === `/`) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n","import { match } from \"@reach/router/lib/utils\"\nimport stripPrefix from \"./strip-prefix\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nconst pathCache = new Map()\nlet matchPaths = []\n\nconst trimPathname = rawPathname => {\n  const pathname = decodeURIComponent(rawPathname)\n  // Remove the pathPrefix from the pathname.\n  const trimmedPathname = stripPrefix(pathname, __BASE_PATH__)\n    // Remove any hashfragment\n    .split(`#`)[0]\n    // Remove search query\n    .split(`?`)[0]\n\n  return trimmedPathname\n}\n\n/**\n * Set list of matchPaths\n *\n * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths\n */\nexport const setMatchPaths = value => {\n  matchPaths = value\n}\n\n/**\n * Return a matchpath url\n * if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n * `/foo?bar=far` => `/page1`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string|null}\n */\nexport const findMatchPath = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  for (const { matchPath, path } of matchPaths) {\n    if (match(matchPath, trimmedPathname)) {\n      return normalizePagePath(path)\n    }\n  }\n\n  return null\n}\n\n// Given a raw URL path, returns the cleaned version of it (trim off\n// `#` and query params), or if it matches an entry in\n// `match-paths.json`, its matched path is returned\n//\n// E.g. `/foo?bar=far` => `/foo`\n//\n// Or if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n// `/foo?bar=far` => `/page1`\nexport const findPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname)\n  }\n\n  let foundPath = findMatchPath(trimmedPathname)\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname)\n  }\n\n  pathCache.set(trimmedPathname, foundPath)\n\n  return foundPath\n}\n\n/**\n * Clean a url and converts /index.html => /\n * E.g. `/foo?bar=far` => `/foo`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string}\n */\nexport const cleanPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  let foundPath = trimmedPathname\n  if (foundPath === `/index.html`) {\n    foundPath = `/`\n  }\n\n  foundPath = normalizePagePath(foundPath)\n\n  return foundPath\n}\n","import prefetchHelper from \"./prefetch\"\nimport emitter from \"./emitter\"\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\"\n\n/**\n * Available resource loading statuses\n */\nexport const PageResourceStatus = {\n  /**\n   * At least one of critical resources failed to load\n   */\n  Error: `error`,\n  /**\n   * Resources loaded successfully\n   */\n  Success: `success`,\n}\n\nconst preferDefault = m => (m && m.default) || m\n\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s\n  return s\n}\n\nconst createPageDataUrl = path => {\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path)\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json`\n}\n\nconst doFetch = (url, method = `GET`) =>\n  new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(method, url, true)\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req)\n      }\n    }\n    req.send(null)\n  })\n\nconst loadPageDataJson = loadObj => {\n  const { pagePath, retries = 0 } = loadObj\n  const url = createPageDataUrl(pagePath)\n  return doFetch(url).then(req => {\n    const { status, responseText } = req\n\n    // Handle 200\n    if (status === 200) {\n      try {\n        const jsonPayload = JSON.parse(responseText)\n        if (jsonPayload.path === undefined) {\n          throw new Error(`not a valid pageData response`)\n        }\n\n        return Object.assign(loadObj, {\n          status: PageResourceStatus.Success,\n          payload: jsonPayload,\n        })\n      } catch (err) {\n        // continue regardless of error\n      }\n    }\n\n    // Handle 404\n    if (status === 404 || status === 200) {\n      // If the request was for a 404 page and it doesn't exist, we're done\n      if (pagePath === `/404.html`) {\n        return Object.assign(loadObj, {\n          status: PageResourceStatus.Error,\n        })\n      }\n\n      // Need some code here to cache the 404 request. In case\n      // multiple loadPageDataJsons result in 404s\n      return loadPageDataJson(\n        Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n      )\n    }\n\n    // handle 500 response (Unrecoverable)\n    if (status === 500) {\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error,\n      })\n    }\n\n    // Handle everything else, including status === 0, and 503s. Should retry\n    if (retries < 3) {\n      return loadPageDataJson(Object.assign(loadObj, { retries: retries + 1 }))\n    }\n\n    // Retried 3 times already, result is an error.\n    return Object.assign(loadObj, {\n      status: PageResourceStatus.Error,\n    })\n  })\n}\n\nconst doesConnectionSupportPrefetch = () => {\n  if (\n    `connection` in navigator &&\n    typeof navigator.connection !== `undefined`\n  ) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false\n    }\n    if (navigator.connection.saveData) {\n      return false\n    }\n  }\n  return true\n}\n\nconst toPageResources = (pageData, component = null) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n  }\n\n  return {\n    component,\n    json: pageData.result,\n    page,\n  }\n}\n\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: PageResourceStatus.Success || PageResourceStatus.Error,\n    //   payload: PageResources, // undefined if PageResourceStatus.Error\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //   }\n    // }\n    this.pageDb = new Map()\n    this.inFlightDb = new Map()\n    this.pageDataDb = new Map()\n    this.prefetchTriggered = new Set()\n    this.prefetchCompleted = new Set()\n    this.loadComponent = loadComponent\n    setMatchPaths(matchPaths)\n  }\n\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a)\n  }\n\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDataDb.has(pagePath)) {\n      return Promise.resolve(this.pageDataDb.get(pagePath))\n    }\n\n    return loadPageDataJson({ pagePath }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath)\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath)\n      return Promise.resolve(page.payload)\n    }\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath)\n    }\n\n    const inFlight = Promise.all([\n      this.loadAppData(),\n      this.loadPageDataJson(pagePath),\n    ])\n      .then(allData => {\n        const result = allData[1]\n        if (result.status === PageResourceStatus.Error) {\n          return {\n            status: PageResourceStatus.Error,\n          }\n        }\n\n        let pageData = result.payload\n        const { componentChunkName } = pageData\n        return this.loadComponent(componentChunkName).then(component => {\n          const finalResult = { createdAt: new Date() }\n          let pageResources\n          if (!component) {\n            finalResult.status = PageResourceStatus.Error\n          } else {\n            finalResult.status = PageResourceStatus.Success\n            if (result.notFound === true) {\n              finalResult.notFound = true\n            }\n            pageData = Object.assign(pageData, {\n              webpackCompilationHash: allData[0]\n                ? allData[0].webpackCompilationHash\n                : ``,\n            })\n            pageResources = toPageResources(pageData, component)\n            finalResult.payload = pageResources\n            emitter.emit(`onPostLoadPageResources`, {\n              page: pageResources,\n              pageResources,\n            })\n          }\n          this.pageDb.set(pagePath, finalResult)\n          // undefined if final result is an error\n          return pageResources\n        })\n      })\n      // prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n      .then(response => {\n        this.inFlightDb.delete(pagePath)\n        return response\n      })\n      .catch(err => {\n        this.inFlightDb.delete(pagePath)\n        throw err\n      })\n\n    this.inFlightDb.set(pagePath, inFlight)\n    return inFlight\n  }\n\n  // returns undefined if loading page ran into errors\n  loadPageSync(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      return this.pageDb.get(pagePath).payload\n    }\n    return undefined\n  }\n\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false\n    }\n\n    return true\n  }\n\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return false\n    }\n\n    // Tell plugins with custom prefetching logic that they should start\n    // prefetching this path.\n    if (!this.prefetchTriggered.has(pagePath)) {\n      this.apiRunner(`onPrefetchPathname`, { pathname: pagePath })\n      this.prefetchTriggered.add(pagePath)\n    }\n\n    // If a plugin has disabled core prefetching, stop now.\n    if (this.prefetchDisabled) {\n      return false\n    }\n\n    const realPath = findPath(pagePath)\n    // Todo make doPrefetch logic cacheable\n    // eslint-disable-next-line consistent-return\n    this.doPrefetch(realPath).then(() => {\n      if (!this.prefetchCompleted.has(pagePath)) {\n        this.apiRunner(`onPostPrefetchPathname`, { pathname: pagePath })\n        this.prefetchCompleted.add(pagePath)\n      }\n    })\n\n    return true\n  }\n\n  doPrefetch(pagePath) {\n    throw new Error(`doPrefetch not implemented`)\n  }\n\n  hovering(rawPath) {\n    this.loadPage(rawPath)\n  }\n\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDataDb.get(pagePath)\n    if (page) {\n      const pageResources = toPageResources(page.payload)\n\n      return [\n        ...createComponentUrls(pageResources.page.componentChunkName),\n        createPageDataUrl(pagePath),\n      ]\n    } else {\n      return null\n    }\n  }\n\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDb.get(pagePath)\n    return page && page.notFound === true\n  }\n\n  loadAppData(retries = 0) {\n    return doFetch(`${__PATH_PREFIX__}/page-data/app-data.json`).then(req => {\n      const { status, responseText } = req\n\n      let appData\n\n      if (status !== 200 && retries < 3) {\n        // Retry 3 times incase of non-200 responses\n        return this.loadAppData(retries + 1)\n      }\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText)\n          if (jsonPayload.webpackCompilationHash === undefined) {\n            throw new Error(`not a valid app-data response`)\n          }\n\n          appData = jsonPayload\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      return appData\n    })\n  }\n}\n\nconst createComponentUrls = componentChunkName =>\n  (window.___chunkMapping[componentChunkName] || []).map(\n    chunk => __PATH_PREFIX__ + chunk\n  )\n\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths) {\n    const loadComponent = chunkName =>\n      asyncRequires.components[chunkName]\n        ? asyncRequires.components[chunkName]()\n            .then(preferDefault)\n            // loader will handle the case when component is null\n            .catch(() => null)\n        : Promise.resolve()\n\n    super(loadComponent, matchPaths)\n  }\n\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath)\n    return prefetchHelper(pageDataUrl, {\n      crossOrigin: `anonymous`,\n      as: `fetch`,\n    })\n      .then(() =>\n        // This was just prefetched, so will return a response from\n        // the cache instead of making another request to the server\n        this.loadPageDataJson(pagePath)\n      )\n      .then(result => {\n        if (result.status !== PageResourceStatus.Success) {\n          return Promise.resolve()\n        }\n        const pageData = result.payload\n        const chunkName = pageData.componentChunkName\n        const componentUrls = createComponentUrls(chunkName)\n        return Promise.all(componentUrls.map(prefetchHelper)).then(\n          () => pageData\n        )\n      })\n  }\n\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      if (data.notFound) {\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error,\n            }\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data\n        })\n      }\n      return data\n    })\n  }\n}\n\nlet instance\n\nexport const setLoader = _loader => {\n  instance = _loader\n}\n\nexport const publicLoader = {\n  // Deprecated methods. As far as we're aware, these are only used by\n  // core gatsby and the offline plugin, however there's a very small\n  // chance they're called by others.\n  getResourcesForPathname: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathname is deprecated. Use loadPage instead`\n    )\n    return instance.i.loadPage(rawPath)\n  },\n  getResourcesForPathnameSync: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead`\n    )\n    return instance.i.loadPageSync(rawPath)\n  },\n  enqueue: rawPath => instance.prefetch(rawPath),\n\n  // Real methods\n  getResourceURLsForPathname: rawPath =>\n    instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  loadPageSync: rawPath => instance.loadPageSync(rawPath),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData(),\n}\n\nexport default publicLoader\n","const preferDefault = m => (m && m.default) || m\n\nif (process.env.BUILD_STAGE === `develop`) {\n  module.exports = preferDefault(require(`./public-page-renderer-dev`))\n} else if (process.env.BUILD_STAGE === `build-javascript`) {\n  module.exports = preferDefault(require(`./public-page-renderer-prod`))\n} else {\n  module.exports = () => null\n}\n","import React from \"react\"\n\nexport default React.createContext\n","// prefer default export if available\nconst preferDefault = m => m && m.default || m\n\nexports.components = {\n  \"component---cache-caches-gatsby-plugin-offline-app-shell-js\": () => import(\"./caches/gatsby-plugin-offline/app-shell.js\" /* webpackChunkName: \"component---cache-caches-gatsby-plugin-offline-app-shell-js\" */),\n  \"component---src-pages-404-js\": () => import(\"./../src/pages/404.js\" /* webpackChunkName: \"component---src-pages-404-js\" */),\n  \"component---src-pages-about-js\": () => import(\"./../src/pages/about.js\" /* webpackChunkName: \"component---src-pages-about-js\" */),\n  \"component---src-pages-account-js\": () => import(\"./../src/pages/account.js\" /* webpackChunkName: \"component---src-pages-account-js\" */),\n  \"component---src-templates-game-post-js\": () => import(\"./../src/templates/game-post.js\" /* webpackChunkName: \"component---src-templates-game-post-js\" */),\n  \"component---src-templates-press-js\": () => import(\"./../src/templates/press.js\" /* webpackChunkName: \"component---src-templates-press-js\" */),\n  \"component---src-templates-report-js\": () => import(\"./../src/templates/report.js\" /* webpackChunkName: \"component---src-templates-report-js\" */),\n  \"component---src-templates-teachers-js\": () => import(\"./../src/templates/teachers.js\" /* webpackChunkName: \"component---src-templates-teachers-js\" */)\n}\n\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\n\nimport InternalPageRenderer from \"./page-renderer\"\n\nconst ProdPageRenderer = ({ location, pageResources }) => {\n  if (!pageResources) {\n    return null\n  }\n  return React.createElement(InternalPageRenderer, {\n    location,\n    pageResources,\n    ...pageResources.json,\n  })\n}\n\nProdPageRenderer.propTypes = {\n  location: PropTypes.shape({\n    pathname: PropTypes.string.isRequired,\n  }).isRequired,\n}\n\nexport default ProdPageRenderer\n","const plugins = require(`./api-runner-browser-plugins`)\nconst {\n  getResourcesForPathname,\n  getResourcesForPathnameSync,\n  getResourceURLsForPathname,\n  loadPage,\n  loadPageSync,\n} = require(`./loader`).publicLoader\n\nexports.apiRunner = (api, args = {}, defaultReturn, argTransform) => {\n  // Hooks for gatsby-cypress's API handler\n  if (process.env.CYPRESS_SUPPORT) {\n    if (window.___apiHandler) {\n      window.___apiHandler(api)\n    } else if (window.___resolvedAPIs) {\n      window.___resolvedAPIs.push(api)\n    } else {\n      window.___resolvedAPIs = [api]\n    }\n  }\n\n  let results = plugins.map(plugin => {\n    if (!plugin.plugin[api]) {\n      return undefined\n    }\n\n    // Deprecated April 2019. Use `loadPageSync` instead\n    args.getResourcesForPathnameSync = getResourcesForPathnameSync\n    // Deprecated April 2019. Use `loadPage` instead\n    args.getResourcesForPathname = getResourcesForPathname\n    args.getResourceURLsForPathname = getResourceURLsForPathname\n    args.loadPage = loadPage\n    args.loadPageSync = loadPageSync\n\n    const result = plugin.plugin[api](args, plugin.options)\n    if (result && argTransform) {\n      args = argTransform({ args, result, plugin })\n    }\n    return result\n  })\n\n  // Filter out undefined results.\n  results = results.filter(result => typeof result !== `undefined`)\n\n  if (results.length > 0) {\n    return results\n  } else if (defaultReturn) {\n    return [defaultReturn]\n  } else {\n    return []\n  }\n}\n\nexports.apiRunnerAsync = (api, args, defaultReturn) =>\n  plugins.reduce(\n    (previous, next) =>\n      next.plugin[api]\n        ? previous.then(() => next.plugin[api](args, next.options))\n        : previous,\n    Promise.resolve()\n  )\n"],"sourceRoot":""}